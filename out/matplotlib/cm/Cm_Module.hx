/* This file is generated, do not edit! */
package matplotlib.cm;
@:pythonImport("matplotlib.cm") extern class Cm_Module {
	static public function Accent(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Accent_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Blues(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Blues_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BrBG(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BrBG_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuPu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function BuPu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function CMRmap(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function CMRmap_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Dark2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Dark2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function GnBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function GnBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greens(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greens_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greys(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Greys_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var LUTSIZE : Dynamic;
	static public function OrRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function OrRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Oranges(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Oranges_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PRGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PRGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Paired(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Paired_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel1(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel1_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Pastel2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PiYG(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PiYG_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBuGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBuGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuOr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuOr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function PuRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Purples(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Purples_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdGy(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdGy_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdPu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdPu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function RdYlGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Reds(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Reds_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set1(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set1_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set3(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Set3_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Spectral(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Spectral_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Wistia(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function Wistia_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGnBu(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGnBu_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlGn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrBr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrBr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrRd(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function YlOrRd_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	/**
		Generates the requested cmap from its *name*.  The lut size is
		*lutsize*.
	**/
	static public function _generate_cmap(name:Dynamic, lutsize:Dynamic):Dynamic;
	/**
		Reverses cmap specification *spec*, can handle both dict and tuple
		type specs.
	**/
	static public function _reverse_cmap_spec(spec:Dynamic):Dynamic;
	/**
		Helper such that ``_reverser(f)(x) == f(1 - x)``.
	**/
	static public function _reverser(f:Dynamic, ?x:Dynamic):Dynamic;
	static public function afmhot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function afmhot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function autumn(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function autumn_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function binary(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function binary_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bone(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bone_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function brg(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function brg_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bwr(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function bwr_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cividis(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cividis_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var cmap_d : Dynamic;
	static public var cmapname : Dynamic;
	static public var cmaps_listed : Dynamic;
	static public function cool(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cool_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function coolwarm(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function coolwarm_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function copper(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function copper_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cubehelix(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function cubehelix_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public var datad : Dynamic;
	static public function flag(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function flag_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	/**
		Get a colormap instance, defaulting to rc values if *name* is None.
		
		Colormaps added with :func:`register_cmap` take precedence over
		built-in colormaps.
		
		If *name* is a :class:`matplotlib.colors.Colormap` instance, it will be
		returned.
		
		If *lut* is not None it must be an integer giving the number of
		entries desired in the lookup table, and *name* must be a standard
		mpl colormap name.
	**/
	static public function get_cmap(?name:Dynamic, ?lut:Dynamic):Dynamic;
	static public function gist_earth(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_earth_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_gray(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_gray_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_heat(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_heat_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_ncar(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_ncar_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_rainbow(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_rainbow_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_stern(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_stern_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_yarg(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gist_yarg_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot2(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot2_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gnuplot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gray(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function gray_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hot(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hot_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hsv(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function hsv_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function inferno(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function inferno_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function jet(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function jet_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function magma(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function magma_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function nipy_spectral(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function nipy_spectral_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function ocean(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function ocean_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function pink(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function pink_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function plasma(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function plasma_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function prism(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function prism_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function rainbow(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function rainbow_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	/**
		Add a colormap to the set recognized by :func:`get_cmap`.
		
		It can be used in two ways::
		
		    register_cmap(name='swirly', cmap=swirly_cmap)
		
		    register_cmap(name='choppy', data=choppydata, lut=128)
		
		In the first case, *cmap* must be a :class:`matplotlib.colors.Colormap`
		instance.  The *name* is optional; if absent, the name will
		be the :attr:`~matplotlib.colors.Colormap.name` attribute of the *cmap*.
		
		In the second case, the three arguments are passed to
		the :class:`~matplotlib.colors.LinearSegmentedColormap` initializer,
		and the resulting colormap is registered.
	**/
	static public function register_cmap(?name:Dynamic, ?cmap:Dynamic, ?data:Dynamic, ?lut:Dynamic):Dynamic;
	/**
		Can only handle specification *data* in dictionary format.
	**/
	static public function revcmap(data:Dynamic):Dynamic;
	static public function seismic(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function seismic_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function spring(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function spring_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function summer(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function summer_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab10(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab10_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20b(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20b_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20c(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function tab20c_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function terrain(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function terrain_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_shifted(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function twilight_shifted_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function viridis(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function viridis_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function winter(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
	static public function winter_r(X:Dynamic, ?alpha:Dynamic, ?bytes:Dynamic):Dynamic;
}