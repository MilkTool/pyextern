/* This file is generated, do not edit! */
package matplotlib.pylab;
@:pythonImport("matplotlib.pylab") extern class Pylab_Module {
	static public var ALLOW_THREADS : Dynamic;
	static public var BUFSIZE : Dynamic;
	static public var CLIP : Dynamic;
	static public var DAILY : Dynamic;
	static public var ERR_CALL : Dynamic;
	static public var ERR_DEFAULT : Dynamic;
	static public var ERR_IGNORE : Dynamic;
	static public var ERR_LOG : Dynamic;
	static public var ERR_PRINT : Dynamic;
	static public var ERR_RAISE : Dynamic;
	static public var ERR_WARN : Dynamic;
	static public var FLOATING_POINT_SUPPORT : Dynamic;
	static public var FPE_DIVIDEBYZERO : Dynamic;
	static public var FPE_INVALID : Dynamic;
	static public var FPE_OVERFLOW : Dynamic;
	static public var FPE_UNDERFLOW : Dynamic;
	static public function FR(n:Dynamic):Dynamic;
	static public var False_ : Dynamic;
	static public var HOURLY : Dynamic;
	static public var Inf : Dynamic;
	static public var Infinity : Dynamic;
	static public var MAXDIMS : Dynamic;
	static public var MAY_SHARE_BOUNDS : Dynamic;
	static public var MAY_SHARE_EXACT : Dynamic;
	static public var MINUTELY : Dynamic;
	static public function MO(n:Dynamic):Dynamic;
	static public var MONTHLY : Dynamic;
	static public var NAN : Dynamic;
	static public var NINF : Dynamic;
	static public var NZERO : Dynamic;
	static public var NaN : Dynamic;
	static public var PINF : Dynamic;
	static public var PZERO : Dynamic;
	static public var RAISE : Dynamic;
	static public function SA(n:Dynamic):Dynamic;
	static public var SECONDLY : Dynamic;
	static public var SHIFT_DIVIDEBYZERO : Dynamic;
	static public var SHIFT_INVALID : Dynamic;
	static public var SHIFT_OVERFLOW : Dynamic;
	static public var SHIFT_UNDERFLOW : Dynamic;
	static public function SU(n:Dynamic):Dynamic;
	static public var ScalarType : Dynamic;
	static public function TH(n:Dynamic):Dynamic;
	static public function TU(n:Dynamic):Dynamic;
	static public var True_ : Dynamic;
	static public var UFUNC_BUFSIZE_DEFAULT : Dynamic;
	static public var UFUNC_PYVALS_NAME : Dynamic;
	static public function WE(n:Dynamic):Dynamic;
	static public var WEEKLY : Dynamic;
	static public var WRAP : Dynamic;
	static public var YEARLY : Dynamic;
	static public var _UFUNC_API : Dynamic;
	static public var __builtins__ : Dynamic;
	static public var __cached__ : Dynamic;
	static public var __doc__ : Dynamic;
	static public var __file__ : Dynamic;
	static public var __loader__ : Dynamic;
	static public var __name__ : Dynamic;
	static public var __package__ : Dynamic;
	static public var __spec__ : Dynamic;
	static public var __version__ : Dynamic;
	/**
		add_ufunc_docstring(ufunc, new_docstring)
		
		Replace the docstring for a ufunc with new_docstring.
		This method will only work if the current docstring for
		the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)
		
		Parameters
		----------
		ufunc : numpy.ufunc
		    A ufunc whose current doc is NULL.
		new_docstring : string
		    The new docstring for the ufunc.
		
		Notes
		-----
		This method allocates memory for new_docstring on
		the heap. Technically this creates a mempory leak, since this
		memory will not be reclaimed until the end of the program
		even if the ufunc itself is removed. However this will only
		be a problem if the user is repeatedly creating ufuncs with
		no documentation, adding documentation via add_newdoc_ufunc,
		and then throwing away the ufunc.
	**/
	static public function _add_newdoc_ufunc(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		_arg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		DO NOT USE, ONLY FOR TESTING
	**/
	static public function _arg(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Calculate the absolute value element-wise.
		
		``np.abs`` is a shorthand for this function.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		absolute : ndarray
		    An ndarray containing the absolute value of
		    each element in `x`.  For complex input, ``a + ib``, the
		    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> x = np.array([-1.2, 1.2])
		>>> np.absolute(x)
		array([ 1.2,  1.2])
		>>> np.absolute(1.2 + 1j)
		1.5620499351813308
		
		Plot the function over ``[-10, 10]``:
		
		>>> import matplotlib.pyplot as plt
		
		>>> x = np.linspace(start=-10, stop=10, num=101)
		>>> plt.plot(x, np.absolute(x))
		>>> plt.show()
		
		Plot the function over the complex plane:
		
		>>> xx = x + 1j * x[:, np.newaxis]
		>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
		>>> plt.show()
	**/
	static public function absolute(args:haxe.extern.Rest<Dynamic>):Dynamic;
	static public var absolute_import : Dynamic;
	/**
		Plot the autocorrelation of *x*.
		
		Parameters
		----------
		x : array-like
		
		detrend : callable, optional, default: `mlab.detrend_none`
		    *x* is detrended by the *detrend* callable. This must be a
		    function ``x = detrend(x)`` accepting and returning an
		    `numpy.array`. Default is no normalization.
		
		normed : bool, optional, default: True
		    If ``True``, input vectors are normalised to unit length.
		
		usevlines : bool, optional, default: True
		    Determines the plot style.
		
		    If ``True``, vertical lines are plotted from 0 to the acorr value
		    using `Axes.vlines`. Additionally, a horizontal line is plotted
		    at y=0 using `Axes.axhline`.
		
		    If ``False``, markers are plotted at the acorr values using
		    `Axes.plot`.
		
		maxlags : int, optional, default: 10
		    Number of lags to show. If ``None``, will return all
		    ``2 * len(x) - 1`` lags.
		
		Returns
		-------
		lags : array (length ``2*maxlags+1``)
		    The lag vector.
		c : array  (length ``2*maxlags+1``)
		    The auto correlation vector.
		line : `.LineCollection` or `.Line2D`
		    `.Artist` added to the axes of the correlation:
		
		    - `.LineCollection` if *usevlines* is True.
		    - `.Line2D` if *usevlines* is False.
		b : `.Line2D` or None
		    Horizontal line at 0 if *usevlines* is True
		    None *usevlines* is False.
		
		Other Parameters
		----------------
		linestyle : `.Line2D` property, optional
		    The linestyle for plotting the data points.
		    Only used if *usevlines* is ``False``.
		
		marker : str, optional, default: 'o'
		    The marker for plotting the data points.
		    Only used if *usevlines* is ``False``.
		
		Notes
		-----
		The cross correlation is performed with :func:`numpy.correlate` with
		``mode = "full"``.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function acorr(x:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Add arguments element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays to be added.  If ``x1.shape != x2.shape``, they must be
		    broadcastable to a common shape (which may be the shape of one or
		    the other).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		add : ndarray or scalar
		    The sum of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		Equivalent to `x1` + `x2` in terms of array broadcasting.
		
		Examples
		--------
		>>> np.add(1.0, 4.0)
		5.0
		>>> x1 = np.arange(9.0).reshape((3, 3))
		>>> x2 = np.arange(3.0)
		>>> np.add(x1, x2)
		array([[  0.,   2.,   4.],
		       [  3.,   5.,   7.],
		       [  6.,   8.,  10.]])
	**/
	static public function add(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		add_docstring(obj, docstring)
		
		Add a docstring to a built-in obj if possible.
		If the obj already has a docstring raise a RuntimeError
		If this routine does not know how to add a docstring to the object
		raise a TypeError
	**/
	static public function add_docstring(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Adds documentation to obj which is in module place.
		
		If doc is a string add it to obj as a docstring
		
		If doc is a tuple, then the first element is interpreted as
		   an attribute of obj and the second as the docstring
		      (method, docstring)
		
		If doc is a list, then each element of the list should be a
		   sequence of length two --> [(method1, docstring1),
		   (method2, docstring2), ...]
		
		This routine never raises an error.
		
		This routine cannot modify read-only docstrings, as appear
		in new-style classes or built-in functions. Because this
		routine never raises an error the caller must check manually
		that the docstrings were changed.
	**/
	static public function add_newdoc(place:Dynamic, obj:Dynamic, doc:Dynamic):Dynamic;
	/**
		add_ufunc_docstring(ufunc, new_docstring)
		
		Replace the docstring for a ufunc with new_docstring.
		This method will only work if the current docstring for
		the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)
		
		Parameters
		----------
		ufunc : numpy.ufunc
		    A ufunc whose current doc is NULL.
		new_docstring : string
		    The new docstring for the ufunc.
		
		Notes
		-----
		This method allocates memory for new_docstring on
		the heap. Technically this creates a mempory leak, since this
		memory will not be reclaimed until the end of the program
		even if the ufunc itself is removed. However this will only
		be a problem if the user is repeatedly creating ufuncs with
		no documentation, adding documentation via add_newdoc_ufunc,
		and then throwing away the ufunc.
	**/
	static public function add_newdoc_ufunc(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the length of the first dimension of the input array.
		
		Parameters
		----------
		a : array_like
		   Input array.
		
		Returns
		-------
		alen : int
		   Length of the first dimension of `a`.
		
		See Also
		--------
		shape, size
		
		Examples
		--------
		>>> a = np.zeros((7,4,5))
		>>> a.shape[0]
		7
		>>> np.alen(a)
		7
	**/
	static public function alen(a:Dynamic):Int;
	/**
		Test whether all array elements along a given axis evaluate to True.
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which a logical AND reduction is performed.
		    The default (`axis` = `None`) is to perform a logical AND over all
		    the dimensions of the input array. `axis` may be negative, in
		    which case it counts from the last to the first axis.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, a reduction is performed on multiple
		    axes, instead of a single axis or all the axes as before.
		out : ndarray, optional
		    Alternate output array in which to place the result.
		    It must have the same shape as the expected output and its
		    type is preserved (e.g., if ``dtype(out)`` is float, the result
		    will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
		    "Output arguments") for more details.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `all` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		all : ndarray, bool
		    A new boolean or array is returned unless `out` is specified,
		    in which case a reference to `out` is returned.
		
		See Also
		--------
		ndarray.all : equivalent method
		
		any : Test whether any element along a given axis evaluates to True.
		
		Notes
		-----
		Not a Number (NaN), positive infinity and negative infinity
		evaluate to `True` because these are not equal to zero.
		
		Examples
		--------
		>>> np.all([[True,False],[True,True]])
		False
		
		>>> np.all([[True,False],[True,True]], axis=0)
		array([ True, False])
		
		>>> np.all([-1, 4, 5])
		True
		
		>>> np.all([1.0, np.nan])
		True
		
		>>> o=np.array([False])
		>>> z=np.all([-1, 4, 5], out=o)
		>>> id(z), id(o), z                             # doctest: +SKIP
		(28293632, 28293632, array([ True]))
	**/
	static public function all(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Returns True if two arrays are element-wise equal within a tolerance.
		
		The tolerance values are positive, typically very small numbers.  The
		relative difference (`rtol` * abs(`b`)) and the absolute difference
		`atol` are added together to compare against the absolute difference
		between `a` and `b`.
		
		If either array contains one or more NaNs, False is returned.
		Infs are treated as equal if they are in the same place and of the same
		sign in both arrays.
		
		Parameters
		----------
		a, b : array_like
		    Input arrays to compare.
		rtol : float
		    The relative tolerance parameter (see Notes).
		atol : float
		    The absolute tolerance parameter (see Notes).
		equal_nan : bool
		    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
		    considered equal to NaN's in `b` in the output array.
		
		    .. versionadded:: 1.10.0
		
		Returns
		-------
		allclose : bool
		    Returns True if the two arrays are equal within the given
		    tolerance; False otherwise.
		
		See Also
		--------
		isclose, all, any, equal
		
		Notes
		-----
		If the following equation is element-wise True, then allclose returns
		True.
		
		 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
		
		The above equation is not symmetric in `a` and `b`, so that
		``allclose(a, b)`` might be different from ``allclose(b, a)`` in
		some rare cases.
		
		The comparison of `a` and `b` uses standard broadcasting, which
		means that `a` and `b` need not have the same shape in order for
		``allclose(a, b)`` to evaluate to True.  The same is true for
		`equal` but not `array_equal`.
		
		Examples
		--------
		>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
		False
		>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
		True
		>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
		False
		>>> np.allclose([1.0, np.nan], [1.0, np.nan])
		False
		>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
		True
	**/
	static public function allclose(a:Dynamic, b:Dynamic, ?rtol:Dynamic, ?atol:Dynamic, ?equal_nan:Dynamic):Bool;
	/**
		Check if all elements of input array are true.
		
		See Also
		--------
		numpy.all : Equivalent function; see for details.
	**/
	static public function alltrue(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the maximum of an array or maximum along an axis.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which to operate.  By default, flattened input is
		    used.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, the maximum is selected over multiple axes,
		    instead of a single axis or all the axes as before.
		out : ndarray, optional
		    Alternative output array in which to place the result.  Must
		    be of the same shape and buffer length as the expected output.
		    See `doc.ufuncs` (Section "Output arguments") for more details.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `amax` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		initial : scalar, optional
		    The minimum value of an output element. Must be present to allow
		    computation on empty slice. See `~numpy.ufunc.reduce` for details.
		
		    .. versionadded:: 1.15.0
		
		
		Returns
		-------
		amax : ndarray or scalar
		    Maximum of `a`. If `axis` is None, the result is a scalar value.
		    If `axis` is given, the result is an array of dimension
		    ``a.ndim - 1``.
		
		See Also
		--------
		amin :
		    The minimum value of an array along a given axis, propagating any NaNs.
		nanmax :
		    The maximum value of an array along a given axis, ignoring any NaNs.
		maximum :
		    Element-wise maximum of two arrays, propagating any NaNs.
		fmax :
		    Element-wise maximum of two arrays, ignoring any NaNs.
		argmax :
		    Return the indices of the maximum values.
		
		nanmin, minimum, fmin
		
		Notes
		-----
		NaN values are propagated, that is if at least one item is NaN, the
		corresponding max value will be NaN as well. To ignore NaN values
		(MATLAB behavior), please use nanmax.
		
		Don't use `amax` for element-wise comparison of 2 arrays; when
		``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
		``amax(a, axis=0)``.
		
		Examples
		--------
		>>> a = np.arange(4).reshape((2,2))
		>>> a
		array([[0, 1],
		       [2, 3]])
		>>> np.amax(a)           # Maximum of the flattened array
		3
		>>> np.amax(a, axis=0)   # Maxima along the first axis
		array([2, 3])
		>>> np.amax(a, axis=1)   # Maxima along the second axis
		array([1, 3])
		
		>>> b = np.arange(5, dtype=float)
		>>> b[2] = np.NaN
		>>> np.amax(b)
		nan
		>>> np.nanmax(b)
		4.0
		
		You can use an initial value to compute the maximum of an empty slice, or
		to initialize it to a different value:
		
		>>> np.max([[-50], [10]], axis=-1, initial=0)
		array([ 0, 10])
		
		Notice that the initial value is used as one of the elements for which the
		maximum is determined, unlike for the default argument Python's max
		function, which is only used for empty iterables.
		
		>>> np.max([5], initial=6)
		6
		>>> max([5], default=6)
		5
	**/
	static public function amax(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic, ?initial:Dynamic):Dynamic;
	/**
		Return the minimum of an array or minimum along an axis.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which to operate.  By default, flattened input is
		    used.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, the minimum is selected over multiple axes,
		    instead of a single axis or all the axes as before.
		out : ndarray, optional
		    Alternative output array in which to place the result.  Must
		    be of the same shape and buffer length as the expected output.
		    See `doc.ufuncs` (Section "Output arguments") for more details.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `amin` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		initial : scalar, optional
		    The maximum value of an output element. Must be present to allow
		    computation on empty slice. See `~numpy.ufunc.reduce` for details.
		
		    .. versionadded:: 1.15.0
		
		Returns
		-------
		amin : ndarray or scalar
		    Minimum of `a`. If `axis` is None, the result is a scalar value.
		    If `axis` is given, the result is an array of dimension
		    ``a.ndim - 1``.
		
		See Also
		--------
		amax :
		    The maximum value of an array along a given axis, propagating any NaNs.
		nanmin :
		    The minimum value of an array along a given axis, ignoring any NaNs.
		minimum :
		    Element-wise minimum of two arrays, propagating any NaNs.
		fmin :
		    Element-wise minimum of two arrays, ignoring any NaNs.
		argmin :
		    Return the indices of the minimum values.
		
		nanmax, maximum, fmax
		
		Notes
		-----
		NaN values are propagated, that is if at least one item is NaN, the
		corresponding min value will be NaN as well. To ignore NaN values
		(MATLAB behavior), please use nanmin.
		
		Don't use `amin` for element-wise comparison of 2 arrays; when
		``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
		``amin(a, axis=0)``.
		
		Examples
		--------
		>>> a = np.arange(4).reshape((2,2))
		>>> a
		array([[0, 1],
		       [2, 3]])
		>>> np.amin(a)           # Minimum of the flattened array
		0
		>>> np.amin(a, axis=0)   # Minima along the first axis
		array([0, 1])
		>>> np.amin(a, axis=1)   # Minima along the second axis
		array([0, 2])
		
		>>> b = np.arange(5, dtype=float)
		>>> b[2] = np.NaN
		>>> np.amin(b)
		nan
		>>> np.nanmin(b)
		0.0
		
		>>> np.min([[-50], [10]], axis=-1, initial=0)
		array([-50,   0])
		
		Notice that the initial value is used as one of the elements for which the
		minimum is determined, unlike for the default argument Python's max
		function, which is only used for empty iterables.
		
		Notice that this isn't the same as Python's ``default`` argument.
		
		>>> np.min([6], initial=5)
		5
		>>> min([6], default=5)
		6
	**/
	static public function amin(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic, ?initial:Dynamic):Dynamic;
	/**
		Return the angle of the complex argument.
		
		Parameters
		----------
		z : array_like
		    A complex number or sequence of complex numbers.
		deg : bool, optional
		    Return angle in degrees if True, radians if False (default).
		
		Returns
		-------
		angle : ndarray or scalar
		    The counterclockwise angle from the positive real axis on
		    the complex plane, with dtype as numpy.float64.
		    
		    ..versionchanged:: 1.16.0
		        This function works on subclasses of ndarray like `ma.array`.
		
		See Also
		--------
		arctan2
		absolute
		
		Examples
		--------
		>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
		array([ 0.        ,  1.57079633,  0.78539816])
		>>> np.angle(1+1j, deg=True)                  # in degrees
		45.0
	**/
	static public function angle(z:Dynamic, ?deg:Dynamic):Dynamic;
	/**
		Plot the angle spectrum.
		
		Compute the angle spectrum (wrapped phase spectrum) of *x*.
		Data is padded to a length of *pad_to* and the windowing function
		*window* is applied to the signal.
		
		Parameters
		----------
		x : 1-D array or sequence
		    Array or sequence containing the data.
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  While not increasing the actual resolution of
		    the spectrum (the minimum distance between resolvable peaks),
		    this can give more points in the plot, allowing for more
		    detail. This corresponds to the *n* parameter in the call to fft().
		    The default is None, which sets *pad_to* equal to the length of the
		    input signal (i.e. no padding).
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		Returns
		-------
		spectrum : 1-D array
		    The values for the angle spectrum in radians (real valued).
		
		freqs : 1-D array
		    The frequencies corresponding to the elements in *spectrum*.
		
		line : a :class:`~matplotlib.lines.Line2D` instance
		    The line created by this function.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See Also
		--------
		:func:`magnitude_spectrum`
		    :func:`angle_spectrum` plots the magnitudes of the corresponding
		    frequencies.
		
		:func:`phase_spectrum`
		    :func:`phase_spectrum` plots the unwrapped version of this
		    function.
		
		:func:`specgram`
		    :func:`specgram` can plot the angle spectrum of segments within the
		    signal in a colormap.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function angle_spectrum(x:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?window:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Annotate the point *xy* with text *text*.
		
		In the simplest form, the text is placed at *xy*.
		
		Optionally, the text can be displayed in another position *xytext*.
		An arrow pointing from the text to the annotated point *xy* can then
		be added by defining *arrowprops*.
		
		Parameters
		----------
		text : str
		    The text of the annotation.  *s* is a deprecated synonym for this
		    parameter.
		
		xy : (float, float)
		    The point *(x,y)* to annotate.
		
		xytext : (float, float), optional
		    The position *(x,y)* to place the text at.
		    If *None*, defaults to *xy*.
		
		xycoords : str, `.Artist`, `.Transform`, callable or tuple, optional
		
		    The coordinate system that *xy* is given in. The following types
		    of values are supported:
		
		    - One of the following strings:
		
		      =================   =============================================
		      Value               Description
		      =================   =============================================
		      'figure points'     Points from the lower left of the figure
		      'figure pixels'     Pixels from the lower left of the figure
		      'figure fraction'   Fraction of figure from lower left
		      'axes points'       Points from lower left corner of axes
		      'axes pixels'       Pixels from lower left corner of axes
		      'axes fraction'     Fraction of axes from lower left
		      'data'              Use the coordinate system of the object being
		                          annotated (default)
		      'polar'             *(theta,r)* if not native 'data' coordinates
		      =================   =============================================
		
		    - An `.Artist`: *xy* is interpreted as a fraction of the artists
		      `~matplotlib.transforms.Bbox`. E.g. *(0, 0)* would be the lower
		      left corner of the bounding box and *(0.5, 1)* would be the
		      center top of the bounding box.
		
		    - A `.Transform` to transform *xy* to screen coordinates.
		
		    - A function with one of the following signatures::
		
		        def transform(renderer) -> Bbox
		        def transform(renderer) -> Transform
		
		      where *renderer* is a `.RendererBase` subclass.
		
		      The result of the function is interpreted like the `.Artist` and
		      `.Transform` cases above.
		
		    - A tuple *(xcoords, ycoords)* specifying separate coordinate
		      systems for *x* and *y*. *xcoords* and *ycoords* must each be
		      of one of the above described types.
		
		    See :ref:`plotting-guide-annotation` for more details.
		
		    Defaults to 'data'.
		
		textcoords : str, `.Artist`, `.Transform`, callable or tuple, optional
		    The coordinate system that *xytext* is given in.
		
		    All *xycoords* values are valid as well as the following
		    strings:
		
		    =================   =========================================
		    Value               Description
		    =================   =========================================
		    'offset points'     Offset (in points) from the *xy* value
		    'offset pixels'     Offset (in pixels) from the *xy* value
		    =================   =========================================
		
		    Defaults to the value of *xycoords*, i.e. use the same coordinate
		    system for annotation point and text position.
		
		arrowprops : dict, optional
		    The properties used to draw a
		    `~matplotlib.patches.FancyArrowPatch` arrow between the
		    positions *xy* and *xytext*.
		
		    If *arrowprops* does not contain the key 'arrowstyle' the
		    allowed keys are:
		
		    ==========   ======================================================
		    Key          Description
		    ==========   ======================================================
		    width        The width of the arrow in points
		    headwidth    The width of the base of the arrow head in points
		    headlength   The length of the arrow head in points
		    shrink       Fraction of total length to shrink from both ends
		    ?            Any key to :class:`matplotlib.patches.FancyArrowPatch`
		    ==========   ======================================================
		
		    If *arrowprops* contains the key 'arrowstyle' the
		    above keys are forbidden.  The allowed values of
		    ``'arrowstyle'`` are:
		
		    ============   =============================================
		    Name           Attrs
		    ============   =============================================
		    ``'-'``        None
		    ``'->'``       head_length=0.4,head_width=0.2
		    ``'-['``       widthB=1.0,lengthB=0.2,angleB=None
		    ``'|-|'``      widthA=1.0,widthB=1.0
		    ``'-|>'``      head_length=0.4,head_width=0.2
		    ``'<-'``       head_length=0.4,head_width=0.2
		    ``'<->'``      head_length=0.4,head_width=0.2
		    ``'<|-'``      head_length=0.4,head_width=0.2
		    ``'<|-|>'``    head_length=0.4,head_width=0.2
		    ``'fancy'``    head_length=0.4,head_width=0.4,tail_width=0.4
		    ``'simple'``   head_length=0.5,head_width=0.5,tail_width=0.2
		    ``'wedge'``    tail_width=0.3,shrink_factor=0.5
		    ============   =============================================
		
		    Valid keys for `~matplotlib.patches.FancyArrowPatch` are:
		
		    ===============  ==================================================
		    Key              Description
		    ===============  ==================================================
		    arrowstyle       the arrow style
		    connectionstyle  the connection style
		    relpos           default is (0.5, 0.5)
		    patchA           default is bounding box of the text
		    patchB           default is None
		    shrinkA          default is 2 points
		    shrinkB          default is 2 points
		    mutation_scale   default is text size (in points)
		    mutation_aspect  default is 1.
		    ?                any key for :class:`matplotlib.patches.PathPatch`
		    ===============  ==================================================
		
		    Defaults to None, i.e. no arrow is drawn.
		
		annotation_clip : bool or None, optional
		    Whether to draw the annotation when the annotation point *xy* is
		    outside the axes area.
		
		    - If *True*, the annotation will only be drawn when *xy* is
		      within the axes.
		    - If *False*, the annotation will always be drawn.
		    - If *None*, the annotation will only be drawn when *xy* is
		      within the axes and *xycoords* is 'data'.
		
		    Defaults to *None*.
		
		**kwargs
		    Additional kwargs are passed to `~matplotlib.text.Text`.
		
		Returns
		-------
		annotation : `.Annotation`
		
		See Also
		--------
		:ref:`plotting-guide-annotation`.
	**/
	static public function annotate(s:Dynamic, xy:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Test whether any array element along a given axis evaluates to True.
		
		Returns single boolean unless `axis` is not ``None``
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which a logical OR reduction is performed.
		    The default (`axis` = `None`) is to perform a logical OR over all
		    the dimensions of the input array. `axis` may be negative, in
		    which case it counts from the last to the first axis.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, a reduction is performed on multiple
		    axes, instead of a single axis or all the axes as before.
		out : ndarray, optional
		    Alternate output array in which to place the result.  It must have
		    the same shape as the expected output and its type is preserved
		    (e.g., if it is of type float, then it will remain so, returning
		    1.0 for True and 0.0 for False, regardless of the type of `a`).
		    See `doc.ufuncs` (Section "Output arguments") for details.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `any` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		any : bool or ndarray
		    A new boolean or `ndarray` is returned unless `out` is specified,
		    in which case a reference to `out` is returned.
		
		See Also
		--------
		ndarray.any : equivalent method
		
		all : Test whether all elements along a given axis evaluate to True.
		
		Notes
		-----
		Not a Number (NaN), positive infinity and negative infinity evaluate
		to `True` because these are not equal to zero.
		
		Examples
		--------
		>>> np.any([[True, False], [True, True]])
		True
		
		>>> np.any([[True, False], [False, False]], axis=0)
		array([ True, False])
		
		>>> np.any([-1, 0, 5])
		True
		
		>>> np.any(np.nan)
		True
		
		>>> o=np.array([False])
		>>> z=np.any([-1, 4, 5], out=o)
		>>> z, o
		(array([ True]), array([ True]))
		>>> # Check now that z is a reference to o
		>>> z is o
		True
		>>> id(z), id(o) # identity of z and o              # doctest: +SKIP
		(191614240, 191614240)
	**/
	static public function any(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Append values to the end of an array.
		
		Parameters
		----------
		arr : array_like
		    Values are appended to a copy of this array.
		values : array_like
		    These values are appended to a copy of `arr`.  It must be of the
		    correct shape (the same shape as `arr`, excluding `axis`).  If
		    `axis` is not specified, `values` can be any shape and will be
		    flattened before use.
		axis : int, optional
		    The axis along which `values` are appended.  If `axis` is not
		    given, both `arr` and `values` are flattened before use.
		
		Returns
		-------
		append : ndarray
		    A copy of `arr` with `values` appended to `axis`.  Note that
		    `append` does not occur in-place: a new array is allocated and
		    filled.  If `axis` is None, `out` is a flattened array.
		
		See Also
		--------
		insert : Insert elements into an array.
		delete : Delete elements from an array.
		
		Examples
		--------
		>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
		array([1, 2, 3, 4, 5, 6, 7, 8, 9])
		
		When `axis` is specified, `values` must have the correct shape.
		
		>>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
		array([[1, 2, 3],
		       [4, 5, 6],
		       [7, 8, 9]])
		>>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
		Traceback (most recent call last):
		...
		ValueError: arrays must have same number of dimensions
	**/
	static public function append(arr:Dynamic, values:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Apply a function to 1-D slices along the given axis.
		
		Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
		is a 1-D slice of `arr` along `axis`.
		
		This is equivalent to (but faster than) the following use of `ndindex` and
		`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::
		
		    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
		    for ii in ndindex(Ni):
		        for kk in ndindex(Nk):
		            f = func1d(arr[ii + s_[:,] + kk])
		            Nj = f.shape
		            for jj in ndindex(Nj):
		                out[ii + jj + kk] = f[jj]
		
		Equivalently, eliminating the inner loop, this can be expressed as::
		
		    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
		    for ii in ndindex(Ni):
		        for kk in ndindex(Nk):
		            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])
		
		Parameters
		----------
		func1d : function (M,) -> (Nj...)
		    This function should accept 1-D arrays. It is applied to 1-D
		    slices of `arr` along the specified axis.
		axis : integer
		    Axis along which `arr` is sliced.
		arr : ndarray (Ni..., M, Nk...)
		    Input array.
		args : any
		    Additional arguments to `func1d`.
		kwargs : any
		    Additional named arguments to `func1d`.
		
		    .. versionadded:: 1.9.0
		
		
		Returns
		-------
		out : ndarray  (Ni..., Nj..., Nk...)
		    The output array. The shape of `out` is identical to the shape of
		    `arr`, except along the `axis` dimension. This axis is removed, and
		    replaced with new dimensions equal to the shape of the return value
		    of `func1d`. So if `func1d` returns a scalar `out` will have one
		    fewer dimensions than `arr`.
		
		See Also
		--------
		apply_over_axes : Apply a function repeatedly over multiple axes.
		
		Examples
		--------
		>>> def my_func(a):
		...     """Average first and last element of a 1-D array"""
		...     return (a[0] + a[-1]) * 0.5
		>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
		>>> np.apply_along_axis(my_func, 0, b)
		array([ 4.,  5.,  6.])
		>>> np.apply_along_axis(my_func, 1, b)
		array([ 2.,  5.,  8.])
		
		For a function that returns a 1D array, the number of dimensions in
		`outarr` is the same as `arr`.
		
		>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
		>>> np.apply_along_axis(sorted, 1, b)
		array([[1, 7, 8],
		       [3, 4, 9],
		       [2, 5, 6]])
		
		For a function that returns a higher dimensional array, those dimensions
		are inserted in place of the `axis` dimension.
		
		>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
		>>> np.apply_along_axis(np.diag, -1, b)
		array([[[1, 0, 0],
		        [0, 2, 0],
		        [0, 0, 3]],
		       [[4, 0, 0],
		        [0, 5, 0],
		        [0, 0, 6]],
		       [[7, 0, 0],
		        [0, 8, 0],
		        [0, 0, 9]]])
	**/
	static public function apply_along_axis(func1d:Dynamic, axis:Dynamic, arr:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Apply a function repeatedly over multiple axes.
		
		`func` is called as `res = func(a, axis)`, where `axis` is the first
		element of `axes`.  The result `res` of the function call must have
		either the same dimensions as `a` or one less dimension.  If `res`
		has one less dimension than `a`, a dimension is inserted before
		`axis`.  The call to `func` is then repeated for each axis in `axes`,
		with `res` as the first argument.
		
		Parameters
		----------
		func : function
		    This function must take two arguments, `func(a, axis)`.
		a : array_like
		    Input array.
		axes : array_like
		    Axes over which `func` is applied; the elements must be integers.
		
		Returns
		-------
		apply_over_axis : ndarray
		    The output array.  The number of dimensions is the same as `a`,
		    but the shape can be different.  This depends on whether `func`
		    changes the shape of its output with respect to its input.
		
		See Also
		--------
		apply_along_axis :
		    Apply a function to 1-D slices of an array along the given axis.
		
		Notes
		------
		This function is equivalent to tuple axis arguments to reorderable ufuncs
		with keepdims=True. Tuple axis arguments to ufuncs have been available since
		version 1.7.0.
		
		Examples
		--------
		>>> a = np.arange(24).reshape(2,3,4)
		>>> a
		array([[[ 0,  1,  2,  3],
		        [ 4,  5,  6,  7],
		        [ 8,  9, 10, 11]],
		       [[12, 13, 14, 15],
		        [16, 17, 18, 19],
		        [20, 21, 22, 23]]])
		
		Sum over axes 0 and 2. The result has same number of dimensions
		as the original array:
		
		>>> np.apply_over_axes(np.sum, a, [0,2])
		array([[[ 60],
		        [ 92],
		        [124]]])
		
		Tuple axis arguments to ufuncs are equivalent:
		
		>>> np.sum(a, axis=(0,2), keepdims=True)
		array([[[ 60],
		        [ 92],
		        [124]]])
	**/
	static public function apply_over_axes(func:Dynamic, a:Dynamic, axes:Dynamic):Dynamic;
	/**
		arange([start,] stop[, step,], dtype=None)
		
		Return evenly spaced values within a given interval.
		
		Values are generated within the half-open interval ``[start, stop)``
		(in other words, the interval including `start` but excluding `stop`).
		For integer arguments the function is equivalent to the Python built-in
		`range` function, but returns an ndarray rather than a list.
		
		When using a non-integer step, such as 0.1, the results will often not
		be consistent.  It is better to use `numpy.linspace` for these cases.
		
		Parameters
		----------
		start : number, optional
		    Start of interval.  The interval includes this value.  The default
		    start value is 0.
		stop : number
		    End of interval.  The interval does not include this value, except
		    in some cases where `step` is not an integer and floating point
		    round-off affects the length of `out`.
		step : number, optional
		    Spacing between values.  For any output `out`, this is the distance
		    between two adjacent values, ``out[i+1] - out[i]``.  The default
		    step size is 1.  If `step` is specified as a position argument,
		    `start` must also be given.
		dtype : dtype
		    The type of the output array.  If `dtype` is not given, infer the data
		    type from the other input arguments.
		
		Returns
		-------
		arange : ndarray
		    Array of evenly spaced values.
		
		    For floating point arguments, the length of the result is
		    ``ceil((stop - start)/step)``.  Because of floating point overflow,
		    this rule may result in the last element of `out` being greater
		    than `stop`.
		
		See Also
		--------
		linspace : Evenly spaced numbers with careful handling of endpoints.
		ogrid: Arrays of evenly spaced numbers in N-dimensions.
		mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.
		
		Examples
		--------
		>>> np.arange(3)
		array([0, 1, 2])
		>>> np.arange(3.0)
		array([ 0.,  1.,  2.])
		>>> np.arange(3,7)
		array([3, 4, 5, 6])
		>>> np.arange(3,7,2)
		array([3, 5])
	**/
	static public function arange(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Trigonometric inverse cosine, element-wise.
		
		The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.
		
		Parameters
		----------
		x : array_like
		    `x`-coordinate on the unit circle.
		    For real arguments, the domain is [-1, 1].
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		angle : ndarray
		    The angle of the ray intersecting the unit circle at the given
		    `x`-coordinate in radians [0, pi].
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		cos, arctan, arcsin, emath.arccos
		
		Notes
		-----
		`arccos` is a multivalued function: for each `x` there are infinitely
		many numbers `z` such that `cos(z) = x`. The convention is to return
		the angle `z` whose real part lies in `[0, pi]`.
		
		For real-valued input data types, `arccos` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arccos` is a complex analytic function that
		has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from
		above on the former and from below on the latter.
		
		The inverse `cos` is also known as `acos` or cos^-1.
		
		References
		----------
		M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/
		
		Examples
		--------
		We expect the arccos of 1 to be 0, and of -1 to be pi:
		
		>>> np.arccos([1, -1])
		array([ 0.        ,  3.14159265])
		
		Plot arccos:
		
		>>> import matplotlib.pyplot as plt
		>>> x = np.linspace(-1, 1, num=100)
		>>> plt.plot(x, np.arccos(x))
		>>> plt.axis('tight')
		>>> plt.show()
	**/
	static public function arccos(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Inverse hyperbolic cosine, element-wise.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		arccosh : ndarray
		    Array of the same shape as `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		
		cosh, arcsinh, sinh, arctanh, tanh
		
		Notes
		-----
		`arccosh` is a multivalued function: for each `x` there are infinitely
		many numbers `z` such that `cosh(z) = x`. The convention is to return the
		`z` whose imaginary part lies in `[-pi, pi]` and the real part in
		``[0, inf]``.
		
		For real-valued input data types, `arccosh` always returns real output.
		For each value that cannot be expressed as a real number or infinity, it
		yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arccosh` is a complex analytical function that
		has a branch cut `[-inf, 1]` and is continuous from above on it.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Inverse hyperbolic function",
		       https://en.wikipedia.org/wiki/Arccosh
		
		Examples
		--------
		>>> np.arccosh([np.e, 10.0])
		array([ 1.65745445,  2.99322285])
		>>> np.arccosh(1)
		0.0
	**/
	static public function arccosh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Inverse sine, element-wise.
		
		Parameters
		----------
		x : array_like
		    `y`-coordinate on the unit circle.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		angle : ndarray
		    The inverse sine of each element in `x`, in radians and in the
		    closed interval ``[-pi/2, pi/2]``.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		sin, cos, arccos, tan, arctan, arctan2, emath.arcsin
		
		Notes
		-----
		`arcsin` is a multivalued function: for each `x` there are infinitely
		many numbers `z` such that :math:`sin(z) = x`.  The convention is to
		return the angle `z` whose real part lies in [-pi/2, pi/2].
		
		For real-valued input data types, *arcsin* always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arcsin` is a complex analytic function that
		has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
		continuous from above on the former and from below on the latter.
		
		The inverse sine is also known as `asin` or sin^{-1}.
		
		References
		----------
		Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
		10th printing, New York: Dover, 1964, pp. 79ff.
		http://www.math.sfu.ca/~cbm/aands/
		
		Examples
		--------
		>>> np.arcsin(1)     # pi/2
		1.5707963267948966
		>>> np.arcsin(-1)    # -pi/2
		-1.5707963267948966
		>>> np.arcsin(0)
		0.0
	**/
	static public function arcsin(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Inverse hyperbolic sine element-wise.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Array of the same shape as `x`.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		`arcsinh` is a multivalued function: for each `x` there are infinitely
		many numbers `z` such that `sinh(z) = x`. The convention is to return the
		`z` whose imaginary part lies in `[-pi/2, pi/2]`.
		
		For real-valued input data types, `arcsinh` always returns real output.
		For each value that cannot be expressed as a real number or infinity, it
		returns ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arccos` is a complex analytical function that
		has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
		the right on the former and from the left on the latter.
		
		The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Inverse hyperbolic function",
		       https://en.wikipedia.org/wiki/Arcsinh
		
		Examples
		--------
		>>> np.arcsinh(np.array([np.e, 10.0]))
		array([ 1.72538256,  2.99822295])
	**/
	static public function arcsinh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Trigonometric inverse tangent, element-wise.
		
		The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.
		
		Parameters
		----------
		x : array_like
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Out has the same shape as `x`.  Its real part is in
		    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		arctan2 : The "four quadrant" arctan of the angle formed by (`x`, `y`)
		    and the positive `x`-axis.
		angle : Argument of complex values.
		
		Notes
		-----
		`arctan` is a multi-valued function: for each `x` there are infinitely
		many numbers `z` such that tan(`z`) = `x`.  The convention is to return
		the angle `z` whose real part lies in [-pi/2, pi/2].
		
		For real-valued input data types, `arctan` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arctan` is a complex analytic function that
		has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous
		from the left on the former and from the right on the latter.
		
		The inverse tangent is also known as `atan` or tan^{-1}.
		
		References
		----------
		Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
		10th printing, New York: Dover, 1964, pp. 79.
		http://www.math.sfu.ca/~cbm/aands/
		
		Examples
		--------
		We expect the arctan of 0 to be 0, and of 1 to be pi/4:
		
		>>> np.arctan([0, 1])
		array([ 0.        ,  0.78539816])
		
		>>> np.pi/4
		0.78539816339744828
		
		Plot arctan:
		
		>>> import matplotlib.pyplot as plt
		>>> x = np.linspace(-10, 10)
		>>> plt.plot(x, np.arctan(x))
		>>> plt.axis('tight')
		>>> plt.show()
	**/
	static public function arctan(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.
		
		The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is
		the signed angle in radians between the ray ending at the origin and
		passing through the point (1,0), and the ray ending at the origin and
		passing through the point (`x2`, `x1`).  (Note the role reversal: the
		"`y`-coordinate" is the first function parameter, the "`x`-coordinate"
		is the second.)  By IEEE convention, this function is defined for
		`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see
		Notes for specific values).
		
		This function is not defined for complex-valued arguments; for the
		so-called argument of complex values, use `angle`.
		
		Parameters
		----------
		x1 : array_like, real-valued
		    `y`-coordinates.
		x2 : array_like, real-valued
		    `x`-coordinates. `x2` must be broadcastable to match the shape of
		    `x1` or vice versa.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		angle : ndarray
		    Array of angles in radians, in the range ``[-pi, pi]``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		arctan, tan, angle
		
		Notes
		-----
		*arctan2* is identical to the `atan2` function of the underlying
		C library.  The following special values are defined in the C
		standard: [1]_
		
		====== ====== ================
		`x1`   `x2`   `arctan2(x1,x2)`
		====== ====== ================
		+/- 0  +0     +/- 0
		+/- 0  -0     +/- pi
		 > 0   +/-inf +0 / +pi
		 < 0   +/-inf -0 / -pi
		+/-inf +inf   +/- (pi/4)
		+/-inf -inf   +/- (3*pi/4)
		====== ====== ================
		
		Note that +0 and -0 are distinct floating point numbers, as are +inf
		and -inf.
		
		References
		----------
		.. [1] ISO/IEC standard 9899:1999, "Programming language C."
		
		Examples
		--------
		Consider four points in different quadrants:
		
		>>> x = np.array([-1, +1, +1, -1])
		>>> y = np.array([-1, -1, +1, +1])
		>>> np.arctan2(y, x) * 180 / np.pi
		array([-135.,  -45.,   45.,  135.])
		
		Note the order of the parameters. `arctan2` is defined also when `x2` = 0
		and at several other special points, obtaining values in
		the range ``[-pi, pi]``:
		
		>>> np.arctan2([1., -1.], [0., 0.])
		array([ 1.57079633, -1.57079633])
		>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
		array([ 0.        ,  3.14159265,  0.78539816])
	**/
	static public function arctan2(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Inverse hyperbolic tangent element-wise.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Array of the same shape as `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		emath.arctanh
		
		Notes
		-----
		`arctanh` is a multivalued function: for each `x` there are infinitely
		many numbers `z` such that `tanh(z) = x`. The convention is to return
		the `z` whose imaginary part lies in `[-pi/2, pi/2]`.
		
		For real-valued input data types, `arctanh` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `arctanh` is a complex analytical function
		that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
		above on the former and from below on the latter.
		
		The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Inverse hyperbolic function",
		       https://en.wikipedia.org/wiki/Arctanh
		
		Examples
		--------
		>>> np.arctanh([0, -0.5])
		array([ 0.        , -0.54930614])
	**/
	static public function arctanh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Returns the indices of the maximum values along an axis.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    By default, the index is into the flattened array, otherwise
		    along the specified axis.
		out : array, optional
		    If provided, the result will be inserted into this array. It should
		    be of the appropriate shape and dtype.
		
		Returns
		-------
		index_array : ndarray of ints
		    Array of indices into the array. It has the same shape as `a.shape`
		    with the dimension along `axis` removed.
		
		See Also
		--------
		ndarray.argmax, argmin
		amax : The maximum value along a given axis.
		unravel_index : Convert a flat index into an index tuple.
		
		Notes
		-----
		In case of multiple occurrences of the maximum values, the indices
		corresponding to the first occurrence are returned.
		
		Examples
		--------
		>>> a = np.arange(6).reshape(2,3) + 10
		>>> a
		array([[10, 11, 12],
		       [13, 14, 15]])
		>>> np.argmax(a)
		5
		>>> np.argmax(a, axis=0)
		array([1, 1, 1])
		>>> np.argmax(a, axis=1)
		array([2, 2])
		
		Indexes of the maximal elements of a N-dimensional array:
		
		>>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
		>>> ind
		(1, 2)
		>>> a[ind]
		15
		
		>>> b = np.arange(6)
		>>> b[1] = 5
		>>> b
		array([0, 5, 2, 3, 4, 5])
		>>> np.argmax(b)  # Only the first occurrence is returned.
		1
	**/
	static public function argmax(a:Dynamic, ?axis:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Returns the indices of the minimum values along an axis.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    By default, the index is into the flattened array, otherwise
		    along the specified axis.
		out : array, optional
		    If provided, the result will be inserted into this array. It should
		    be of the appropriate shape and dtype.
		
		Returns
		-------
		index_array : ndarray of ints
		    Array of indices into the array. It has the same shape as `a.shape`
		    with the dimension along `axis` removed.
		
		See Also
		--------
		ndarray.argmin, argmax
		amin : The minimum value along a given axis.
		unravel_index : Convert a flat index into an index tuple.
		
		Notes
		-----
		In case of multiple occurrences of the minimum values, the indices
		corresponding to the first occurrence are returned.
		
		Examples
		--------
		>>> a = np.arange(6).reshape(2,3) + 10
		>>> a
		array([[10, 11, 12],
		       [13, 14, 15]])
		>>> np.argmin(a)
		0
		>>> np.argmin(a, axis=0)
		array([0, 0, 0])
		>>> np.argmin(a, axis=1)
		array([0, 0])
		
		Indices of the minimum elements of a N-dimensional array:
		
		>>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
		>>> ind
		(0, 0)
		>>> a[ind]
		10
		
		>>> b = np.arange(6) + 10
		>>> b[4] = 10
		>>> b
		array([10, 11, 12, 13, 10, 15])
		>>> np.argmin(b)  # Only the first occurrence is returned.
		0
	**/
	static public function argmin(a:Dynamic, ?axis:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Perform an indirect partition along the given axis using the
		algorithm specified by the `kind` keyword. It returns an array of
		indices of the same shape as `a` that index data along the given
		axis in partitioned order.
		
		.. versionadded:: 1.8.0
		
		Parameters
		----------
		a : array_like
		    Array to sort.
		kth : int or sequence of ints
		    Element index to partition by. The k-th element will be in its
		    final sorted position and all smaller elements will be moved
		    before it and all larger elements behind it. The order all
		    elements in the partitions is undefined. If provided with a
		    sequence of k-th it will partition all of them into their sorted
		    position at once.
		axis : int or None, optional
		    Axis along which to sort. The default is -1 (the last axis). If
		    None, the flattened array is used.
		kind : {'introselect'}, optional
		    Selection algorithm. Default is 'introselect'
		order : str or list of str, optional
		    When `a` is an array with fields defined, this argument
		    specifies which fields to compare first, second, etc. A single
		    field can be specified as a string, and not all fields need be
		    specified, but unspecified fields will still be used, in the
		    order in which they come up in the dtype, to break ties.
		
		Returns
		-------
		index_array : ndarray, int
		    Array of indices that partition `a` along the specified axis.
		    If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.
		    More generally, ``np.take_along_axis(a, index_array, axis=a)`` always
		    yields the partitioned `a`, irrespective of dimensionality.
		
		See Also
		--------
		partition : Describes partition algorithms used.
		ndarray.partition : Inplace partition.
		argsort : Full indirect sort
		
		Notes
		-----
		See `partition` for notes on the different selection algorithms.
		
		Examples
		--------
		One dimensional array:
		
		>>> x = np.array([3, 4, 2, 1])
		>>> x[np.argpartition(x, 3)]
		array([2, 1, 3, 4])
		>>> x[np.argpartition(x, (1, 3))]
		array([1, 2, 3, 4])
		
		>>> x = [3, 4, 2, 1]
		>>> np.array(x)[np.argpartition(x, 3)]
		array([2, 1, 3, 4])
	**/
	static public function argpartition(a:Dynamic, kth:Dynamic, ?axis:Dynamic, ?kind:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Returns the indices that would sort an array.
		
		Perform an indirect sort along the given axis using the algorithm specified
		by the `kind` keyword. It returns an array of indices of the same shape as
		`a` that index data along the given axis in sorted order.
		
		Parameters
		----------
		a : array_like
		    Array to sort.
		axis : int or None, optional
		    Axis along which to sort.  The default is -1 (the last axis). If None,
		    the flattened array is used.
		kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
		    Sorting algorithm.
		order : str or list of str, optional
		    When `a` is an array with fields defined, this argument specifies
		    which fields to compare first, second, etc.  A single field can
		    be specified as a string, and not all fields need be specified,
		    but unspecified fields will still be used, in the order in which
		    they come up in the dtype, to break ties.
		
		Returns
		-------
		index_array : ndarray, int
		    Array of indices that sort `a` along the specified axis.
		    If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.
		    More generally, ``np.take_along_axis(a, index_array, axis=a)`` always
		    yields the sorted `a`, irrespective of dimensionality.
		
		See Also
		--------
		sort : Describes sorting algorithms used.
		lexsort : Indirect stable sort with multiple keys.
		ndarray.sort : Inplace sort.
		argpartition : Indirect partial sort.
		
		Notes
		-----
		See `sort` for notes on the different sorting algorithms.
		
		As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
		nan values. The enhanced sort order is documented in `sort`.
		
		Examples
		--------
		One dimensional array:
		
		>>> x = np.array([3, 1, 2])
		>>> np.argsort(x)
		array([1, 2, 0])
		
		Two-dimensional array:
		
		>>> x = np.array([[0, 3], [2, 2]])
		>>> x
		array([[0, 3],
		       [2, 2]])
		
		>>> np.argsort(x, axis=0)  # sorts along first axis (down)
		array([[0, 1],
		       [1, 0]])
		
		>>> np.argsort(x, axis=1)  # sorts along last axis (across)
		array([[0, 1],
		       [0, 1]])
		
		Indices of the sorted elements of a N-dimensional array:
		
		>>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
		>>> ind
		(array([0, 1, 1, 0]), array([0, 0, 1, 1]))
		>>> x[ind]  # same as np.sort(x, axis=None)
		array([0, 2, 2, 3])
		
		Sorting with keys:
		
		>>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
		>>> x
		array([(1, 0), (0, 1)],
		      dtype=[('x', '<i4'), ('y', '<i4')])
		
		>>> np.argsort(x, order=('x','y'))
		array([1, 0])
		
		>>> np.argsort(x, order=('y','x'))
		array([0, 1])
	**/
	static public function argsort(a:Dynamic, ?axis:Dynamic, ?kind:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Find the indices of array elements that are non-zero, grouped by element.
		
		Parameters
		----------
		a : array_like
		    Input data.
		
		Returns
		-------
		index_array : ndarray
		    Indices of elements that are non-zero. Indices are grouped by element.
		
		See Also
		--------
		where, nonzero
		
		Notes
		-----
		``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.
		
		The output of ``argwhere`` is not suitable for indexing arrays.
		For this purpose use ``nonzero(a)`` instead.
		
		Examples
		--------
		>>> x = np.arange(6).reshape(2,3)
		>>> x
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.argwhere(x>1)
		array([[0, 2],
		       [1, 0],
		       [1, 1],
		       [1, 2]])
	**/
	static public function argwhere(a:Dynamic):Dynamic;
	/**
		Evenly round to the given number of decimals.
		
		Parameters
		----------
		a : array_like
		    Input data.
		decimals : int, optional
		    Number of decimal places to round to (default: 0).  If
		    decimals is negative, it specifies the number of positions to
		    the left of the decimal point.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must have
		    the same shape as the expected output, but the type of the output
		    values will be cast if necessary. See `doc.ufuncs` (Section
		    "Output arguments") for details.
		
		Returns
		-------
		rounded_array : ndarray
		    An array of the same type as `a`, containing the rounded values.
		    Unless `out` was specified, a new array is created.  A reference to
		    the result is returned.
		
		    The real and imaginary parts of complex numbers are rounded
		    separately.  The result of rounding a float is a float.
		
		See Also
		--------
		ndarray.round : equivalent method
		
		ceil, fix, floor, rint, trunc
		
		
		Notes
		-----
		For values exactly halfway between rounded decimal values, NumPy
		rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
		-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
		to the inexact representation of decimal fractions in the IEEE
		floating point standard [1]_ and errors introduced when scaling
		by powers of ten.
		
		References
		----------
		.. [1] "Lecture Notes on the Status of IEEE 754", William Kahan,
		       https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
		.. [2] "How Futile are Mindless Assessments of
		       Roundoff in Floating-Point Computation?", William Kahan,
		       https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf
		
		Examples
		--------
		>>> np.around([0.37, 1.64])
		array([ 0.,  2.])
		>>> np.around([0.37, 1.64], decimals=1)
		array([ 0.4,  1.6])
		>>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
		array([ 0.,  2.,  2.,  4.,  4.])
		>>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
		array([ 1,  2,  3, 11])
		>>> np.around([1,2,3,11], decimals=-1)
		array([ 0,  0,  0, 10])
	**/
	static public function around(a:Dynamic, ?decimals:Dynamic, ?out:Dynamic):Dynamic;
	/**
		array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)
		
		Create an array.
		
		Parameters
		----------
		object : array_like
		    An array, any object exposing the array interface, an object whose
		    __array__ method returns an array, or any (nested) sequence.
		dtype : data-type, optional
		    The desired data-type for the array.  If not given, then the type will
		    be determined as the minimum type required to hold the objects in the
		    sequence.  This argument can only be used to 'upcast' the array.  For
		    downcasting, use the .astype(t) method.
		copy : bool, optional
		    If true (default), then the object is copied.  Otherwise, a copy will
		    only be made if __array__ returns a copy, if obj is a nested sequence,
		    or if a copy is needed to satisfy any of the other requirements
		    (`dtype`, `order`, etc.).
		order : {'K', 'A', 'C', 'F'}, optional
		    Specify the memory layout of the array. If object is not an array, the
		    newly created array will be in C order (row major) unless 'F' is
		    specified, in which case it will be in Fortran order (column major).
		    If object is an array the following holds.
		
		    ===== ========= ===================================================
		    order  no copy                     copy=True
		    ===== ========= ===================================================
		    'K'   unchanged F & C order preserved, otherwise most similar order
		    'A'   unchanged F order if input is F and not C, otherwise C order
		    'C'   C order   C order
		    'F'   F order   F order
		    ===== ========= ===================================================
		
		    When ``copy=False`` and a copy is made for other reasons, the result is
		    the same as if ``copy=True``, with some exceptions for `A`, see the
		    Notes section. The default order is 'K'.
		subok : bool, optional
		    If True, then sub-classes will be passed-through, otherwise
		    the returned array will be forced to be a base-class array (default).
		ndmin : int, optional
		    Specifies the minimum number of dimensions that the resulting
		    array should have.  Ones will be pre-pended to the shape as
		    needed to meet this requirement.
		
		Returns
		-------
		out : ndarray
		    An array object satisfying the specified requirements.
		
		See Also
		--------
		empty_like : Return an empty array with shape and type of input.
		ones_like : Return an array of ones with shape and type of input.
		zeros_like : Return an array of zeros with shape and type of input.
		full_like : Return a new array with shape of input filled with value.
		empty : Return a new uninitialized array.
		ones : Return a new array setting values to one.
		zeros : Return a new array setting values to zero.
		full : Return a new array of given shape filled with value.
		
		
		Notes
		-----
		When order is 'A' and `object` is an array in neither 'C' nor 'F' order,
		and a copy is forced by a change in dtype, then the order of the result is
		not necessarily 'C' as expected. This is likely a bug.
		
		Examples
		--------
		>>> np.array([1, 2, 3])
		array([1, 2, 3])
		
		Upcasting:
		
		>>> np.array([1, 2, 3.0])
		array([ 1.,  2.,  3.])
		
		More than one dimension:
		
		>>> np.array([[1, 2], [3, 4]])
		array([[1, 2],
		       [3, 4]])
		
		Minimum dimensions 2:
		
		>>> np.array([1, 2, 3], ndmin=2)
		array([[1, 2, 3]])
		
		Type provided:
		
		>>> np.array([1, 2, 3], dtype=complex)
		array([ 1.+0.j,  2.+0.j,  3.+0.j])
		
		Data-type consisting of more than one element:
		
		>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
		>>> x['a']
		array([1, 3])
		
		Creating an array from sub-classes:
		
		>>> np.array(np.mat('1 2; 3 4'))
		array([[1, 2],
		       [3, 4]])
		
		>>> np.array(np.mat('1 2; 3 4'), subok=True)
		matrix([[1, 2],
		        [3, 4]])
	**/
	static public function array(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return a string representation of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.
		max_line_width : int, optional
		    The maximum number of columns the string should span. Newline
		    characters splits the string appropriately after array elements.
		precision : int or None, optional
		    Floating point precision. Default is the current printing
		    precision (usually 8), which can be altered using `set_printoptions`.
		suppress_small : bool, optional
		    Represent very small numbers as zero. A number is "very small" if it
		    is smaller than the current printing precision.
		separator : str, optional
		    Inserted between elements.
		prefix : str, optional
		suffix: str, optional
		    The length of the prefix and suffix strings are used to respectively
		    align and wrap the output. An array is typically printed as::
		
		      prefix + array2string(a) + suffix
		
		    The output is left-padded by the length of the prefix string, and
		    wrapping is forced at the column ``max_line_width - len(suffix)``.
		    It should be noted that the content of prefix and suffix strings are
		    not included in the output.
		style : _NoValue, optional
		    Has no effect, do not use.
		
		    .. deprecated:: 1.14.0
		formatter : dict of callables, optional
		    If not None, the keys should indicate the type(s) that the respective
		    formatting function applies to.  Callables should return a string.
		    Types that are not specified (by their corresponding keys) are handled
		    by the default formatters.  Individual types for which a formatter
		    can be set are:
		
		    - 'bool'
		    - 'int'
		    - 'timedelta' : a `numpy.timedelta64`
		    - 'datetime' : a `numpy.datetime64`
		    - 'float'
		    - 'longfloat' : 128-bit floats
		    - 'complexfloat'
		    - 'longcomplexfloat' : composed of two 128-bit floats
		    - 'void' : type `numpy.void`
		    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
		    - 'str' : all other strings
		
		    Other keys that can be used to set a group of types at once are:
		
		    - 'all' : sets all types
		    - 'int_kind' : sets 'int'
		    - 'float_kind' : sets 'float' and 'longfloat'
		    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
		    - 'str_kind' : sets 'str' and 'numpystr'
		threshold : int, optional
		    Total number of array elements which trigger summarization
		    rather than full repr.
		edgeitems : int, optional
		    Number of array items in summary at beginning and end of
		    each dimension.
		sign : string, either '-', '+', or ' ', optional
		    Controls printing of the sign of floating-point types. If '+', always
		    print the sign of positive values. If ' ', always prints a space
		    (whitespace character) in the sign position of positive values.  If
		    '-', omit the sign character of positive values.
		floatmode : str, optional
		    Controls the interpretation of the `precision` option for
		    floating-point types. Can take the following values:
		
		    - 'fixed': Always print exactly `precision` fractional digits,
		      even if this would print more or fewer digits than
		      necessary to specify the value uniquely.
		    - 'unique': Print the minimum number of fractional digits necessary
		      to represent each value uniquely. Different elements may
		      have a different number of digits.  The value of the
		      `precision` option is ignored.
		    - 'maxprec': Print at most `precision` fractional digits, but if
		      an element can be uniquely represented with fewer digits
		      only print it with that many.
		    - 'maxprec_equal': Print at most `precision` fractional digits,
		      but if every element in the array can be uniquely
		      represented with an equal number of fewer digits, use that
		      many digits for all elements.
		legacy : string or `False`, optional
		    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
		    approximates numpy 1.13 print output by including a space in the sign
		    position of floats and different behavior for 0d arrays. If set to
		    `False`, disables legacy mode. Unrecognized strings will be ignored
		    with a warning for forward compatibility.
		
		    .. versionadded:: 1.14.0
		
		Returns
		-------
		array_str : str
		    String representation of the array.
		
		Raises
		------
		TypeError
		    if a callable in `formatter` does not return a string.
		
		See Also
		--------
		array_str, array_repr, set_printoptions, get_printoptions
		
		Notes
		-----
		If a formatter is specified for a certain type, the `precision` keyword is
		ignored for that type.
		
		This is a very flexible function; `array_repr` and `array_str` are using
		`array2string` internally so keywords with the same name should work
		identically in all three functions.
		
		Examples
		--------
		>>> x = np.array([1e-16,1,2,3])
		>>> print(np.array2string(x, precision=2, separator=',',
		...                       suppress_small=True))
		[ 0., 1., 2., 3.]
		
		>>> x  = np.arange(3.)
		>>> np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x})
		'[0.00 1.00 2.00]'
		
		>>> x  = np.arange(3)
		>>> np.array2string(x, formatter={'int':lambda x: hex(x)})
		'[0x0L 0x1L 0x2L]'
	**/
	static public function array2string(a:Dynamic, ?max_line_width:Dynamic, ?precision:Dynamic, ?suppress_small:Dynamic, ?separator:Dynamic, ?prefix:Dynamic, ?style:Dynamic, ?formatter:Dynamic, ?threshold:Dynamic, ?edgeitems:Dynamic, ?sign:Dynamic, ?floatmode:Dynamic, ?suffix:Dynamic, ?kwarg:python.KwArgs<Dynamic>):String;
	/**
		True if two arrays have the same shape and elements, False otherwise.
		
		Parameters
		----------
		a1, a2 : array_like
		    Input arrays.
		
		Returns
		-------
		b : bool
		    Returns True if the arrays are equal.
		
		See Also
		--------
		allclose: Returns True if two arrays are element-wise equal within a
		          tolerance.
		array_equiv: Returns True if input arrays are shape consistent and all
		             elements equal.
		
		Examples
		--------
		>>> np.array_equal([1, 2], [1, 2])
		True
		>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
		True
		>>> np.array_equal([1, 2], [1, 2, 3])
		False
		>>> np.array_equal([1, 2], [1, 4])
		False
	**/
	static public function array_equal(a1:Dynamic, a2:Dynamic):Bool;
	/**
		Returns True if input arrays are shape consistent and all elements equal.
		
		Shape consistent means they are either the same shape, or one input array
		can be broadcasted to create the same shape as the other one.
		
		Parameters
		----------
		a1, a2 : array_like
		    Input arrays.
		
		Returns
		-------
		out : bool
		    True if equivalent, False otherwise.
		
		Examples
		--------
		>>> np.array_equiv([1, 2], [1, 2])
		True
		>>> np.array_equiv([1, 2], [1, 3])
		False
		
		Showing the shape equivalence:
		
		>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
		True
		>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
		False
		
		>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
		False
	**/
	static public function array_equiv(a1:Dynamic, a2:Dynamic):Bool;
	/**
		Return the string representation of an array.
		
		Parameters
		----------
		arr : ndarray
		    Input array.
		max_line_width : int, optional
		    The maximum number of columns the string should span. Newline
		    characters split the string appropriately after array elements.
		precision : int, optional
		    Floating point precision. Default is the current printing precision
		    (usually 8), which can be altered using `set_printoptions`.
		suppress_small : bool, optional
		    Represent very small numbers as zero, default is False. Very small
		    is defined by `precision`, if the precision is 8 then
		    numbers smaller than 5e-9 are represented as zero.
		
		Returns
		-------
		string : str
		  The string representation of an array.
		
		See Also
		--------
		array_str, array2string, set_printoptions
		
		Examples
		--------
		>>> np.array_repr(np.array([1,2]))
		'array([1, 2])'
		>>> np.array_repr(np.ma.array([0.]))
		'MaskedArray([ 0.])'
		>>> np.array_repr(np.array([], np.int32))
		'array([], dtype=int32)'
		
		>>> x = np.array([1e-6, 4e-7, 2, 3])
		>>> np.array_repr(x, precision=6, suppress_small=True)
		'array([ 0.000001,  0.      ,  2.      ,  3.      ])'
	**/
	static public function array_repr(arr:Dynamic, ?max_line_width:Dynamic, ?precision:Dynamic, ?suppress_small:Dynamic):String;
	/**
		Split an array into multiple sub-arrays.
		
		Please refer to the ``split`` documentation.  The only difference
		between these functions is that ``array_split`` allows
		`indices_or_sections` to be an integer that does *not* equally
		divide the axis. For an array of length l that should be split
		into n sections, it returns l % n sub-arrays of size l//n + 1
		and the rest of size l//n.
		
		See Also
		--------
		split : Split array into multiple sub-arrays of equal size.
		
		Examples
		--------
		>>> x = np.arange(8.0)
		>>> np.array_split(x, 3)
		    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]
		
		>>> x = np.arange(7.0)
		>>> np.array_split(x, 3)
		    [array([ 0.,  1.,  2.]), array([ 3.,  4.]), array([ 5.,  6.])]
	**/
	static public function array_split(ary:Dynamic, indices_or_sections:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return a string representation of the data in an array.
		
		The data in the array is returned as a single string.  This function is
		similar to `array_repr`, the difference being that `array_repr` also
		returns information on the kind of array and its data type.
		
		Parameters
		----------
		a : ndarray
		    Input array.
		max_line_width : int, optional
		    Inserts newlines if text is longer than `max_line_width`.  The
		    default is, indirectly, 75.
		precision : int, optional
		    Floating point precision.  Default is the current printing precision
		    (usually 8), which can be altered using `set_printoptions`.
		suppress_small : bool, optional
		    Represent numbers "very close" to zero as zero; default is False.
		    Very close is defined by precision: if the precision is 8, e.g.,
		    numbers smaller (in absolute value) than 5e-9 are represented as
		    zero.
		
		See Also
		--------
		array2string, array_repr, set_printoptions
		
		Examples
		--------
		>>> np.array_str(np.arange(3))
		'[0 1 2]'
	**/
	static public function array_str(a:Dynamic, ?max_line_width:Dynamic, ?precision:Dynamic, ?suppress_small:Dynamic):Dynamic;
	/**
		Add an arrow to the axes.
		
		This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
		
		Parameters
		----------
		x, y : float
		    The x and y coordinates of the arrow base.
		dx, dy : float
		    The length of the arrow along x and y direction.
		
		Returns
		-------
		arrow : `.FancyArrow`
		    The created `.FancyArrow` object.
		
		Other Parameters
		----------------
		**kwargs
		    Optional kwargs (inherited from `.FancyArrow` patch) control the
		    arrow construction and properties:
		
		Constructor arguments
		  *width*: float (default: 0.001)
		    width of full arrow tail
		
		  *length_includes_head*: bool (default: False)
		    True if head is to be counted in calculating the length.
		
		  *head_width*: float or None (default: 3*width)
		    total width of the full arrow head
		
		  *head_length*: float or None (default: 1.5 * head_width)
		    length of arrow head
		
		  *shape*: ['full', 'left', 'right'] (default: 'full')
		    draw the left-half, right-half, or full arrow
		
		  *overhang*: float (default: 0)
		    fraction that the arrow is swept back (0 overhang means
		    triangular shape). Can be negative or greater than one.
		
		  *head_starts_at_zero*: bool (default: False)
		    if True, the head starts being drawn at coordinate 0
		    instead of ending at coordinate 0.
		
		Other valid kwargs (inherited from :class:`Patch`) are:
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa: unknown
		  capstyle: {'butt', 'round', 'projecting'}
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color: color
		  contains: callable
		  edgecolor or ec: color or None or 'auto'
		  facecolor or fc: color or None
		  figure: `.Figure`
		  fill: bool
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float or None
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  visible: bool
		  zorder: float
		
		Notes
		-----
		The resulting arrow is affected by the axes aspect ratio and limits.
		This may produce an arrow whose head is not square with its stem. To
		create an arrow whose head is square with its stem,
		use :meth:`annotate` for example:
		
		>>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
		...             arrowprops=dict(arrowstyle="->"))
	**/
	static public function arrow(x:Dynamic, y:Dynamic, dx:Dynamic, dy:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Convert the input to an ndarray, but pass ndarray subclasses through.
		
		Parameters
		----------
		a : array_like
		    Input data, in any form that can be converted to an array.  This
		    includes scalars, lists, lists of tuples, tuples, tuples of tuples,
		    tuples of lists, and ndarrays.
		dtype : data-type, optional
		    By default, the data-type is inferred from the input data.
		order : {'C', 'F'}, optional
		    Whether to use row-major (C-style) or column-major
		    (Fortran-style) memory representation.  Defaults to 'C'.
		
		Returns
		-------
		out : ndarray or an ndarray subclass
		    Array interpretation of `a`.  If `a` is an ndarray or a subclass
		    of ndarray, it is returned as-is and no copy is performed.
		
		See Also
		--------
		asarray : Similar function which always returns ndarrays.
		ascontiguousarray : Convert input to a contiguous array.
		asfarray : Convert input to a floating point ndarray.
		asfortranarray : Convert input to an ndarray with column-major
		                 memory order.
		asarray_chkfinite : Similar function which checks input for NaNs and
		                    Infs.
		fromiter : Create an array from an iterator.
		fromfunction : Construct an array by executing a function on grid
		               positions.
		
		Examples
		--------
		Convert a list into an array:
		
		>>> a = [1, 2]
		>>> np.asanyarray(a)
		array([1, 2])
		
		Instances of `ndarray` subclasses are passed through as-is:
		
		>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
		>>> np.asanyarray(a) is a
		True
	**/
	static public function asanyarray(a:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Convert the input to an array.
		
		Parameters
		----------
		a : array_like
		    Input data, in any form that can be converted to an array.  This
		    includes lists, lists of tuples, tuples, tuples of tuples, tuples
		    of lists and ndarrays.
		dtype : data-type, optional
		    By default, the data-type is inferred from the input data.
		order : {'C', 'F'}, optional
		    Whether to use row-major (C-style) or
		    column-major (Fortran-style) memory representation.
		    Defaults to 'C'.
		
		Returns
		-------
		out : ndarray
		    Array interpretation of `a`.  No copy is performed if the input
		    is already an ndarray with matching dtype and order.  If `a` is a
		    subclass of ndarray, a base class ndarray is returned.
		
		See Also
		--------
		asanyarray : Similar function which passes through subclasses.
		ascontiguousarray : Convert input to a contiguous array.
		asfarray : Convert input to a floating point ndarray.
		asfortranarray : Convert input to an ndarray with column-major
		                 memory order.
		asarray_chkfinite : Similar function which checks input for NaNs and Infs.
		fromiter : Create an array from an iterator.
		fromfunction : Construct an array by executing a function on grid
		               positions.
		
		Examples
		--------
		Convert a list into an array:
		
		>>> a = [1, 2]
		>>> np.asarray(a)
		array([1, 2])
		
		Existing arrays are not copied:
		
		>>> a = np.array([1, 2])
		>>> np.asarray(a) is a
		True
		
		If `dtype` is set, array is copied only if dtype does not match:
		
		>>> a = np.array([1, 2], dtype=np.float32)
		>>> np.asarray(a, dtype=np.float32) is a
		True
		>>> np.asarray(a, dtype=np.float64) is a
		False
		
		Contrary to `asanyarray`, ndarray subclasses are not passed through:
		
		>>> issubclass(np.recarray, np.ndarray)
		True
		>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
		>>> np.asarray(a) is a
		False
		>>> np.asanyarray(a) is a
		True
	**/
	static public function asarray(a:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Convert the input to an array, checking for NaNs or Infs.
		
		Parameters
		----------
		a : array_like
		    Input data, in any form that can be converted to an array.  This
		    includes lists, lists of tuples, tuples, tuples of tuples, tuples
		    of lists and ndarrays.  Success requires no NaNs or Infs.
		dtype : data-type, optional
		    By default, the data-type is inferred from the input data.
		order : {'C', 'F'}, optional
		     Whether to use row-major (C-style) or
		     column-major (Fortran-style) memory representation.
		     Defaults to 'C'.
		
		Returns
		-------
		out : ndarray
		    Array interpretation of `a`.  No copy is performed if the input
		    is already an ndarray.  If `a` is a subclass of ndarray, a base
		    class ndarray is returned.
		
		Raises
		------
		ValueError
		    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).
		
		See Also
		--------
		asarray : Create and array.
		asanyarray : Similar function which passes through subclasses.
		ascontiguousarray : Convert input to a contiguous array.
		asfarray : Convert input to a floating point ndarray.
		asfortranarray : Convert input to an ndarray with column-major
		                 memory order.
		fromiter : Create an array from an iterator.
		fromfunction : Construct an array by executing a function on grid
		               positions.
		
		Examples
		--------
		Convert a list into an array.  If all elements are finite
		``asarray_chkfinite`` is identical to ``asarray``.
		
		>>> a = [1, 2]
		>>> np.asarray_chkfinite(a, dtype=float)
		array([1., 2.])
		
		Raises ValueError if array_like contains Nans or Infs.
		
		>>> a = [1, 2, np.inf]
		>>> try:
		...     np.asarray_chkfinite(a)
		... except ValueError:
		...     print('ValueError')
		...
		ValueError
	**/
	static public function asarray_chkfinite(a:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Return a contiguous array (ndim >= 1) in memory (C order).
		
		Parameters
		----------
		a : array_like
		    Input array.
		dtype : str or dtype object, optional
		    Data-type of returned array.
		
		Returns
		-------
		out : ndarray
		    Contiguous array of same shape and content as `a`, with type `dtype`
		    if specified.
		
		See Also
		--------
		asfortranarray : Convert input to an ndarray with column-major
		                 memory order.
		require : Return an ndarray that satisfies requirements.
		ndarray.flags : Information about the memory layout of the array.
		
		Examples
		--------
		>>> x = np.arange(6).reshape(2,3)
		>>> np.ascontiguousarray(x, dtype=np.float32)
		array([[ 0.,  1.,  2.],
		       [ 3.,  4.,  5.]], dtype=float32)
		>>> x.flags['C_CONTIGUOUS']
		True
		
		Note: This function returns an array with at least one-dimension (1-d) 
		so it will not preserve 0-d arrays.  
	**/
	static public function ascontiguousarray(a:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		Return an array converted to a float type.
		
		Parameters
		----------
		a : array_like
		    The input array.
		dtype : str or dtype object, optional
		    Float type code to coerce input array `a`.  If `dtype` is one of the
		    'int' dtypes, it is replaced with float64.
		
		Returns
		-------
		out : ndarray
		    The input `a` as a float ndarray.
		
		Examples
		--------
		>>> np.asfarray([2, 3])
		array([ 2.,  3.])
		>>> np.asfarray([2, 3], dtype='float')
		array([ 2.,  3.])
		>>> np.asfarray([2, 3], dtype='int8')
		array([ 2.,  3.])
	**/
	static public function asfarray(a:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		Return an array (ndim >= 1) laid out in Fortran order in memory.
		
		Parameters
		----------
		a : array_like
		    Input array.
		dtype : str or dtype object, optional
		    By default, the data-type is inferred from the input data.
		
		Returns
		-------
		out : ndarray
		    The input `a` in Fortran, or column-major, order.
		
		See Also
		--------
		ascontiguousarray : Convert input to a contiguous (C order) array.
		asanyarray : Convert input to an ndarray with either row or
		    column-major memory order.
		require : Return an ndarray that satisfies requirements.
		ndarray.flags : Information about the memory layout of the array.
		
		Examples
		--------
		>>> x = np.arange(6).reshape(2,3)
		>>> y = np.asfortranarray(x)
		>>> x.flags['F_CONTIGUOUS']
		False
		>>> y.flags['F_CONTIGUOUS']
		True
		
		Note: This function returns an array with at least one-dimension (1-d) 
		so it will not preserve 0-d arrays.  
	**/
	static public function asfortranarray(a:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		Interpret the input as a matrix.
		
		Unlike `matrix`, `asmatrix` does not make a copy if the input is already
		a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.
		
		Parameters
		----------
		data : array_like
		    Input data.
		dtype : data-type
		   Data-type of the output matrix.
		
		Returns
		-------
		mat : matrix
		    `data` interpreted as a matrix.
		
		Examples
		--------
		>>> x = np.array([[1, 2], [3, 4]])
		
		>>> m = np.asmatrix(x)
		
		>>> x[0,0] = 5
		
		>>> m
		matrix([[5, 2],
		        [3, 4]])
	**/
	static public function asmatrix(data:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		Convert an array of size 1 to its scalar equivalent.
		
		.. deprecated:: 1.16
		
		    Deprecated, use `numpy.ndarray.item()` instead.
		
		Parameters
		----------
		a : ndarray
		    Input array of size 1.
		
		Returns
		-------
		out : scalar
		    Scalar representation of `a`. The output data type is the same type
		    returned by the input's `item` method.
		
		Examples
		--------
		>>> np.asscalar(np.array([24]))
		24
	**/
	static public function asscalar(a:Dynamic):Dynamic;
	/**
		Convert inputs to arrays with at least one dimension.
		
		Scalar inputs are converted to 1-dimensional arrays, whilst
		higher-dimensional inputs are preserved.
		
		Parameters
		----------
		arys1, arys2, ... : array_like
		    One or more input arrays.
		
		Returns
		-------
		ret : ndarray
		    An array, or list of arrays, each with ``a.ndim >= 1``.
		    Copies are made only if necessary.
		
		See Also
		--------
		atleast_2d, atleast_3d
		
		Examples
		--------
		>>> np.atleast_1d(1.0)
		array([ 1.])
		
		>>> x = np.arange(9.0).reshape(3,3)
		>>> np.atleast_1d(x)
		array([[ 0.,  1.,  2.],
		       [ 3.,  4.,  5.],
		       [ 6.,  7.,  8.]])
		>>> np.atleast_1d(x) is x
		True
		
		>>> np.atleast_1d(1, [3, 4])
		[array([1]), array([3, 4])]
	**/
	static public function atleast_1d(?arys:python.VarArgs<Dynamic>):Dynamic;
	/**
		View inputs as arrays with at least two dimensions.
		
		Parameters
		----------
		arys1, arys2, ... : array_like
		    One or more array-like sequences.  Non-array inputs are converted
		    to arrays.  Arrays that already have two or more dimensions are
		    preserved.
		
		Returns
		-------
		res, res2, ... : ndarray
		    An array, or list of arrays, each with ``a.ndim >= 2``.
		    Copies are avoided where possible, and views with two or more
		    dimensions are returned.
		
		See Also
		--------
		atleast_1d, atleast_3d
		
		Examples
		--------
		>>> np.atleast_2d(3.0)
		array([[ 3.]])
		
		>>> x = np.arange(3.0)
		>>> np.atleast_2d(x)
		array([[ 0.,  1.,  2.]])
		>>> np.atleast_2d(x).base is x
		True
		
		>>> np.atleast_2d(1, [1, 2], [[1, 2]])
		[array([[1]]), array([[1, 2]]), array([[1, 2]])]
	**/
	static public function atleast_2d(?arys:python.VarArgs<Dynamic>):Dynamic;
	/**
		View inputs as arrays with at least three dimensions.
		
		Parameters
		----------
		arys1, arys2, ... : array_like
		    One or more array-like sequences.  Non-array inputs are converted to
		    arrays.  Arrays that already have three or more dimensions are
		    preserved.
		
		Returns
		-------
		res1, res2, ... : ndarray
		    An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are
		    avoided where possible, and views with three or more dimensions are
		    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
		    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
		    view of shape ``(M, N, 1)``.
		
		See Also
		--------
		atleast_1d, atleast_2d
		
		Examples
		--------
		>>> np.atleast_3d(3.0)
		array([[[ 3.]]])
		
		>>> x = np.arange(3.0)
		>>> np.atleast_3d(x).shape
		(1, 3, 1)
		
		>>> x = np.arange(12.0).reshape(4,3)
		>>> np.atleast_3d(x).shape
		(4, 3, 1)
		>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
		True
		
		>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
		...     print(arr, arr.shape)
		...
		[[[1]
		  [2]]] (1, 2, 1)
		[[[1]
		  [2]]] (1, 2, 1)
		[[[1 2]]] (1, 1, 2)
	**/
	static public function atleast_3d(?arys:python.VarArgs<Dynamic>):Dynamic;
	/**
		Autoscale the axis view to the data (toggle).
		
		Convenience method for simple axis view autoscaling.
		It turns autoscaling on or off, and then,
		if autoscaling for either axis is on, it performs
		the autoscaling on the specified axis or axes.
		
		Parameters
		----------
		enable : bool or None, optional
		    True (default) turns autoscaling on, False turns it off.
		    None leaves the autoscaling state unchanged.
		
		axis : {'both', 'x', 'y'}, optional
		    which axis to operate on; default is 'both'
		
		tight : bool or None, optional
		    If True, set view limits to data limits;
		    if False, let the locator and margins expand the view limits;
		    if None, use tight scaling if the only artist is an image,
		    otherwise treat *tight* as False.
		    The *tight* setting is retained for future autoscaling
		    until it is explicitly changed.
	**/
	static public function autoscale(?enable:Dynamic, ?axis:Dynamic, ?tight:Dynamic):Dynamic;
	/**
		Set the colormap to "autumn".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function autumn():Dynamic;
	/**
		Compute the weighted average along the specified axis.
		
		Parameters
		----------
		a : array_like
		    Array containing data to be averaged. If `a` is not an array, a
		    conversion is attempted.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which to average `a`.  The default,
		    axis=None, will average over all of the elements of the input array.
		    If axis is negative it counts from the last to the first axis.
		
		    .. versionadded:: 1.7.0
		
		    If axis is a tuple of ints, averaging is performed on all of the axes
		    specified in the tuple instead of a single axis or all the axes as
		    before.
		weights : array_like, optional
		    An array of weights associated with the values in `a`. Each value in
		    `a` contributes to the average according to its associated weight.
		    The weights array can either be 1-D (in which case its length must be
		    the size of `a` along the given axis) or of the same shape as `a`.
		    If `weights=None`, then all data in `a` are assumed to have a
		    weight equal to one.
		returned : bool, optional
		    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
		    is returned, otherwise only the average is returned.
		    If `weights=None`, `sum_of_weights` is equivalent to the number of
		    elements over which the average is taken.
		
		
		Returns
		-------
		retval, [sum_of_weights] : array_type or double
		    Return the average along the specified axis. When `returned` is `True`,
		    return a tuple with the average as the first element and the sum
		    of the weights as the second element. `sum_of_weights` is of the
		    same type as `retval`. The result dtype follows a genereal pattern.
		    If `weights` is None, the result dtype will be that of `a` , or ``float64``
		    if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
		    integral, the result type will be the type of lowest precision capable of
		    representing values of both `a` and `weights`. If `a` happens to be
		    integral, the previous rules still applies but the result dtype will
		    at least be ``float64``.
		
		Raises
		------
		ZeroDivisionError
		    When all weights along axis are zero. See `numpy.ma.average` for a
		    version robust to this type of error.
		TypeError
		    When the length of 1D `weights` is not the same as the shape of `a`
		    along axis.
		
		See Also
		--------
		mean
		
		ma.average : average for masked arrays -- useful if your data contains
		             "missing" values
		numpy.result_type : Returns the type that results from applying the
		                    numpy type promotion rules to the arguments.
		
		Examples
		--------
		>>> data = range(1,5)
		>>> data
		[1, 2, 3, 4]
		>>> np.average(data)
		2.5
		>>> np.average(range(1,11), weights=range(10,0,-1))
		4.0
		
		>>> data = np.arange(6).reshape((3,2))
		>>> data
		array([[0, 1],
		       [2, 3],
		       [4, 5]])
		>>> np.average(data, axis=1, weights=[1./4, 3./4])
		array([ 0.75,  2.75,  4.75])
		>>> np.average(data, weights=[1./4, 3./4])
		
		Traceback (most recent call last):
		...
		TypeError: Axis must be specified when shapes of a and weights differ.
		
		>>> a = np.ones(5, dtype=np.float128)
		>>> w = np.ones(5, dtype=np.complex64)
		>>> avg = np.average(a, weights=w)
		>>> print(avg.dtype)
		complex256
	**/
	static public function average(a:Dynamic, ?axis:Dynamic, ?weights:Dynamic, ?returned:Dynamic):Dynamic;
	/**
		Add an axes to the current figure and make it the current axes.
		
		Call signatures::
		
		    plt.axes()
		    plt.axes(rect, projection=None, polar=False, **kwargs)
		    plt.axes(ax)
		
		Parameters
		----------
		arg : { None, 4-tuple, Axes }
		    The exact behavior of this function depends on the type:
		
		    - *None*: A new full window axes is added using
		      ``subplot(111, **kwargs)``
		    - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
		      A new axes is added with dimensions *rect* in normalized
		      (0, 1) units using `~.Figure.add_axes` on the current figure.
		    - `~.axes.Axes`: This is equivalent to `.pyplot.sca`.
		      It sets the current axes to *arg*. Note: This implicitly
		      changes the current figure to the parent of *arg*.
		
		      .. note:: The use of an `.axes.Axes` as an argument is deprecated
		                and will be removed in v3.0. Please use `.pyplot.sca`
		                instead.
		
		projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', 'polar', 'rectilinear', str}, optional
		    The projection type of the `~.axes.Axes`. *str* is the name of
		    a costum projection, see `~matplotlib.projections`. The default
		    None results in a 'rectilinear' projection.
		
		polar : boolean, optional
		    If True, equivalent to projection='polar'.
		
		sharex, sharey : `~.axes.Axes`, optional
		    Share the x or y `~matplotlib.axis` with sharex and/or sharey.
		    The axis will have the same limits, ticks, and scale as the axis
		    of the shared axes.
		
		
		label : str
		    A label for the returned axes.
		
		Other Parameters
		----------------
		**kwargs
		    This method also takes the keyword arguments for
		    the returned axes class. The keyword arguments for the
		    rectilinear axes class `~.axes.Axes` can be found in
		    the following table but there might also be other keyword
		    arguments if another projection is used, see the actual axes
		    class.
		      adjustable: {'box', 'datalim'}
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  anchor: 2-tuple of floats or {'C', 'SW', 'S', 'SE', ...}
		  animated: bool
		  aspect: {'auto', 'equal'} or num
		  autoscale_on: bool
		  autoscalex_on: bool
		  autoscaley_on: bool
		  axes_locator: Callable[[Axes, Renderer], Bbox]
		  axisbelow: bool or 'line'
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  contains: callable
		  facecolor: color
		  fc: color
		  figure: `.Figure`
		  frame_on: bool
		  gid: str
		  in_layout: bool
		  label: object
		  navigate: bool
		  navigate_mode: unknown
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  position: [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
		  rasterization_zorder: float or None
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  title: str
		  transform: `.Transform`
		  url: str
		  visible: bool
		  xbound: unknown
		  xlabel: str
		  xlim: (left: float, right: float)
		  xmargin: float greater than -0.5
		  xscale: {"linear", "log", "symlog", "logit", ...}
		  xticklabels: List[str]
		  xticks: list
		  ybound: unknown
		  ylabel: str
		  ylim: (bottom: float, top: float)
		  ymargin: float greater than -0.5
		  yscale: {"linear", "log", "symlog", "logit", ...}
		  yticklabels: List[str]
		  yticks: list
		  zorder: float
		
		Returns
		-------
		axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
		    The returned axes class depends on the projection used. It is
		    `~.axes.Axes` if rectilinear projection are used and
		    `.projections.polar.PolarAxes` if polar projection
		    are used.
		
		Notes
		-----
		If the figure already has a axes with key (*args*,
		*kwargs*) then it will simply make that axes current and
		return it.  This behavior is deprecated. Meanwhile, if you do
		not want this behavior (i.e., you want to force the creation of a
		new axes), you must use a unique set of args and kwargs.  The axes
		*label* attribute has been exposed for this purpose: if you want
		two axes that are otherwise identical to be added to the figure,
		make sure you give them unique labels.
		
		See Also
		--------
		.Figure.add_axes
		.pyplot.subplot
		.Figure.add_subplot
		.Figure.subplots
		.pyplot.subplots
		
		Examples
		--------
		::
		
		    # Creating a new full window axes
		    plt.axes()
		
		    # Creating a new axes with specified dimensions and some kwargs
		    plt.axes((left, bottom, width, height), facecolor='w')
	**/
	static public function axes(?arg:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Add a horizontal line across the axis.
		
		Parameters
		----------
		y : scalar, optional, default: 0
		    y position in data coordinates of the horizontal line.
		
		xmin : scalar, optional, default: 0
		    Should be between 0 and 1, 0 being the far left of the plot, 1 the
		    far right of the plot.
		
		xmax : scalar, optional, default: 1
		    Should be between 0 and 1, 0 being the far left of the plot, 1 the
		    far right of the plot.
		
		Returns
		-------
		line : :class:`~matplotlib.lines.Line2D`
		
		Other Parameters
		----------------
		**kwargs
		    Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,
		    with the exception of 'transform':
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See also
		--------
		hlines : Add horizontal lines in data coordinates.
		axhspan : Add a horizontal span (rectangle) across the axis.
		
		Examples
		--------
		
		* draw a thick red hline at 'y' = 0 that spans the xrange::
		
		    >>> axhline(linewidth=4, color='r')
		
		* draw a default hline at 'y' = 1 that spans the xrange::
		
		    >>> axhline(y=1)
		
		* draw a default hline at 'y' = .5 that spans the middle half of
		  the xrange::
		
		    >>> axhline(y=.5, xmin=0.25, xmax=0.75)
	**/
	static public function axhline(?y:Dynamic, ?xmin:Dynamic, ?xmax:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Add a horizontal span (rectangle) across the axis.
		
		Draw a horizontal span (rectangle) from *ymin* to *ymax*.
		With the default values of *xmin* = 0 and *xmax* = 1, this
		always spans the xrange, regardless of the xlim settings, even
		if you change them, e.g., with the :meth:`set_xlim` command.
		That is, the horizontal extent is in axes coords: 0=left,
		0.5=middle, 1.0=right but the *y* location is in data
		coordinates.
		
		Parameters
		----------
		ymin : float
		       Lower limit of the horizontal span in data units.
		ymax : float
		       Upper limit of the horizontal span in data units.
		xmin : float, optional, default: 0
		       Lower limit of the vertical span in axes (relative
		       0-1) units.
		xmax : float, optional, default: 1
		       Upper limit of the vertical span in axes (relative
		       0-1) units.
		
		Returns
		-------
		Polygon : `~matplotlib.patches.Polygon`
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.patches.Polygon` properties.
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa: unknown
		  capstyle: {'butt', 'round', 'projecting'}
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color: color
		  contains: callable
		  edgecolor or ec: color or None or 'auto'
		  facecolor or fc: color or None
		  figure: `.Figure`
		  fill: bool
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float or None
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  visible: bool
		  zorder: float
		
		See Also
		--------
		axvspan : Add a vertical span across the axes.
	**/
	static public function axhspan(ymin:Dynamic, ymax:Dynamic, ?xmin:Dynamic, ?xmax:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Convenience method to get or set some axis properties.
		
		Call signatures::
		
		  xmin, xmax, ymin, ymax = axis()
		  xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
		  xmin, xmax, ymin, ymax = axis(option)
		  xmin, xmax, ymin, ymax = axis(**kwargs)
		
		Parameters
		----------
		xmin, xmax, ymin, ymax : float, optional
		    The axis limits to be set. Either none or all of the limits must
		    be given.
		
		option : bool or str
		    If a bool, turns axis lines and labels on or off. If a string,
		    possible values are:
		
		    ======== ==========================================================
		    Value    Description
		    ======== ==========================================================
		    'on'     Turn on axis lines and labels. Same as ``True``.
		    'off'    Turn off axis lines and labels. Same as ``False``.
		    'equal'  Set equal scaling (i.e., make circles circular) by
		             changing axis limits.
		    'scaled' Set equal scaling (i.e., make circles circular) by
		             changing dimensions of the plot box.
		    'tight'  Set limits just large enough to show all data.
		    'auto'   Automatic scaling (fill plot box with data).
		    'normal' Same as 'auto'; deprecated.
		    'image'  'scaled' with axis limits equal to data limits.
		    'square' Square plot; similar to 'scaled', but initially forcing
		             ``xmax-xmin = ymax-ymin``.
		    ======== ==========================================================
		
		emit : bool, optional, default *True*
		    Whether observers are notified of the axis limit change.
		    This option is passed on to `~.Axes.set_xlim` and
		    `~.Axes.set_ylim`.
		
		Returns
		-------
		xmin, xmax, ymin, ymax : float
		    The axis limits.
		
		See also
		--------
		matplotlib.axes.Axes.set_xlim
		matplotlib.axes.Axes.set_ylim
	**/
	static public function axis(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Float;
	/**
		Add a vertical line across the axes.
		
		Parameters
		----------
		x : scalar, optional, default: 0
		    x position in data coordinates of the vertical line.
		
		ymin : scalar, optional, default: 0
		    Should be between 0 and 1, 0 being the bottom of the plot, 1 the
		    top of the plot.
		
		ymax : scalar, optional, default: 1
		    Should be between 0 and 1, 0 being the bottom of the plot, 1 the
		    top of the plot.
		
		Returns
		-------
		line : :class:`~matplotlib.lines.Line2D`
		
		Other Parameters
		----------------
		**kwargs
		    Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,
		    with the exception of 'transform':
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		Examples
		--------
		* draw a thick red vline at *x* = 0 that spans the yrange::
		
		    >>> axvline(linewidth=4, color='r')
		
		* draw a default vline at *x* = 1 that spans the yrange::
		
		    >>> axvline(x=1)
		
		* draw a default vline at *x* = .5 that spans the middle half of
		  the yrange::
		
		    >>> axvline(x=.5, ymin=0.25, ymax=0.75)
		
		See also
		--------
		vlines : Add vertical lines in data coordinates.
		axvspan : Add a vertical span (rectangle) across the axis.
	**/
	static public function axvline(?x:Dynamic, ?ymin:Dynamic, ?ymax:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Add a vertical span (rectangle) across the axes.
		
		Draw a vertical span (rectangle) from `xmin` to `xmax`.  With
		the default values of `ymin` = 0 and `ymax` = 1. This always
		spans the yrange, regardless of the ylim settings, even if you
		change them, e.g., with the :meth:`set_ylim` command.  That is,
		the vertical extent is in axes coords: 0=bottom, 0.5=middle,
		1.0=top but the x location is in data coordinates.
		
		Parameters
		----------
		xmin : scalar
		    Number indicating the first X-axis coordinate of the vertical
		    span rectangle in data units.
		xmax : scalar
		    Number indicating the second X-axis coordinate of the vertical
		    span rectangle in data units.
		ymin : scalar, optional
		    Number indicating the first Y-axis coordinate of the vertical
		    span rectangle in relative Y-axis units (0-1). Default to 0.
		ymax : scalar, optional
		    Number indicating the second Y-axis coordinate of the vertical
		    span rectangle in relative Y-axis units (0-1). Default to 1.
		
		Returns
		-------
		rectangle : matplotlib.patches.Polygon
		    Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
		
		Other Parameters
		----------------
		**kwargs
		    Optional parameters are properties of the class
		    matplotlib.patches.Polygon.
		
		See Also
		--------
		axhspan : Add a horizontal span across the axes.
		
		Examples
		--------
		Draw a vertical, green, translucent rectangle from x = 1.25 to
		x = 1.55 that spans the yrange of the axes.
		
		>>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
	**/
	static public function axvspan(xmin:Dynamic, xmax:Dynamic, ?ymin:Dynamic, ?ymax:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Make a bar plot.
		
		The bars are positioned at *x* with the given *align*\ment. Their
		dimensions are given by *width* and *height*. The vertical baseline
		is *bottom* (default 0).
		
		Each of *x*, *height*, *width*, and *bottom* may either be a scalar
		applying to all bars, or it may be a sequence of length N providing a
		separate value for each bar.
		
		Parameters
		----------
		x : sequence of scalars
		    The x coordinates of the bars. See also *align* for the
		    alignment of the bars to the coordinates.
		
		height : scalar or sequence of scalars
		    The height(s) of the bars.
		
		width : scalar or array-like, optional
		    The width(s) of the bars (default: 0.8).
		
		bottom : scalar or array-like, optional
		    The y coordinate(s) of the bars bases (default: 0).
		
		align : {'center', 'edge'}, optional, default: 'center'
		    Alignment of the bars to the *x* coordinates:
		
		    - 'center': Center the base on the *x* positions.
		    - 'edge': Align the left edges of the bars with the *x* positions.
		
		    To align the bars on the right edge pass a negative *width* and
		    ``align='edge'``.
		
		Returns
		-------
		container : `.BarContainer`
		    Container with all the bars and optionally errorbars.
		
		Other Parameters
		----------------
		color : scalar or array-like, optional
		    The colors of the bar faces.
		
		edgecolor : scalar or array-like, optional
		    The colors of the bar edges.
		
		linewidth : scalar or array-like, optional
		    Width of the bar edge(s). If 0, don't draw edges.
		
		tick_label : string or array-like, optional
		    The tick labels of the bars.
		    Default: None (Use default numeric labels.)
		
		xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional
		    If not *None*, add horizontal / vertical errorbars to the bar tips.
		    The values are +/- sizes relative to the data:
		
		    - scalar: symmetric +/- values for all bars
		    - shape(N,): symmetric +/- values for each bar
		    - shape(2,N): Separate - and + values for each bar. First row
		        contains the lower errors, the second row contains the
		        upper errors.
		    - *None*: No errorbar. (Default)
		
		    See :doc:`/gallery/statistics/errorbar_features`
		    for an example on the usage of ``xerr`` and ``yerr``.
		
		ecolor : scalar or array-like, optional, default: 'black'
		    The line color of the errorbars.
		
		capsize : scalar, optional
		   The length of the error bar caps in points.
		   Default: None, which will take the value from
		   :rc:`errorbar.capsize`.
		
		error_kw : dict, optional
		    Dictionary of kwargs to be passed to the `~.Axes.errorbar`
		    method. Values of *ecolor* or *capsize* defined here take
		    precedence over the independent kwargs.
		
		log : bool, optional, default: False
		    If *True*, set the y-axis to be log scale.
		
		orientation : {'vertical',  'horizontal'}, optional
		    *This is for internal use only.* Please use `barh` for
		    horizontal bar plots. Default: 'vertical'.
		
		See also
		--------
		barh: Plot a horizontal bar plot.
		
		Notes
		-----
		The optional arguments *color*, *edgecolor*, *linewidth*,
		*xerr*, and *yerr* can be either scalars or sequences of
		length equal to the number of bars.  This enables you to use
		bar as the basis for stacked bar charts, or candlestick plots.
		Detail: *xerr* and *yerr* are passed directly to
		:meth:`errorbar`, so they can also have shape 2xN for
		independent specification of lower and upper errors.
		
		Other optional kwargs:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa: unknown
		  capstyle: {'butt', 'round', 'projecting'}
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color: color
		  contains: callable
		  edgecolor or ec: color or None or 'auto'
		  facecolor or fc: color or None
		  figure: `.Figure`
		  fill: bool
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float or None
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  visible: bool
		  zorder: float
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function bar(x:Dynamic, height:Dynamic, ?width:Dynamic, ?bottom:Dynamic, ?align:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Plot a 2-D field of barbs.
		
		Call signatures::
		
		  barb(U, V, **kw)
		  barb(U, V, C, **kw)
		  barb(X, Y, U, V, **kw)
		  barb(X, Y, U, V, C, **kw)
		
		Arguments:
		
		  *X*, *Y*:
		    The x and y coordinates of the barb locations
		    (default is head of barb; see *pivot* kwarg)
		
		  *U*, *V*:
		    Give the x and y components of the barb shaft
		
		  *C*:
		    An optional array used to map colors to the barbs
		
		All arguments may be 1-D or 2-D arrays or sequences. If *X* and *Y*
		are absent, they will be generated as a uniform grid.  If *U* and *V*
		are 2-D arrays but *X* and *Y* are 1-D, and if ``len(X)`` and ``len(Y)``
		match the column and row dimensions of *U*, then *X* and *Y* will be
		expanded with :func:`numpy.meshgrid`.
		
		*U*, *V*, *C* may be masked arrays, but masked *X*, *Y* are not
		supported at present.
		
		Keyword arguments:
		
		  *length*:
		    Length of the barb in points; the other parts of the barb
		    are scaled against this.
		    Default is 7.
		
		  *pivot*: [ 'tip' | 'middle' | float ]
		    The part of the arrow that is at the grid point; the arrow rotates
		    about this point, hence the name *pivot*.  Default is 'tip'. Can
		    also be a number, which shifts the start of the barb that many
		    points from the origin.
		
		  *barbcolor*: [ color | color sequence ]
		    Specifies the color all parts of the barb except any flags.  This
		    parameter is analogous to the *edgecolor* parameter for polygons,
		    which can be used instead. However this parameter will override
		    facecolor.
		
		  *flagcolor*: [ color | color sequence ]
		    Specifies the color of any flags on the barb.  This parameter is
		    analogous to the *facecolor* parameter for polygons, which can be
		    used instead. However this parameter will override facecolor.  If
		    this is not set (and *C* has not either) then *flagcolor* will be
		    set to match *barbcolor* so that the barb has a uniform color. If
		    *C* has been set, *flagcolor* has no effect.
		
		  *sizes*:
		    A dictionary of coefficients specifying the ratio of a given
		    feature to the length of the barb. Only those values one wishes to
		    override need to be included.  These features include:
		
		        - 'spacing' - space between features (flags, full/half barbs)
		
		        - 'height' - height (distance from shaft to top) of a flag or
		          full barb
		
		        - 'width' - width of a flag, twice the width of a full barb
		
		        - 'emptybarb' - radius of the circle used for low magnitudes
		
		  *fill_empty*:
		    A flag on whether the empty barbs (circles) that are drawn should
		    be filled with the flag color.  If they are not filled, they will
		    be drawn such that no color is applied to the center.  Default is
		    False
		
		  *rounding*:
		    A flag to indicate whether the vector magnitude should be rounded
		    when allocating barb components.  If True, the magnitude is
		    rounded to the nearest multiple of the half-barb increment.  If
		    False, the magnitude is simply truncated to the next lowest
		    multiple.  Default is True
		
		  *barb_increments*:
		    A dictionary of increments specifying values to associate with
		    different parts of the barb. Only those values one wishes to
		    override need to be included.
		
		        - 'half' - half barbs (Default is 5)
		
		        - 'full' - full barbs (Default is 10)
		
		        - 'flag' - flags (default is 50)
		
		  *flip_barb*:
		    Either a single boolean flag or an array of booleans.  Single
		    boolean indicates whether the lines and flags should point
		    opposite to normal for all barbs.  An array (which should be the
		    same size as the other data arrays) indicates whether to flip for
		    each individual barb.  Normal behavior is for the barbs and lines
		    to point right (comes from wind barbs having these features point
		    towards low pressure in the Northern Hemisphere.)  Default is
		    False
		
		Barbs are traditionally used in meteorology as a way to plot the speed
		and direction of wind observations, but can technically be used to
		plot any two dimensional vector quantity.  As opposed to arrows, which
		give vector magnitude by the length of the arrow, the barbs give more
		quantitative information about the vector magnitude by putting slanted
		lines or a triangle for various increments in magnitude, as show
		schematically below::
		
		 :     /\    \\
		 :    /  \    \\
		 :   /    \    \    \\
		 :  /      \    \    \\
		 : ------------------------------
		
		.. note the double \\ at the end of each line to make the figure
		.. render correctly
		
		The largest increment is given by a triangle (or "flag"). After those
		come full lines (barbs). The smallest increment is a half line.  There
		is only, of course, ever at most 1 half line.  If the magnitude is
		small and only needs a single half-line and no full lines or
		triangles, the half-line is offset from the end of the barb so that it
		can be easily distinguished from barbs with a single full line.  The
		magnitude for the barb shown above would nominally be 65, using the
		standard increments of 50, 10, and 5.
		
		linewidths and edgecolors can be used to customize the barb.
		Additional :class:`~matplotlib.collections.PolyCollection` keyword
		arguments:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function barbs(?args:python.VarArgs<Dynamic>, ?data:Dynamic, ?kw:python.KwArgs<Dynamic>):Dynamic;
	/**
		Make a horizontal bar plot.
		
		The bars are positioned at *y* with the given *align*\ment. Their
		dimensions are given by *width* and *height*. The horizontal baseline
		is *left* (default 0).
		
		Each of *y*, *width*, *height*, and *left* may either be a scalar
		applying to all bars, or it may be a sequence of length N providing a
		separate value for each bar.
		
		Parameters
		----------
		y : scalar or array-like
		    The y coordinates of the bars. See also *align* for the
		    alignment of the bars to the coordinates.
		
		width : scalar or array-like
		    The width(s) of the bars.
		
		height : sequence of scalars, optional, default: 0.8
		    The heights of the bars.
		
		left : sequence of scalars
		    The x coordinates of the left sides of the bars (default: 0).
		
		align : {'center', 'edge'}, optional, default: 'center'
		    Alignment of the base to the *y* coordinates*:
		
		    - 'center': Center the bars on the *y* positions.
		    - 'edge': Align the bottom edges of the bars with the *y*
		      positions.
		
		    To align the bars on the top edge pass a negative *height* and
		    ``align='edge'``.
		
		Returns
		-------
		container : `.BarContainer`
		    Container with all the bars and optionally errorbars.
		
		Other Parameters
		----------------
		color : scalar or array-like, optional
		    The colors of the bar faces.
		
		edgecolor : scalar or array-like, optional
		    The colors of the bar edges.
		
		linewidth : scalar or array-like, optional
		    Width of the bar edge(s). If 0, don't draw edges.
		
		tick_label : string or array-like, optional
		    The tick labels of the bars.
		    Default: None (Use default numeric labels.)
		
		xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional
		    If not ``None``, add horizontal / vertical errorbars to the
		    bar tips. The values are +/- sizes relative to the data:
		
		    - scalar: symmetric +/- values for all bars
		    - shape(N,): symmetric +/- values for each bar
		    - shape(2,N): Separate - and + values for each bar. First row
		        contains the lower errors, the second row contains the
		        upper errors.
		    - *None*: No errorbar. (default)
		
		    See :doc:`/gallery/statistics/errorbar_features`
		    for an example on the usage of ``xerr`` and ``yerr``.
		
		ecolor : scalar or array-like, optional, default: 'black'
		    The line color of the errorbars.
		
		capsize : scalar, optional
		   The length of the error bar caps in points.
		   Default: None, which will take the value from
		   :rc:`errorbar.capsize`.
		
		error_kw : dict, optional
		    Dictionary of kwargs to be passed to the `~.Axes.errorbar`
		    method. Values of *ecolor* or *capsize* defined here take
		    precedence over the independent kwargs.
		
		log : bool, optional, default: False
		    If ``True``, set the x-axis to be log scale.
		
		See also
		--------
		bar: Plot a vertical bar plot.
		
		Notes
		-----
		The optional arguments *color*, *edgecolor*, *linewidth*,
		*xerr*, and *yerr* can be either scalars or sequences of
		length equal to the number of bars.  This enables you to use
		bar as the basis for stacked bar charts, or candlestick plots.
		Detail: *xerr* and *yerr* are passed directly to
		:meth:`errorbar`, so they can also have shape 2xN for
		independent specification of lower and upper errors.
		
		Other optional kwargs:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa: unknown
		  capstyle: {'butt', 'round', 'projecting'}
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color: color
		  contains: callable
		  edgecolor or ec: color or None or 'auto'
		  facecolor or fc: color or None
		  figure: `.Figure`
		  fill: bool
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float or None
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  visible: bool
		  zorder: float
	**/
	static public function barh(y:Dynamic, width:Dynamic, ?height:Dynamic, ?left:Dynamic, ?align:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the Bartlett window.
		
		The Bartlett window is very similar to a triangular window, except
		that the end points are at zero.  It is often used in signal
		processing for tapering a signal, without generating too much
		ripple in the frequency domain.
		
		Parameters
		----------
		M : int
		    Number of points in the output window. If zero or less, an
		    empty array is returned.
		
		Returns
		-------
		out : array
		    The triangular window, with the maximum value normalized to one
		    (the value one appears only if the number of samples is odd), with
		    the first and last samples equal to zero.
		
		See Also
		--------
		blackman, hamming, hanning, kaiser
		
		Notes
		-----
		The Bartlett window is defined as
		
		.. math:: w(n) = \frac{2}{M-1} \left(
		          \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
		          \right)
		
		Most references to the Bartlett window come from the signal
		processing literature, where it is used as one of many windowing
		functions for smoothing values.  Note that convolution with this
		window produces linear interpolation.  It is also known as an
		apodization (which means"removing the foot", i.e. smoothing
		discontinuities at the beginning and end of the sampled signal) or
		tapering function. The fourier transform of the Bartlett is the product
		of two sinc functions.
		Note the excellent discussion in Kanasewich.
		
		References
		----------
		.. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
		       Biometrika 37, 1-16, 1950.
		.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
		       The University of Alberta Press, 1975, pp. 109-110.
		.. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
		       Processing", Prentice-Hall, 1999, pp. 468-471.
		.. [4] Wikipedia, "Window function",
		       https://en.wikipedia.org/wiki/Window_function
		.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
		       "Numerical Recipes", Cambridge University Press, 1986, page 429.
		
		Examples
		--------
		>>> np.bartlett(12)
		array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,
		        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
		        0.18181818,  0.        ])
		
		Plot the window and its frequency response (requires SciPy and matplotlib):
		
		>>> from numpy.fft import fft, fftshift
		>>> window = np.bartlett(51)
		>>> plt.plot(window)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Bartlett window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Sample")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		>>> plt.figure()
		<matplotlib.figure.Figure object at 0x...>
		>>> A = fft(window, 2048) / 25.5
		>>> mag = np.abs(fftshift(A))
		>>> freq = np.linspace(-0.5, 0.5, len(A))
		>>> response = 20 * np.log10(mag)
		>>> response = np.clip(response, -100, 100)
		>>> plt.plot(freq, response)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Frequency response of Bartlett window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Magnitude [dB]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Normalized frequency [cycles per sample]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.axis('tight')
		(-0.5, 0.5, -100.0, ...)
		>>> plt.show()
	**/
	static public function bartlett(M:Dynamic):Array<Dynamic>;
	/**
		Return a string representation of a number in the given base system.
		
		Parameters
		----------
		number : int
		    The value to convert. Positive and negative values are handled.
		base : int, optional
		    Convert `number` to the `base` number system. The valid range is 2-36,
		    the default value is 2.
		padding : int, optional
		    Number of zeros padded on the left. Default is 0 (no padding).
		
		Returns
		-------
		out : str
		    String representation of `number` in `base` system.
		
		See Also
		--------
		binary_repr : Faster version of `base_repr` for base 2.
		
		Examples
		--------
		>>> np.base_repr(5)
		'101'
		>>> np.base_repr(6, 5)
		'11'
		>>> np.base_repr(7, base=5, padding=3)
		'00012'
		
		>>> np.base_repr(10, base=16)
		'A'
		>>> np.base_repr(32, base=16)
		'20'
	**/
	static public function base_repr(number:Dynamic, ?base:Dynamic, ?padding:Dynamic):String;
	/**
		beta(a, b, size=None)
		
		Draw samples from a Beta distribution.
		
		The Beta distribution is a special case of the Dirichlet distribution,
		and is related to the Gamma distribution.  It has the probability
		distribution function
		
		.. math:: f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
		                                                 (1 - x)^{\beta - 1},
		
		where the normalisation, B, is the beta function,
		
		.. math:: B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
		                             (1 - t)^{\beta - 1} dt.
		
		It is often seen in Bayesian inference and order statistics.
		
		Parameters
		----------
		a : float or array_like of floats
		    Alpha, positive (>0).
		b : float or array_like of floats
		    Beta, positive (>0).
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``a`` and ``b`` are both scalars.
		    Otherwise, ``np.broadcast(a, b).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized beta distribution.
	**/
	static public function beta(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the binary representation of the input number as a string.
		
		For negative numbers, if width is not given, a minus sign is added to the
		front. If width is given, the two's complement of the number is
		returned, with respect to that width.
		
		In a two's-complement system negative numbers are represented by the two's
		complement of the absolute value. This is the most common method of
		representing signed integers on computers [1]_. A N-bit two's-complement
		system can represent every integer in the range
		:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
		
		Parameters
		----------
		num : int
		    Only an integer decimal number can be used.
		width : int, optional
		    The length of the returned string if `num` is positive, or the length
		    of the two's complement if `num` is negative, provided that `width` is
		    at least a sufficient number of bits for `num` to be represented in the
		    designated form.
		
		    If the `width` value is insufficient, it will be ignored, and `num` will
		    be returned in binary (`num` > 0) or two's complement (`num` < 0) form
		    with its width equal to the minimum number of bits needed to represent
		    the number in the designated form. This behavior is deprecated and will
		    later raise an error.
		
		    .. deprecated:: 1.12.0
		
		Returns
		-------
		bin : str
		    Binary representation of `num` or two's complement of `num`.
		
		See Also
		--------
		base_repr: Return a string representation of a number in the given base
		           system.
		bin: Python's built-in binary representation generator of an integer.
		
		Notes
		-----
		`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
		faster.
		
		References
		----------
		.. [1] Wikipedia, "Two's complement",
		    https://en.wikipedia.org/wiki/Two's_complement
		
		Examples
		--------
		>>> np.binary_repr(3)
		'11'
		>>> np.binary_repr(-3)
		'-11'
		>>> np.binary_repr(3, width=4)
		'0011'
		
		The two's complement is returned when the input number is negative and
		width is specified:
		
		>>> np.binary_repr(-3, width=3)
		'101'
		>>> np.binary_repr(-3, width=5)
		'11101'
	**/
	static public function binary_repr(num:Dynamic, ?width:Dynamic):String;
	/**
		bincount(x, weights=None, minlength=0)
		
		Count number of occurrences of each value in array of non-negative ints.
		
		The number of bins (of size 1) is one larger than the largest value in
		`x`. If `minlength` is specified, there will be at least this number
		of bins in the output array (though it will be longer if necessary,
		depending on the contents of `x`).
		Each bin gives the number of occurrences of its index value in `x`.
		If `weights` is specified the input array is weighted by it, i.e. if a
		value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
		of ``out[n] += 1``.
		
		Parameters
		----------
		x : array_like, 1 dimension, nonnegative ints
		    Input array.
		weights : array_like, optional
		    Weights, array of the same shape as `x`.
		minlength : int, optional
		    A minimum number of bins for the output array.
		
		    .. versionadded:: 1.6.0
		
		Returns
		-------
		out : ndarray of ints
		    The result of binning the input array.
		    The length of `out` is equal to ``np.amax(x)+1``.
		
		Raises
		------
		ValueError
		    If the input is not 1-dimensional, or contains elements with negative
		    values, or if `minlength` is negative.
		TypeError
		    If the type of the input is float or complex.
		
		See Also
		--------
		histogram, digitize, unique
		
		Examples
		--------
		>>> np.bincount(np.arange(5))
		array([1, 1, 1, 1, 1])
		>>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
		array([1, 3, 1, 1, 0, 0, 0, 1])
		
		>>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
		>>> np.bincount(x).size == np.amax(x)+1
		True
		
		The input array needs to be of integer dtype, otherwise a
		TypeError is raised:
		
		>>> np.bincount(np.arange(5, dtype=float))
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		TypeError: array cannot be safely cast to required type
		
		A possible use of ``bincount`` is to perform sums over
		variable-size chunks of an array, using the ``weights`` keyword.
		
		>>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
		>>> x = np.array([0, 1, 1, 2, 2, 2])
		>>> np.bincount(x,  weights=w)
		array([ 0.3,  0.7,  1.1])
	**/
	static public function bincount(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		binomial(n, p, size=None)
		
		Draw samples from a binomial distribution.
		
		Samples are drawn from a binomial distribution with specified
		parameters, n trials and p probability of success where
		n an integer >= 0 and p is in the interval [0,1]. (n may be
		input as a float, but it is truncated to an integer in use)
		
		Parameters
		----------
		n : int or array_like of ints
		    Parameter of the distribution, >= 0. Floats are also accepted,
		    but they will be truncated to integers.
		p : float or array_like of floats
		    Parameter of the distribution, >= 0 and <=1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``n`` and ``p`` are both scalars.
		    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized binomial distribution, where
		    each sample is equal to the number of successes over the n trials.
		
		See Also
		--------
		scipy.stats.binom : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the binomial distribution is
		
		.. math:: P(N) = \binom{n}{N}p^N(1-p)^{n-N},
		
		where :math:`n` is the number of trials, :math:`p` is the probability
		of success, and :math:`N` is the number of successes.
		
		When estimating the standard error of a proportion in a population by
		using a random sample, the normal distribution works well unless the
		product p*n <=5, where p = population proportion estimate, and n =
		number of samples, in which case the binomial distribution is used
		instead. For example, a sample of 15 people shows 4 who are left
		handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
		so the binomial distribution should be used in this case.
		
		References
		----------
		.. [1] Dalgaard, Peter, "Introductory Statistics with R",
		       Springer-Verlag, 2002.
		.. [2] Glantz, Stanton A. "Primer of Biostatistics.", McGraw-Hill,
		       Fifth Edition, 2002.
		.. [3] Lentner, Marvin, "Elementary Applied Statistics", Bogden
		       and Quigley, 1972.
		.. [4] Weisstein, Eric W. "Binomial Distribution." From MathWorld--A
		       Wolfram Web Resource.
		       http://mathworld.wolfram.com/BinomialDistribution.html
		.. [5] Wikipedia, "Binomial distribution",
		       https://en.wikipedia.org/wiki/Binomial_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> n, p = 10, .5  # number of trials, probability of each trial
		>>> s = np.random.binomial(n, p, 1000)
		# result of flipping a coin 10 times, tested 1000 times.
		
		A real world example. A company drills 9 wild-cat oil exploration
		wells, each with an estimated probability of success of 0.1. All nine
		wells fail. What is the probability of that happening?
		
		Let's do 20,000 trials of the model, and count the number that
		generate zero positive results.
		
		>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
		# answer = 0.38885, or 38%.
	**/
	static public function binomial(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the bit-wise AND of two arrays element-wise.
		
		Computes the bit-wise AND of the underlying binary representation of
		the integers in the input arrays. This ufunc implements the C/Python
		operator ``&``.
		
		Parameters
		----------
		x1, x2 : array_like
		    Only integer and boolean types are handled.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Result.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_and
		bitwise_or
		bitwise_xor
		binary_repr :
		    Return the binary representation of the input number as a string.
		
		Examples
		--------
		The number 13 is represented by ``00001101``.  Likewise, 17 is
		represented by ``00010001``.  The bit-wise AND of 13 and 17 is
		therefore ``000000001``, or 1:
		
		>>> np.bitwise_and(13, 17)
		1
		
		>>> np.bitwise_and(14, 13)
		12
		>>> np.binary_repr(12)
		'1100'
		>>> np.bitwise_and([14,3], 13)
		array([12,  1])
		
		>>> np.bitwise_and([11,7], [4,25])
		array([0, 1])
		>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
		array([ 2,  4, 16])
		>>> np.bitwise_and([True, True], [False, True])
		array([False,  True])
	**/
	static public function bitwise_and(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute bit-wise inversion, or bit-wise NOT, element-wise.
		
		Computes the bit-wise NOT of the underlying binary representation of
		the integers in the input arrays. This ufunc implements the C/Python
		operator ``~``.
		
		For signed integer inputs, the two's complement is returned.  In a
		two's-complement system negative numbers are represented by the two's
		complement of the absolute value. This is the most common method of
		representing signed integers on computers [1]_. A N-bit
		two's-complement system can represent every integer in the range
		:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
		
		Parameters
		----------
		x : array_like
		    Only integer and boolean types are handled.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Result.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		bitwise_and, bitwise_or, bitwise_xor
		logical_not
		binary_repr :
		    Return the binary representation of the input number as a string.
		
		Notes
		-----
		`bitwise_not` is an alias for `invert`:
		
		>>> np.bitwise_not is np.invert
		True
		
		References
		----------
		.. [1] Wikipedia, "Two's complement",
		    https://en.wikipedia.org/wiki/Two's_complement
		
		Examples
		--------
		We've seen that 13 is represented by ``00001101``.
		The invert or bit-wise NOT of 13 is then:
		
		>>> np.invert(np.array([13], dtype=uint8))
		array([242], dtype=uint8)
		>>> np.binary_repr(x, width=8)
		'00001101'
		>>> np.binary_repr(242, width=8)
		'11110010'
		
		The result depends on the bit-width:
		
		>>> np.invert(np.array([13], dtype=uint16))
		array([65522], dtype=uint16)
		>>> np.binary_repr(x, width=16)
		'0000000000001101'
		>>> np.binary_repr(65522, width=16)
		'1111111111110010'
		
		When using signed integer types the result is the two's complement of
		the result for the unsigned type:
		
		>>> np.invert(np.array([13], dtype=int8))
		array([-14], dtype=int8)
		>>> np.binary_repr(-14, width=8)
		'11110010'
		
		Booleans are accepted as well:
		
		>>> np.invert(array([True, False]))
		array([False,  True])
	**/
	static public function bitwise_not(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the bit-wise OR of two arrays element-wise.
		
		Computes the bit-wise OR of the underlying binary representation of
		the integers in the input arrays. This ufunc implements the C/Python
		operator ``|``.
		
		Parameters
		----------
		x1, x2 : array_like
		    Only integer and boolean types are handled.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Result.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_or
		bitwise_and
		bitwise_xor
		binary_repr :
		    Return the binary representation of the input number as a string.
		
		Examples
		--------
		The number 13 has the binaray representation ``00001101``. Likewise,
		16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is
		then ``000111011``, or 29:
		
		>>> np.bitwise_or(13, 16)
		29
		>>> np.binary_repr(29)
		'11101'
		
		>>> np.bitwise_or(32, 2)
		34
		>>> np.bitwise_or([33, 4], 1)
		array([33,  5])
		>>> np.bitwise_or([33, 4], [1, 2])
		array([33,  6])
		
		>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
		array([  6,   5, 255])
		>>> np.array([2, 5, 255]) | np.array([4, 4, 4])
		array([  6,   5, 255])
		>>> np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),
		...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))
		array([         6,          5,        255, 2147483647])
		>>> np.bitwise_or([True, True], [False, True])
		array([ True,  True])
	**/
	static public function bitwise_or(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the bit-wise XOR of two arrays element-wise.
		
		Computes the bit-wise XOR of the underlying binary representation of
		the integers in the input arrays. This ufunc implements the C/Python
		operator ``^``.
		
		Parameters
		----------
		x1, x2 : array_like
		    Only integer and boolean types are handled.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Result.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_xor
		bitwise_and
		bitwise_or
		binary_repr :
		    Return the binary representation of the input number as a string.
		
		Examples
		--------
		The number 13 is represented by ``00001101``. Likewise, 17 is
		represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
		therefore ``00011100``, or 28:
		
		>>> np.bitwise_xor(13, 17)
		28
		>>> np.binary_repr(28)
		'11100'
		
		>>> np.bitwise_xor(31, 5)
		26
		>>> np.bitwise_xor([31,3], 5)
		array([26,  6])
		
		>>> np.bitwise_xor([31,3], [5,6])
		array([26,  5])
		>>> np.bitwise_xor([True, True], [False, True])
		array([ True, False])
	**/
	static public function bitwise_xor(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the Blackman window.
		
		The Blackman window is a taper formed by using the first three
		terms of a summation of cosines. It was designed to have close to the
		minimal leakage possible.  It is close to optimal, only slightly worse
		than a Kaiser window.
		
		Parameters
		----------
		M : int
		    Number of points in the output window. If zero or less, an empty
		    array is returned.
		
		Returns
		-------
		out : ndarray
		    The window, with the maximum value normalized to one (the value one
		    appears only if the number of samples is odd).
		
		See Also
		--------
		bartlett, hamming, hanning, kaiser
		
		Notes
		-----
		The Blackman window is defined as
		
		.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)
		
		Most references to the Blackman window come from the signal processing
		literature, where it is used as one of many windowing functions for
		smoothing values.  It is also known as an apodization (which means
		"removing the foot", i.e. smoothing discontinuities at the beginning
		and end of the sampled signal) or tapering function. It is known as a
		"near optimal" tapering function, almost as good (by some measures)
		as the kaiser window.
		
		References
		----------
		Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
		Dover Publications, New York.
		
		Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
		Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
		
		Examples
		--------
		>>> import matplotlib.pyplot as plt
		>>> np.blackman(12)
		array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,
		         4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
		         9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
		         1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])
		
		
		Plot the window and the frequency response:
		
		>>> from numpy.fft import fft, fftshift
		>>> window = np.blackman(51)
		>>> plt.plot(window)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Blackman window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Sample")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		>>> plt.figure()
		<matplotlib.figure.Figure object at 0x...>
		>>> A = fft(window, 2048) / 25.5
		>>> mag = np.abs(fftshift(A))
		>>> freq = np.linspace(-0.5, 0.5, len(A))
		>>> response = 20 * np.log10(mag)
		>>> response = np.clip(response, -100, 100)
		>>> plt.plot(freq, response)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Frequency response of Blackman window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Magnitude [dB]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Normalized frequency [cycles per sample]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.axis('tight')
		(-0.5, 0.5, -100.0, ...)
		>>> plt.show()
	**/
	static public function blackman(M:Dynamic):Dynamic;
	/**
		Assemble an nd-array from nested lists of blocks.
		
		Blocks in the innermost lists are concatenated (see `concatenate`) along
		the last dimension (-1), then these are concatenated along the
		second-last dimension (-2), and so on until the outermost list is reached.
		
		Blocks can be of any dimension, but will not be broadcasted using the normal
		rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``
		the same for all blocks. This is primarily useful for working with scalars,
		and means that code like ``np.block([v, 1])`` is valid, where
		``v.ndim == 1``.
		
		When the nested list is two levels deep, this allows block matrices to be
		constructed from their components.
		
		.. versionadded:: 1.13.0
		
		Parameters
		----------
		arrays : nested list of array_like or scalars (but not tuples)
		    If passed a single ndarray or scalar (a nested list of depth 0), this
		    is returned unmodified (and not copied).
		
		    Elements shapes must match along the appropriate axes (without
		    broadcasting), but leading 1s will be prepended to the shape as
		    necessary to make the dimensions match.
		
		Returns
		-------
		block_array : ndarray
		    The array assembled from the given blocks.
		
		    The dimensionality of the output is equal to the greatest of:
		    * the dimensionality of all the inputs
		    * the depth to which the input list is nested
		
		Raises
		------
		ValueError
		    * If list depths are mismatched - for instance, ``[[a, b], c]`` is
		      illegal, and should be spelt ``[[a, b], [c]]``
		    * If lists are empty - for instance, ``[[a, b], []]``
		
		See Also
		--------
		concatenate : Join a sequence of arrays together.
		stack : Stack arrays in sequence along a new dimension.
		hstack : Stack arrays in sequence horizontally (column wise).
		vstack : Stack arrays in sequence vertically (row wise).
		dstack : Stack arrays in sequence depth wise (along third dimension).
		vsplit : Split array into a list of multiple sub-arrays vertically.
		
		Notes
		-----
		
		When called with only scalars, ``np.block`` is equivalent to an ndarray
		call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
		``np.array([[1, 2], [3, 4]])``.
		
		This function does not enforce that the blocks lie on a fixed grid.
		``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::
		
		    AAAbb
		    AAAbb
		    cccDD
		
		But is also allowed to produce, for some ``a, b, c, d``::
		
		    AAAbb
		    AAAbb
		    cDDDD
		
		Since concatenation happens along the last axis first, `block` is _not_
		capable of producing the following directly::
		
		    AAAbb
		    cccbb
		    cccDD
		
		Matlab's "square bracket stacking", ``[A, B, ...; p, q, ...]``, is
		equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.
		
		Examples
		--------
		The most common use of this function is to build a block matrix
		
		>>> A = np.eye(2) * 2
		>>> B = np.eye(3) * 3
		>>> np.block([
		...     [A,               np.zeros((2, 3))],
		...     [np.ones((3, 2)), B               ]
		... ])
		array([[ 2.,  0.,  0.,  0.,  0.],
		       [ 0.,  2.,  0.,  0.,  0.],
		       [ 1.,  1.,  3.,  0.,  0.],
		       [ 1.,  1.,  0.,  3.,  0.],
		       [ 1.,  1.,  0.,  0.,  3.]])
		
		With a list of depth 1, `block` can be used as `hstack`
		
		>>> np.block([1, 2, 3])              # hstack([1, 2, 3])
		array([1, 2, 3])
		
		>>> a = np.array([1, 2, 3])
		>>> b = np.array([2, 3, 4])
		>>> np.block([a, b, 10])             # hstack([a, b, 10])
		array([1, 2, 3, 2, 3, 4, 10])
		
		>>> A = np.ones((2, 2), int)
		>>> B = 2 * A
		>>> np.block([A, B])                 # hstack([A, B])
		array([[1, 1, 2, 2],
		       [1, 1, 2, 2]])
		
		With a list of depth 2, `block` can be used in place of `vstack`:
		
		>>> a = np.array([1, 2, 3])
		>>> b = np.array([2, 3, 4])
		>>> np.block([[a], [b]])             # vstack([a, b])
		array([[1, 2, 3],
		       [2, 3, 4]])
		
		>>> A = np.ones((2, 2), int)
		>>> B = 2 * A
		>>> np.block([[A], [B]])             # vstack([A, B])
		array([[1, 1],
		       [1, 1],
		       [2, 2],
		       [2, 2]])
		
		It can also be used in places of `atleast_1d` and `atleast_2d`
		
		>>> a = np.array(0)
		>>> b = np.array([1])
		>>> np.block([a])                    # atleast_1d(a)
		array([0])
		>>> np.block([b])                    # atleast_1d(b)
		array([1])
		
		>>> np.block([[a]])                  # atleast_2d(a)
		array([[0]])
		>>> np.block([[b]])                  # atleast_2d(b)
		array([[1]])
	**/
	static public function block(arrays:Dynamic):Dynamic;
	/**
		Build a matrix object from a string, nested sequence, or array.
		
		Parameters
		----------
		obj : str or array_like
		    Input data. If a string, variables in the current scope may be
		    referenced by name.
		ldict : dict, optional
		    A dictionary that replaces local operands in current frame.
		    Ignored if `obj` is not a string or `gdict` is `None`.
		gdict : dict, optional
		    A dictionary that replaces global operands in current frame.
		    Ignored if `obj` is not a string.
		
		Returns
		-------
		out : matrix
		    Returns a matrix object, which is a specialized 2-D array.
		
		See Also
		--------
		block :
		    A generalization of this function for N-d arrays, that returns normal
		    ndarrays.
		
		Examples
		--------
		>>> A = np.mat('1 1; 1 1')
		>>> B = np.mat('2 2; 2 2')
		>>> C = np.mat('3 4; 5 6')
		>>> D = np.mat('7 8; 9 0')
		
		All the following expressions construct the same block matrix:
		
		>>> np.bmat([[A, B], [C, D]])
		matrix([[1, 1, 2, 2],
		        [1, 1, 2, 2],
		        [3, 4, 7, 8],
		        [5, 6, 9, 0]])
		>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
		matrix([[1, 1, 2, 2],
		        [1, 1, 2, 2],
		        [3, 4, 7, 8],
		        [5, 6, 9, 0]])
		>>> np.bmat('A,B; C,D')
		matrix([[1, 1, 2, 2],
		        [1, 1, 2, 2],
		        [3, 4, 7, 8],
		        [5, 6, 9, 0]])
	**/
	static public function bmat(obj:Dynamic, ?ldict:Dynamic, ?gdict:Dynamic):Dynamic;
	/**
		Set the colormap to "bone".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function bone():Dynamic;
	/**
		Turn the axes box on or off on the current axes.
		
		Parameters
		----------
		on : bool or None
		    The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
		    the state.
		
		See Also
		--------
		:meth:`matplotlib.axes.Axes.set_frame_on`
		:meth:`matplotlib.axes.Axes.get_frame_on`
	**/
	static public function box(?on:Dynamic):Dynamic;
	/**
		Make a box and whisker plot.
		
		Make a box and whisker plot for each column of ``x`` or each
		vector in sequence ``x``.  The box extends from the lower to
		upper quartile values of the data, with a line at the median.
		The whiskers extend from the box to show the range of the
		data.  Flier points are those past the end of the whiskers.
		
		Parameters
		----------
		x : Array or a sequence of vectors.
		    The input data.
		
		notch : bool, optional (False)
		    If `True`, will produce a notched box plot. Otherwise, a
		    rectangular boxplot is produced. The notches represent the
		    confidence interval (CI) around the median. See the entry
		    for the ``bootstrap`` parameter for information regarding
		    how the locations of the notches are computed.
		
		    .. note::
		
		        In cases where the values of the CI are less than the
		        lower quartile or greater than the upper quartile, the
		        notches will extend beyond the box, giving it a
		        distinctive "flipped" appearance. This is expected
		        behavior and consistent with other statistical
		        visualization packages.
		
		sym : str, optional
		    The default symbol for flier points. Enter an empty string
		    ('') if you don't want to show fliers. If `None`, then the
		    fliers default to 'b+'  If you want more control use the
		    flierprops kwarg.
		
		vert : bool, optional (True)
		    If `True` (default), makes the boxes vertical. If `False`,
		    everything is drawn horizontally.
		
		whis : float, sequence, or string (default = 1.5)
		    As a float, determines the reach of the whiskers to the beyond the
		    first and third quartiles. In other words, where IQR is the
		    interquartile range (`Q3-Q1`), the upper whisker will extend to
		    last datum less than `Q3 + whis*IQR`). Similarly, the lower whisker
		    will extend to the first datum greater than `Q1 - whis*IQR`.
		    Beyond the whiskers, data
		    are considered outliers and are plotted as individual
		    points. Set this to an unreasonably high value to force the
		    whiskers to show the min and max values. Alternatively, set
		    this to an ascending sequence of percentile (e.g., [5, 95])
		    to set the whiskers at specific percentiles of the data.
		    Finally, ``whis`` can be the string ``'range'`` to force the
		    whiskers to the min and max of the data.
		
		bootstrap : int, optional
		    Specifies whether to bootstrap the confidence intervals
		    around the median for notched boxplots. If ``bootstrap`` is
		    None, no bootstrapping is performed, and notches are
		    calculated using a Gaussian-based asymptotic approximation
		    (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
		    Kendall and Stuart, 1967). Otherwise, bootstrap specifies
		    the number of times to bootstrap the median to determine its
		    95% confidence intervals. Values between 1000 and 10000 are
		    recommended.
		
		usermedians : array-like, optional
		    An array or sequence whose first dimension (or length) is
		    compatible with ``x``. This overrides the medians computed
		    by matplotlib for each element of ``usermedians`` that is not
		    `None`. When an element of ``usermedians`` is None, the median
		    will be computed by matplotlib as normal.
		
		conf_intervals : array-like, optional
		    Array or sequence whose first dimension (or length) is
		    compatible with ``x`` and whose second dimension is 2. When
		    the an element of ``conf_intervals`` is not None, the
		    notch locations computed by matplotlib are overridden
		    (provided ``notch`` is `True`). When an element of
		    ``conf_intervals`` is `None`, the notches are computed by the
		    method specified by the other kwargs (e.g., ``bootstrap``).
		
		positions : array-like, optional
		    Sets the positions of the boxes. The ticks and limits are
		    automatically set to match the positions. Defaults to
		    `range(1, N+1)` where N is the number of boxes to be drawn.
		
		widths : scalar or array-like
		    Sets the width of each box either with a scalar or a
		    sequence. The default is 0.5, or ``0.15*(distance between
		    extreme positions)``, if that is smaller.
		
		patch_artist : bool, optional (False)
		    If `False` produces boxes with the Line2D artist. Otherwise,
		    boxes and drawn with Patch artists.
		
		labels : sequence, optional
		    Labels for each dataset. Length must be compatible with
		    dimensions of ``x``.
		
		manage_ticks : bool, optional (True)
		    If True, the tick locations and labels will be adjusted to match
		    the boxplot positions.
		
		autorange : bool, optional (False)
		    When `True` and the data are distributed such that the 25th and
		    75th percentiles are equal, ``whis`` is set to ``'range'`` such
		    that the whisker ends are at the minimum and maximum of the data.
		
		meanline : bool, optional (False)
		    If `True` (and ``showmeans`` is `True`), will try to render
		    the mean as a line spanning the full width of the box
		    according to ``meanprops`` (see below). Not recommended if
		    ``shownotches`` is also True. Otherwise, means will be shown
		    as points.
		
		zorder : scalar, optional (None)
		    Sets the zorder of the boxplot.
		
		Other Parameters
		----------------
		showcaps : bool, optional (True)
		    Show the caps on the ends of whiskers.
		showbox : bool, optional (True)
		    Show the central box.
		showfliers : bool, optional (True)
		    Show the outliers beyond the caps.
		showmeans : bool, optional (False)
		    Show the arithmetic means.
		capprops : dict, optional (None)
		    Specifies the style of the caps.
		boxprops : dict, optional (None)
		    Specifies the style of the box.
		whiskerprops : dict, optional (None)
		    Specifies the style of the whiskers.
		flierprops : dict, optional (None)
		    Specifies the style of the fliers.
		medianprops : dict, optional (None)
		    Specifies the style of the median.
		meanprops : dict, optional (None)
		    Specifies the style of the mean.
		
		Returns
		-------
		result : dict
		  A dictionary mapping each component of the boxplot to a list
		  of the :class:`matplotlib.lines.Line2D` instances
		  created. That dictionary has the following keys (assuming
		  vertical boxplots):
		
		  - ``boxes``: the main body of the boxplot showing the
		    quartiles and the median's confidence intervals if
		    enabled.
		
		  - ``medians``: horizontal lines at the median of each box.
		
		  - ``whiskers``: the vertical lines extending to the most
		    extreme, non-outlier data points.
		
		  - ``caps``: the horizontal lines at the ends of the
		    whiskers.
		
		  - ``fliers``: points representing data that extend beyond
		    the whiskers (fliers).
		
		  - ``means``: points or lines representing the means.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function boxplot(x:Dynamic, ?notch:Dynamic, ?sym:Dynamic, ?vert:Dynamic, ?whis:Dynamic, ?positions:Dynamic, ?widths:Dynamic, ?patch_artist:Dynamic, ?bootstrap:Dynamic, ?usermedians:Dynamic, ?conf_intervals:Dynamic, ?meanline:Dynamic, ?showmeans:Dynamic, ?showcaps:Dynamic, ?showbox:Dynamic, ?showfliers:Dynamic, ?boxprops:Dynamic, ?labels:Dynamic, ?flierprops:Dynamic, ?medianprops:Dynamic, ?meanprops:Dynamic, ?capprops:Dynamic, ?whiskerprops:Dynamic, ?manage_ticks:Dynamic, ?autorange:Dynamic, ?zorder:Dynamic, ?data:Dynamic):python.Dict<Dynamic, Dynamic>;
	/**
		Broadcast any number of arrays against each other.
		
		Parameters
		----------
		`*args` : array_likes
		    The arrays to broadcast.
		
		subok : bool, optional
		    If True, then sub-classes will be passed-through, otherwise
		    the returned arrays will be forced to be a base-class array (default).
		
		Returns
		-------
		broadcasted : list of arrays
		    These arrays are views on the original arrays.  They are typically
		    not contiguous.  Furthermore, more than one element of a
		    broadcasted array may refer to a single memory location.  If you
		    need to write to the arrays, make copies first.
		
		Examples
		--------
		>>> x = np.array([[1,2,3]])
		>>> y = np.array([[4],[5]])
		>>> np.broadcast_arrays(x, y)
		[array([[1, 2, 3],
		       [1, 2, 3]]), array([[4, 4, 4],
		       [5, 5, 5]])]
		
		Here is a useful idiom for getting contiguous copies instead of
		non-contiguous views.
		
		>>> [np.array(a) for a in np.broadcast_arrays(x, y)]
		[array([[1, 2, 3],
		       [1, 2, 3]]), array([[4, 4, 4],
		       [5, 5, 5]])]
	**/
	static public function broadcast_arrays(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Broadcast an array to a new shape.
		
		Parameters
		----------
		array : array_like
		    The array to broadcast.
		shape : tuple
		    The shape of the desired array.
		subok : bool, optional
		    If True, then sub-classes will be passed-through, otherwise
		    the returned array will be forced to be a base-class array (default).
		
		Returns
		-------
		broadcast : array
		    A readonly view on the original array with the given shape. It is
		    typically not contiguous. Furthermore, more than one element of a
		    broadcasted array may refer to a single memory location.
		
		Raises
		------
		ValueError
		    If the array is not compatible with the new shape according to NumPy's
		    broadcasting rules.
		
		Notes
		-----
		.. versionadded:: 1.10.0
		
		Examples
		--------
		>>> x = np.array([1, 2, 3])
		>>> np.broadcast_to(x, (3, 3))
		array([[1, 2, 3],
		       [1, 2, 3],
		       [1, 2, 3]])
	**/
	static public function broadcast_to(array:Dynamic, shape:Dynamic, ?subok:Dynamic):Array<Dynamic>;
	/**
		Plot a horizontal sequence of rectangles.
		
		A rectangle is drawn for each element of *xranges*. All rectangles
		have the same vertical position and size defined by *yrange*.
		
		This is a convenience function for instantiating a
		`.BrokenBarHCollection`, adding it to the axes and autoscaling the
		view.
		
		Parameters
		----------
		xranges : sequence of tuples (*xmin*, *xwidth*)
		    The x-positions and extends of the rectangles. For each tuple
		    (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
		    *xwidth*.
		yranges : (*ymin*, *ymax*)
		    The y-position and extend for all the rectangles.
		
		Other Parameters
		----------------
		**kwargs : :class:`.BrokenBarHCollection` properties
		
		    Each *kwarg* can be either a single argument applying to all
		    rectangles, e.g.::
		
		        facecolors='black'
		
		    or a sequence of arguments over which is cycled, e.g.::
		
		        facecolors=('black', 'blue')
		
		    would create interleaving black and blue rectangles.
		
		    Supported keywords:
		
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		Returns
		-------
		collection : A :class:`~.collections.BrokenBarHCollection`
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function broken_barh(xranges:Dynamic, yrange:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)
		
		Counts the number of valid days between `begindates` and
		`enddates`, not including the day of `enddates`.
		
		If ``enddates`` specifies a date value that is earlier than the
		corresponding ``begindates`` date value, the count will be negative.
		
		.. versionadded:: 1.7.0
		
		Parameters
		----------
		begindates : array_like of datetime64[D]
		    The array of the first dates for counting.
		enddates : array_like of datetime64[D]
		    The array of the end dates for counting, which are excluded
		    from the count themselves.
		weekmask : str or array_like of bool, optional
		    A seven-element array indicating which of Monday through Sunday are
		    valid days. May be specified as a length-seven list or array, like
		    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
		    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
		    weekdays, optionally separated by white space. Valid abbreviations
		    are: Mon Tue Wed Thu Fri Sat Sun
		holidays : array_like of datetime64[D], optional
		    An array of dates to consider as invalid dates.  They may be
		    specified in any order, and NaT (not-a-time) dates are ignored.
		    This list is saved in a normalized form that is suited for
		    fast calculations of valid days.
		busdaycal : busdaycalendar, optional
		    A `busdaycalendar` object which specifies the valid days. If this
		    parameter is provided, neither weekmask nor holidays may be
		    provided.
		out : array of int, optional
		    If provided, this array is filled with the result.
		
		Returns
		-------
		out : array of int
		    An array with a shape from broadcasting ``begindates`` and ``enddates``
		    together, containing the number of valid days between
		    the begin and end dates.
		
		See Also
		--------
		busdaycalendar: An object that specifies a custom set of valid days.
		is_busday : Returns a boolean array indicating valid days.
		busday_offset : Applies an offset counted in valid days.
		
		Examples
		--------
		>>> # Number of weekdays in January 2011
		... np.busday_count('2011-01', '2011-02')
		21
		>>> # Number of weekdays in 2011
		...  np.busday_count('2011', '2012')
		260
		>>> # Number of Saturdays in 2011
		... np.busday_count('2011', '2012', weekmask='Sat')
		53
	**/
	static public function busday_count(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)
		
		First adjusts the date to fall on a valid day according to
		the ``roll`` rule, then applies offsets to the given dates
		counted in valid days.
		
		.. versionadded:: 1.7.0
		
		Parameters
		----------
		dates : array_like of datetime64[D]
		    The array of dates to process.
		offsets : array_like of int
		    The array of offsets, which is broadcast with ``dates``.
		roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
		    How to treat dates that do not fall on a valid day. The default
		    is 'raise'.
		
		      * 'raise' means to raise an exception for an invalid day.
		      * 'nat' means to return a NaT (not-a-time) for an invalid day.
		      * 'forward' and 'following' mean to take the first valid day
		        later in time.
		      * 'backward' and 'preceding' mean to take the first valid day
		        earlier in time.
		      * 'modifiedfollowing' means to take the first valid day
		        later in time unless it is across a Month boundary, in which
		        case to take the first valid day earlier in time.
		      * 'modifiedpreceding' means to take the first valid day
		        earlier in time unless it is across a Month boundary, in which
		        case to take the first valid day later in time.
		weekmask : str or array_like of bool, optional
		    A seven-element array indicating which of Monday through Sunday are
		    valid days. May be specified as a length-seven list or array, like
		    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
		    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
		    weekdays, optionally separated by white space. Valid abbreviations
		    are: Mon Tue Wed Thu Fri Sat Sun
		holidays : array_like of datetime64[D], optional
		    An array of dates to consider as invalid dates.  They may be
		    specified in any order, and NaT (not-a-time) dates are ignored.
		    This list is saved in a normalized form that is suited for
		    fast calculations of valid days.
		busdaycal : busdaycalendar, optional
		    A `busdaycalendar` object which specifies the valid days. If this
		    parameter is provided, neither weekmask nor holidays may be
		    provided.
		out : array of datetime64[D], optional
		    If provided, this array is filled with the result.
		
		Returns
		-------
		out : array of datetime64[D]
		    An array with a shape from broadcasting ``dates`` and ``offsets``
		    together, containing the dates with offsets applied.
		
		See Also
		--------
		busdaycalendar: An object that specifies a custom set of valid days.
		is_busday : Returns a boolean array indicating valid days.
		busday_count : Counts how many valid days are in a half-open date range.
		
		Examples
		--------
		>>> # First business day in October 2011 (not accounting for holidays)
		... np.busday_offset('2011-10', 0, roll='forward')
		numpy.datetime64('2011-10-03','D')
		>>> # Last business day in February 2012 (not accounting for holidays)
		... np.busday_offset('2012-03', -1, roll='forward')
		numpy.datetime64('2012-02-29','D')
		>>> # Third Wednesday in January 2011
		... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
		numpy.datetime64('2011-01-19','D')
		>>> # 2012 Mother's Day in Canada and the U.S.
		... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
		numpy.datetime64('2012-05-13','D')
		
		>>> # First business day on or after a date
		... np.busday_offset('2011-03-20', 0, roll='forward')
		numpy.datetime64('2011-03-21','D')
		>>> np.busday_offset('2011-03-22', 0, roll='forward')
		numpy.datetime64('2011-03-22','D')
		>>> # First business day after a date
		... np.busday_offset('2011-03-20', 1, roll='backward')
		numpy.datetime64('2011-03-21','D')
		>>> np.busday_offset('2011-03-22', 1, roll='backward')
		numpy.datetime64('2011-03-23','D')
	**/
	static public function busday_offset(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Returns pointers to the end-points of an array.
		
		Parameters
		----------
		a : ndarray
		    Input array. It must conform to the Python-side of the array
		    interface.
		
		Returns
		-------
		(low, high) : tuple of 2 integers
		    The first integer is the first byte of the array, the second
		    integer is just past the last byte of the array.  If `a` is not
		    contiguous it will not use every byte between the (`low`, `high`)
		    values.
		
		Examples
		--------
		>>> I = np.eye(2, dtype='f'); I.dtype
		dtype('float32')
		>>> low, high = np.byte_bounds(I)
		>>> high - low == I.size*I.itemsize
		True
		>>> I = np.eye(2, dtype='G'); I.dtype
		dtype('complex192')
		>>> low, high = np.byte_bounds(I)
		>>> high - low == I.size*I.itemsize
		True
	**/
	static public function byte_bounds(a:Dynamic):Dynamic;
	static public var c_ : Dynamic;
	/**
		can_cast(from_, to, casting='safe')
		
		Returns True if cast between data types can occur according to the
		casting rule.  If from is a scalar or array scalar, also returns
		True if the scalar value can be cast without overflow or truncation
		to an integer.
		
		Parameters
		----------
		from_ : dtype, dtype specifier, scalar, or array
		    Data type, scalar, or array to cast from.
		to : dtype or dtype specifier
		    Data type to cast to.
		casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
		    Controls what kind of data casting may occur.
		
		      * 'no' means the data types should not be cast at all.
		      * 'equiv' means only byte-order changes are allowed.
		      * 'safe' means only casts which can preserve values are allowed.
		      * 'same_kind' means only safe casts or casts within a kind,
		        like float64 to float32, are allowed.
		      * 'unsafe' means any data conversions may be done.
		
		Returns
		-------
		out : bool
		    True if cast can occur according to the casting rule.
		
		Notes
		-----
		Starting in NumPy 1.9, can_cast function now returns False in 'safe'
		casting mode for integer/float dtype and string dtype if the string dtype
		length is not long enough to store the max integer/float value converted
		to a string. Previously can_cast in 'safe' mode returned True for
		integer/float dtype and a string dtype of any length.
		
		See also
		--------
		dtype, result_type
		
		Examples
		--------
		Basic examples
		
		>>> np.can_cast(np.int32, np.int64)
		True
		>>> np.can_cast(np.float64, complex)
		True
		>>> np.can_cast(complex, float)
		False
		
		>>> np.can_cast('i8', 'f8')
		True
		>>> np.can_cast('i8', 'f4')
		False
		>>> np.can_cast('i4', 'S4')
		False
		
		Casting scalars
		
		>>> np.can_cast(100, 'i1')
		True
		>>> np.can_cast(150, 'i1')
		False
		>>> np.can_cast(150, 'u1')
		True
		
		>>> np.can_cast(3.5e100, np.float32)
		False
		>>> np.can_cast(1000.0, np.float32)
		True
		
		Array scalar checks the value, array does not
		
		>>> np.can_cast(np.array(1000.0), np.float32)
		True
		>>> np.can_cast(np.array([1000.0]), np.float32)
		False
		
		Using the casting rules
		
		>>> np.can_cast('i8', 'i8', 'no')
		True
		>>> np.can_cast('<i8', '>i8', 'no')
		False
		
		>>> np.can_cast('<i8', '>i8', 'equiv')
		True
		>>> np.can_cast('<i4', '>i8', 'equiv')
		False
		
		>>> np.can_cast('<i4', '>i8', 'safe')
		True
		>>> np.can_cast('<i8', '>i4', 'safe')
		False
		
		>>> np.can_cast('<i8', '>i4', 'same_kind')
		True
		>>> np.can_cast('<i8', '>u4', 'same_kind')
		False
		
		>>> np.can_cast('<i8', '>u4', 'unsafe')
		True
	**/
	static public function can_cast(args:haxe.extern.Rest<Dynamic>):Dynamic;
	@:native("cast")
	static public var _cast : Dynamic;
	/**
		cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the cube-root of an array, element-wise.
		
		.. versionadded:: 1.10.0
		
		Parameters
		----------
		x : array_like
		    The values whose cube-roots are required.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    An array of the same shape as `x`, containing the cube
		    cube-root of each element in `x`.
		    If `out` was provided, `y` is a reference to it.
		    This is a scalar if `x` is a scalar.
		
		
		Examples
		--------
		>>> np.cbrt([1,8,27])
		array([ 1.,  2.,  3.])
	**/
	static public function cbrt(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the ceiling of the input, element-wise.
		
		The ceil of the scalar `x` is the smallest integer `i`, such that
		`i >= x`.  It is often denoted as :math:`\lceil x \rceil`.
		
		Parameters
		----------
		x : array_like
		    Input data.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The ceiling of each element in `x`, with `float` dtype.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		floor, trunc, rint
		
		Examples
		--------
		>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
		>>> np.ceil(a)
		array([-1., -1., -0.,  1.,  2.,  2.,  2.])
	**/
	static public function ceil(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		chisquare(df, size=None)
		
		Draw samples from a chi-square distribution.
		
		When `df` independent random variables, each with standard normal
		distributions (mean 0, variance 1), are squared and summed, the
		resulting distribution is chi-square (see Notes).  This distribution
		is often used in hypothesis testing.
		
		Parameters
		----------
		df : float or array_like of floats
		     Number of degrees of freedom, should be > 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``df`` is a scalar.  Otherwise,
		    ``np.array(df).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized chi-square distribution.
		
		Raises
		------
		ValueError
		    When `df` <= 0 or when an inappropriate `size` (e.g. ``size=-1``)
		    is given.
		
		Notes
		-----
		The variable obtained by summing the squares of `df` independent,
		standard normally distributed random variables:
		
		.. math:: Q = \sum_{i=0}^{\mathtt{df}} X^2_i
		
		is chi-square distributed, denoted
		
		.. math:: Q \sim \chi^2_k.
		
		The probability density function of the chi-squared distribution is
		
		.. math:: p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
		                 x^{k/2 - 1} e^{-x/2},
		
		where :math:`\Gamma` is the gamma function,
		
		.. math:: \Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.
		
		References
		----------
		.. [1] NIST "Engineering Statistics Handbook"
		       https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm
		
		Examples
		--------
		>>> np.random.chisquare(2,4)
		array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])
	**/
	static public function chisquare(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		choice(a, size=None, replace=True, p=None)
		
		Generates a random sample from a given 1-D array
		
		        .. versionadded:: 1.7.0
		
		Parameters
		-----------
		a : 1-D array-like or int
		    If an ndarray, a random sample is generated from its elements.
		    If an int, the random sample is generated as if a were np.arange(a)
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		replace : boolean, optional
		    Whether the sample is with or without replacement
		p : 1-D array-like, optional
		    The probabilities associated with each entry in a.
		    If not given the sample assumes a uniform distribution over all
		    entries in a.
		
		Returns
		--------
		samples : single item or ndarray
		    The generated random samples
		
		Raises
		-------
		ValueError
		    If a is an int and less than zero, if a or p are not 1-dimensional,
		    if a is an array-like of size 0, if p is not a vector of
		    probabilities, if a and p have different lengths, or if
		    replace=False and the sample size is greater than the population
		    size
		
		See Also
		---------
		randint, shuffle, permutation
		
		Examples
		---------
		Generate a uniform random sample from np.arange(5) of size 3:
		
		>>> np.random.choice(5, 3)
		array([0, 3, 4])
		>>> #This is equivalent to np.random.randint(0,5,3)
		
		Generate a non-uniform random sample from np.arange(5) of size 3:
		
		>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
		array([3, 3, 0])
		
		Generate a uniform random sample from np.arange(5) of size 3 without
		replacement:
		
		>>> np.random.choice(5, 3, replace=False)
		array([3,1,0])
		>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
		
		Generate a non-uniform random sample from np.arange(5) of size
		3 without replacement:
		
		>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
		array([2, 3, 0])
		
		Any of the above can be repeated with an arbitrary array-like
		instead of just integers. For instance:
		
		>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
		>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
		array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'],
		      dtype='|S11')
	**/
	static public function choice(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Cholesky decomposition.
		
		Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
		where `L` is lower-triangular and .H is the conjugate transpose operator
		(which is the ordinary transpose if `a` is real-valued).  `a` must be
		Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is
		actually returned.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Hermitian (symmetric if all elements are real), positive-definite
		    input matrix.
		
		Returns
		-------
		L : (..., M, M) array_like
		    Upper or lower-triangular Cholesky factor of `a`.  Returns a
		    matrix object if `a` is a matrix object.
		
		Raises
		------
		LinAlgError
		   If the decomposition fails, for example, if `a` is not
		   positive-definite.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		The Cholesky decomposition is often used as a fast way of solving
		
		.. math:: A \mathbf{x} = \mathbf{b}
		
		(when `A` is both Hermitian/symmetric and positive-definite).
		
		First, we solve for :math:`\mathbf{y}` in
		
		.. math:: L \mathbf{y} = \mathbf{b},
		
		and then for :math:`\mathbf{x}` in
		
		.. math:: L.H \mathbf{x} = \mathbf{y}.
		
		Examples
		--------
		>>> A = np.array([[1,-2j],[2j,5]])
		>>> A
		array([[ 1.+0.j,  0.-2.j],
		       [ 0.+2.j,  5.+0.j]])
		>>> L = np.linalg.cholesky(A)
		>>> L
		array([[ 1.+0.j,  0.+0.j],
		       [ 0.+2.j,  1.+0.j]])
		>>> np.dot(L, L.T.conj()) # verify that L * L.H = A
		array([[ 1.+0.j,  0.-2.j],
		       [ 0.+2.j,  5.+0.j]])
		>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
		>>> np.linalg.cholesky(A) # an ndarray object is returned
		array([[ 1.+0.j,  0.+0.j],
		       [ 0.+2.j,  1.+0.j]])
		>>> # But a matrix object is returned if A is a matrix object
		>>> LA.cholesky(np.matrix(A))
		matrix([[ 1.+0.j,  0.+0.j],
		        [ 0.+2.j,  1.+0.j]])
	**/
	static public function cholesky(a:Dynamic):Dynamic;
	/**
		Construct an array from an index array and a set of arrays to choose from.
		
		First of all, if confused or uncertain, definitely look at the Examples -
		in its full generality, this function is less simple than it might
		seem from the following code description (below ndi =
		`numpy.lib.index_tricks`):
		
		``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.
		
		But this omits some subtleties.  Here is a fully general summary:
		
		Given an "index" array (`a`) of integers and a sequence of `n` arrays
		(`choices`), `a` and each choice array are first broadcast, as necessary,
		to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
		0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
		for each `i`.  Then, a new array with shape ``Ba.shape`` is created as
		follows:
		
		* if ``mode=raise`` (the default), then, first of all, each element of
		  `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that
		  `i` (in that range) is the value at the `(j0, j1, ..., jm)` position
		  in `Ba` - then the value at the same position in the new array is the
		  value in `Bchoices[i]` at that same position;
		
		* if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)
		  integer; modular arithmetic is used to map integers outside the range
		  `[0, n-1]` back into that range; and then the new array is constructed
		  as above;
		
		* if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)
		  integer; negative integers are mapped to 0; values greater than `n-1`
		  are mapped to `n-1`; and then the new array is constructed as above.
		
		Parameters
		----------
		a : int array
		    This array must contain integers in `[0, n-1]`, where `n` is the number
		    of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any
		    integers are permissible.
		choices : sequence of arrays
		    Choice arrays. `a` and all of the choices must be broadcastable to the
		    same shape.  If `choices` is itself an array (not recommended), then
		    its outermost dimension (i.e., the one corresponding to
		    ``choices.shape[0]``) is taken as defining the "sequence".
		out : array, optional
		    If provided, the result will be inserted into this array. It should
		    be of the appropriate shape and dtype.
		mode : {'raise' (default), 'wrap', 'clip'}, optional
		    Specifies how indices outside `[0, n-1]` will be treated:
		
		      * 'raise' : an exception is raised
		      * 'wrap' : value becomes value mod `n`
		      * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1
		
		Returns
		-------
		merged_array : array
		    The merged result.
		
		Raises
		------
		ValueError: shape mismatch
		    If `a` and each choice array are not all broadcastable to the same
		    shape.
		
		See Also
		--------
		ndarray.choose : equivalent method
		
		Notes
		-----
		To reduce the chance of misinterpretation, even though the following
		"abuse" is nominally supported, `choices` should neither be, nor be
		thought of as, a single array, i.e., the outermost sequence-like container
		should be either a list or a tuple.
		
		Examples
		--------
		
		>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
		...   [20, 21, 22, 23], [30, 31, 32, 33]]
		>>> np.choose([2, 3, 1, 0], choices
		... # the first element of the result will be the first element of the
		... # third (2+1) "array" in choices, namely, 20; the second element
		... # will be the second element of the fourth (3+1) choice array, i.e.,
		... # 31, etc.
		... )
		array([20, 31, 12,  3])
		>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
		array([20, 31, 12,  3])
		>>> # because there are 4 choice arrays
		>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
		array([20,  1, 12,  3])
		>>> # i.e., 0
		
		A couple examples illustrating how choose broadcasts:
		
		>>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
		>>> choices = [-10, 10]
		>>> np.choose(a, choices)
		array([[ 10, -10,  10],
		       [-10,  10, -10],
		       [ 10, -10,  10]])
		
		>>> # With thanks to Anne Archibald
		>>> a = np.array([0, 1]).reshape((2,1,1))
		>>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
		>>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
		>>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
		array([[[ 1,  1,  1,  1,  1],
		        [ 2,  2,  2,  2,  2],
		        [ 3,  3,  3,  3,  3]],
		       [[-1, -2, -3, -4, -5],
		        [-1, -2, -3, -4, -5],
		        [-1, -2, -3, -4, -5]]])
	**/
	static public function choose(a:Dynamic, choices:Dynamic, ?out:Dynamic, ?mode:Dynamic):Array<Dynamic>;
	/**
		Clear the current axes.
	**/
	static public function cla():Dynamic;
	/**
		Label a contour plot.
		
		Call signature::
		
		  clabel(cs, [levels,] **kwargs)
		
		Adds labels to line contours in *cs*, where *cs* is a
		:class:`~matplotlib.contour.ContourSet` object returned by
		``contour()``.
		
		Parameters
		----------
		cs : `.ContourSet`
		    The ContourSet to label.
		
		levels : array-like, optional
		    A list of level values, that should be labeled. The list must be
		    a subset of ``cs.levels``. If not given, all levels are labeled.
		
		fontsize : string or float, optional
		    Size in points or relative size e.g., 'smaller', 'x-large'.
		    See `.Text.set_size` for accepted string values.
		
		colors : color-spec, optional
		    The label colors:
		
		    - If *None*, the color of each label matches the color of
		      the corresponding contour.
		
		    - If one string color, e.g., *colors* = 'r' or *colors* =
		      'red', all labels will be plotted in this color.
		
		    - If a tuple of matplotlib color args (string, float, rgb, etc),
		      different labels will be plotted in different colors in the order
		      specified.
		
		inline : bool, optional
		    If ``True`` the underlying contour is removed where the label is
		    placed. Default is ``True``.
		
		inline_spacing : float, optional
		    Space in pixels to leave on each side of label when
		    placing inline. Defaults to 5.
		
		    This spacing will be exact for labels at locations where the
		    contour is straight, less so for labels on curved contours.
		
		fmt : string or dict, optional
		    A format string for the label. Default is '%1.3f'
		
		    Alternatively, this can be a dictionary matching contour
		    levels with arbitrary strings to use for each contour level
		    (i.e., fmt[level]=string), or it can be any callable, such
		    as a :class:`~matplotlib.ticker.Formatter` instance, that
		    returns a string when called with a numeric contour level.
		
		manual : bool or iterable, optional
		    If ``True``, contour labels will be placed manually using
		    mouse clicks. Click the first button near a contour to
		    add a label, click the second button (or potentially both
		    mouse buttons at once) to finish adding labels. The third
		    button can be used to remove the last label added, but
		    only if labels are not inline. Alternatively, the keyboard
		    can be used to select label locations (enter to end label
		    placement, delete or backspace act like the third mouse button,
		    and any other key will select a label location).
		
		    *manual* can also be an iterable object of x,y tuples.
		    Contour labels will be created as if mouse is clicked at each
		    x,y positions.
		
		rightside_up : bool, optional
		    If ``True``, label rotations will always be plus
		    or minus 90 degrees from level. Default is ``True``.
		
		use_clabeltext : bool, optional
		    If ``True``, `.ClabelText` class (instead of `.Text`) is used to
		    create labels. `ClabelText` recalculates rotation angles
		    of texts during the drawing time, therefore this can be used if
		    aspect of the axes changes. Default is ``False``.
		
		Returns
		-------
		labels
		    A list of `.Text` instances for the labels.
	**/
	static public function clabel(CS:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Clear the current figure.
	**/
	static public function clf():Dynamic;
	/**
		Set the color limits of the current image.
		
		If either *vmin* or *vmax* is None, the image min/max respectively
		will be used for color scaling.
		
		If you want to set the clim of multiple images, use
		`~.ScalarMappable.set_clim` on every image, for example::
		
		  for im in gca().get_images():
		      im.set_clim(0, 0.5)
	**/
	static public function clim(?vmin:Dynamic, ?vmax:Dynamic):Dynamic;
	/**
		Clip (limit) the values in an array.
		
		Given an interval, values outside the interval are clipped to
		the interval edges.  For example, if an interval of ``[0, 1]``
		is specified, values smaller than 0 become 0, and values larger
		than 1 become 1.
		
		Parameters
		----------
		a : array_like
		    Array containing elements to clip.
		a_min : scalar or array_like or `None`
		    Minimum value. If `None`, clipping is not performed on lower
		    interval edge. Not more than one of `a_min` and `a_max` may be
		    `None`.
		a_max : scalar or array_like or `None`
		    Maximum value. If `None`, clipping is not performed on upper
		    interval edge. Not more than one of `a_min` and `a_max` may be
		    `None`. If `a_min` or `a_max` are array_like, then the three
		    arrays will be broadcasted to match their shapes.
		out : ndarray, optional
		    The results will be placed in this array. It may be the input
		    array for in-place clipping.  `out` must be of the right shape
		    to hold the output.  Its type is preserved.
		
		Returns
		-------
		clipped_array : ndarray
		    An array with the elements of `a`, but where values
		    < `a_min` are replaced with `a_min`, and those > `a_max`
		    with `a_max`.
		
		See Also
		--------
		numpy.doc.ufuncs : Section "Output arguments"
		
		Examples
		--------
		>>> a = np.arange(10)
		>>> np.clip(a, 1, 8)
		array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
		>>> a
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
		>>> np.clip(a, 3, 6, out=a)
		array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
		>>> a = np.arange(10)
		>>> a
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
		>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
		array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
	**/
	static public function clip(a:Dynamic, a_min:Dynamic, a_max:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Close a figure window.
		
		Parameters
		----------
		fig : None or int or str or `.Figure`
		    The figure to close. There are a number of ways to specify this:
		
		    - *None*: the current figure
		    - `.Figure`: the given `.Figure` instance
		    - ``int``: a figure number
		    - ``str``: a figure name
		    - 'all': all figures
	**/
	static public function close(?fig:Dynamic):Dynamic;
	/**
		Plot the coherence between *x* and *y*.
		
		Plot the coherence between *x* and *y*.  Coherence is the
		normalized cross spectral density:
		
		.. math::
		
		  C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
		
		Parameters
		----------
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  This can be different from *NFFT*, which
		    specifies the number of data points used.  While not increasing
		    the actual resolution of the spectrum (the minimum distance between
		    resolvable peaks), this can give more points in the plot,
		    allowing for more detail. This corresponds to the *n* parameter
		    in the call to fft(). The default is None, which sets *pad_to*
		    equal to *NFFT*
		
		NFFT : int
		    The number of data points used in each block for the FFT.
		    A power 2 is most efficient.  The default value is 256.
		    This should *NOT* be used to get zero padding, or the scaling of the
		    result will be incorrect. Use *pad_to* for this instead.
		
		detrend : {'none', 'mean', 'linear'} or callable, default 'none'
		    The function applied to each segment before fft-ing, designed to
		    remove the mean or linear trend.  Unlike in MATLAB, where the
		    *detrend* parameter is a vector, in Matplotlib is it a function.
		    The :mod:`~matplotlib.mlab` module defines `.detrend_none`,
		    `.detrend_mean`, and `.detrend_linear`, but you can use a custom
		    function as well.  You can also use a string to choose one of the
		    functions: 'none' calls `.detrend_none`. 'mean' calls `.detrend_mean`.
		    'linear' calls `.detrend_linear`.
		
		scale_by_freq : bool, optional
		    Specifies whether the resulting density values should be scaled
		    by the scaling frequency, which gives density in units of Hz^-1.
		    This allows for integration over the returned frequency values.
		    The default is True for MATLAB compatibility.
		
		noverlap : int
		    The number of points of overlap between blocks.  The
		    default value is 0 (no overlap).
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		
		Returns
		-------
		Cxy : 1-D array
		    The coherence vector.
		
		freqs : 1-D array
		    The frequencies for the elements in *Cxy*.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		References
		----------
		Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
		John Wiley & Sons (1986)
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function cohere(x:Dynamic, y:Dynamic, ?NFFT:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?detrend:Dynamic, ?window:Dynamic, ?noverlap:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?scale_by_freq:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Add a colorbar to a plot.
		
		Function signatures for the :mod:`~matplotlib.pyplot` interface; all
		but the first are also method signatures for the
		:meth:`~matplotlib.figure.Figure.colorbar` method::
		
		  colorbar(**kwargs)
		  colorbar(mappable, **kwargs)
		  colorbar(mappable, cax=cax, **kwargs)
		  colorbar(mappable, ax=ax, **kwargs)
		
		Parameters
		----------
		mappable
		    The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.Image`,
		    `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.
		    This argument is mandatory for the `.Figure.colorbar` method but optional
		    for the `.pyplot.colorbar` function, which sets the default to the current
		    image.
		
		    Note that one can create a `ScalarMappable` "on-the-fly" to generate
		    colorbars not attached to a previously drawn artist, e.g. ::
		
		        fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
		
		cax : :class:`~matplotlib.axes.Axes` object, optional
		    Axes into which the colorbar will be drawn.
		
		ax : :class:`~matplotlib.axes.Axes`, list of Axes, optional
		    Parent axes from which space for a new colorbar axes will be stolen.
		    If a list of axes is given they will all be resized to make room for the
		    colorbar axes.
		
		use_gridspec : bool, optional
		    If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If
		    *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is
		    created as an instance of Subplot using the :mod:`~.gridspec` module.
		
		Returns
		-------
		colorbar : `~matplotlib.colorbar.Colorbar`
		    See also its base class, `~matplotlib.colorbar.ColorbarBase`.  Use
		    `~.ColorbarBase.set_label` to label the colorbar.
		
		Notes
		-----
		Additional keyword arguments are of two kinds:
		
		  axes properties:
		
		
		    ============= ====================================================
		    Property      Description
		    ============= ====================================================
		    *orientation* vertical or horizontal
		    *fraction*    0.15; fraction of original axes to use for colorbar
		    *pad*         0.05 if vertical, 0.15 if horizontal; fraction
		                  of original axes between colorbar and new image axes
		    *shrink*      1.0; fraction by which to multiply the size of the colorbar
		    *aspect*      20; ratio of long to short dimensions
		    *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;
		                  the anchor point of the colorbar axes
		    *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;
		                  the anchor point of the colorbar parent axes. If
		                  False, the parent axes' anchor will be unchanged
		    ============= ====================================================
		
		
		  colorbar properties:
		
		
		    ============  ====================================================
		    Property      Description
		    ============  ====================================================
		    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]
		                  If not 'neither', make pointed end(s) for out-of-
		                  range values.  These are set for a given colormap
		                  using the colormap set_under and set_over methods.
		    *extendfrac*  [ *None* | 'auto' | length | lengths ]
		                  If set to *None*, both the minimum and maximum
		                  triangular colorbar extensions with have a length of
		                  5% of the interior colorbar length (this is the
		                  default setting). If set to 'auto', makes the
		                  triangular colorbar extensions the same lengths as
		                  the interior boxes (when *spacing* is set to
		                  'uniform') or the same lengths as the respective
		                  adjacent interior boxes (when *spacing* is set to
		                  'proportional'). If a scalar, indicates the length
		                  of both the minimum and maximum triangular colorbar
		                  extensions as a fraction of the interior colorbar
		                  length. A two-element sequence of fractions may also
		                  be given, indicating the lengths of the minimum and
		                  maximum colorbar extensions respectively as a
		                  fraction of the interior colorbar length.
		    *extendrect*  bool
		                  If *False* the minimum and maximum colorbar extensions
		                  will be triangular (the default). If *True* the
		                  extensions will be rectangular.
		    *spacing*     [ 'uniform' | 'proportional' ]
		                  Uniform spacing gives each discrete color the same
		                  space; proportional makes the space proportional to
		                  the data interval.
		    *ticks*       [ None | list of ticks | Locator object ]
		                  If None, ticks are determined automatically from the
		                  input.
		    *format*      [ None | format string | Formatter object ]
		                  If None, the
		                  :class:`~matplotlib.ticker.ScalarFormatter` is used.
		                  If a format string is given, e.g., '%.3f', that is
		                  used. An alternative
		                  :class:`~matplotlib.ticker.Formatter` object may be
		                  given instead.
		    *drawedges*   bool
		                  Whether to draw lines at color boundaries.
		    ============  ====================================================
		
		    The following will probably be useful only in the context of
		    indexed colors (that is, when the mappable has norm=NoNorm()),
		    or other unusual circumstances.
		
		    ============   ===================================================
		    Property       Description
		    ============   ===================================================
		    *boundaries*   None or a sequence
		    *values*       None or a sequence which must be of length 1 less
		                   than the sequence of *boundaries*. For each region
		                   delimited by adjacent entries in *boundaries*, the
		                   color mapped to the corresponding value in values
		                   will be used.
		    ============   ===================================================
		
		
		
		If *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*
		kwarg is included automatically.
		
		The *shrink* kwarg provides a simple way to scale the colorbar with respect
		to the axes. Note that if *cax* is specified, it determines the size of the
		colorbar and *shrink* and *aspect* kwargs are ignored.
		
		For more precise control, you can manually specify the positions of
		the axes objects in which the mappable and the colorbar are drawn.  In
		this case, do not use any of the axes properties kwargs.
		
		It is known that some vector graphics viewers (svg and pdf) renders white gaps
		between segments of the colorbar.  This is due to bugs in the viewers, not
		Matplotlib.  As a workaround, the colorbar can be rendered with overlapping
		segments::
		
		    cbar = colorbar()
		    cbar.solids.set_edgecolor("face")
		    draw()
		
		However this has negative consequences in other circumstances, e.g. with
		semi-transparent images (alpha < 1) and colorbar extensions; therefore, this
		workaround is not used by default (see issue #1188).
	**/
	static public function colorbar(?mappable:Dynamic, ?cax:Dynamic, ?ax:Dynamic, ?kw:python.KwArgs<Dynamic>):Dynamic;
	/**
		Matplotlib provides a number of colormaps, and others can be added using
		:func:`~matplotlib.cm.register_cmap`.  This function documents the built-in
		colormaps, and will also return a list of all registered colormaps if
		called.
		
		You can set the colormap for an image, pcolor, scatter, etc,
		using a keyword argument::
		
		  imshow(X, cmap=cm.hot)
		
		or using the :func:`set_cmap` function::
		
		  imshow(X)
		  pyplot.set_cmap('hot')
		  pyplot.set_cmap('jet')
		
		In interactive mode, :func:`set_cmap` will update the colormap post-hoc,
		allowing you to see which one works best for your data.
		
		All built-in colormaps can be reversed by appending ``_r``: For instance,
		``gray_r`` is the reverse of ``gray``.
		
		There are several common color schemes used in visualization:
		
		Sequential schemes
		  for unipolar data that progresses from low to high
		Diverging schemes
		  for bipolar data that emphasizes positive or negative deviations from a
		  central value
		Cyclic schemes
		  for plotting values that wrap around at the endpoints, such as phase
		  angle, wind direction, or time of day
		Qualitative schemes
		  for nominal data that has no inherent ordering, where color is used
		  only to distinguish categories
		
		Matplotlib ships with 4 perceptually uniform color maps which are
		the recommended color maps for sequential data:
		
		  =========   ===================================================
		  Colormap    Description
		  =========   ===================================================
		  inferno     perceptually uniform shades of black-red-yellow
		  magma       perceptually uniform shades of black-red-white
		  plasma      perceptually uniform shades of blue-red-yellow
		  viridis     perceptually uniform shades of blue-green-yellow
		  =========   ===================================================
		
		The following colormaps are based on the `ColorBrewer
		<http://colorbrewer2.org>`_ color specifications and designs developed by
		Cynthia Brewer:
		
		ColorBrewer Diverging (luminance is highest at the midpoint, and
		decreases towards differently-colored endpoints):
		
		  ========  ===================================
		  Colormap  Description
		  ========  ===================================
		  BrBG      brown, white, blue-green
		  PiYG      pink, white, yellow-green
		  PRGn      purple, white, green
		  PuOr      orange, white, purple
		  RdBu      red, white, blue
		  RdGy      red, white, gray
		  RdYlBu    red, yellow, blue
		  RdYlGn    red, yellow, green
		  Spectral  red, orange, yellow, green, blue
		  ========  ===================================
		
		ColorBrewer Sequential (luminance decreases monotonically):
		
		  ========  ====================================
		  Colormap  Description
		  ========  ====================================
		  Blues     white to dark blue
		  BuGn      white, light blue, dark green
		  BuPu      white, light blue, dark purple
		  GnBu      white, light green, dark blue
		  Greens    white to dark green
		  Greys     white to black (not linear)
		  Oranges   white, orange, dark brown
		  OrRd      white, orange, dark red
		  PuBu      white, light purple, dark blue
		  PuBuGn    white, light purple, dark green
		  PuRd      white, light purple, dark red
		  Purples   white to dark purple
		  RdPu      white, pink, dark purple
		  Reds      white to dark red
		  YlGn      light yellow, dark green
		  YlGnBu    light yellow, light green, dark blue
		  YlOrBr    light yellow, orange, dark brown
		  YlOrRd    light yellow, orange, dark red
		  ========  ====================================
		
		ColorBrewer Qualitative:
		
		(For plotting nominal data, :class:`ListedColormap` is used,
		not :class:`LinearSegmentedColormap`.  Different sets of colors are
		recommended for different numbers of categories.)
		
		* Accent
		* Dark2
		* Paired
		* Pastel1
		* Pastel2
		* Set1
		* Set2
		* Set3
		
		A set of colormaps derived from those of the same name provided
		with Matlab are also included:
		
		  =========   =======================================================
		  Colormap    Description
		  =========   =======================================================
		  autumn      sequential linearly-increasing shades of red-orange-yellow
		  bone        sequential increasing black-white color map with
		              a tinge of blue, to emulate X-ray film
		  cool        linearly-decreasing shades of cyan-magenta
		  copper      sequential increasing shades of black-copper
		  flag        repetitive red-white-blue-black pattern (not cyclic at
		              endpoints)
		  gray        sequential linearly-increasing black-to-white
		              grayscale
		  hot         sequential black-red-yellow-white, to emulate blackbody
		              radiation from an object at increasing temperatures
		  jet         a spectral map with dark endpoints, blue-cyan-yellow-red;
		              based on a fluid-jet simulation by NCSA [#]_
		  pink        sequential increasing pastel black-pink-white, meant
		              for sepia tone colorization of photographs
		  prism       repetitive red-yellow-green-blue-purple-...-green pattern
		              (not cyclic at endpoints)
		  spring      linearly-increasing shades of magenta-yellow
		  summer      sequential linearly-increasing shades of green-yellow
		  winter      linearly-increasing shades of blue-green
		  =========   =======================================================
		
		A set of palettes from the `Yorick scientific visualisation
		package <https://dhmunro.github.io/yorick-doc/>`_, an evolution of
		the GIST package, both by David H. Munro are included:
		
		  ============  =======================================================
		  Colormap      Description
		  ============  =======================================================
		  gist_earth    mapmaker's colors from dark blue deep ocean to green
		                lowlands to brown highlands to white mountains
		  gist_heat     sequential increasing black-red-orange-white, to emulate
		                blackbody radiation from an iron bar as it grows hotter
		  gist_ncar     pseudo-spectral black-blue-green-yellow-red-purple-white
		                colormap from National Center for Atmospheric
		                Research [#]_
		  gist_rainbow  runs through the colors in spectral order from red to
		                violet at full saturation (like *hsv* but not cyclic)
		  gist_stern    "Stern special" color table from Interactive Data
		                Language software
		  ============  =======================================================
		
		A set of cyclic color maps:
		
		  ================  =================================================
		  Colormap          Description
		  ================  =================================================
		  hsv               red-yellow-green-cyan-blue-magenta-red, formed by
		                    changing the hue component in the HSV color space
		  twilight          perceptually uniform shades of
		                    white-blue-black-red-white
		  twilight_shifted  perceptually uniform shades of
		                    black-blue-white-red-black
		  ================  =================================================
		
		
		Other miscellaneous schemes:
		
		  ============= =======================================================
		  Colormap      Description
		  ============= =======================================================
		  afmhot        sequential black-orange-yellow-white blackbody
		                spectrum, commonly used in atomic force microscopy
		  brg           blue-red-green
		  bwr           diverging blue-white-red
		  coolwarm      diverging blue-gray-red, meant to avoid issues with 3D
		                shading, color blindness, and ordering of colors [#]_
		  CMRmap        "Default colormaps on color images often reproduce to
		                confusing grayscale images. The proposed colormap
		                maintains an aesthetically pleasing color image that
		                automatically reproduces to a monotonic grayscale with
		                discrete, quantifiable saturation levels." [#]_
		  cubehelix     Unlike most other color schemes cubehelix was designed
		                by D.A. Green to be monotonically increasing in terms
		                of perceived brightness. Also, when printed on a black
		                and white postscript printer, the scheme results in a
		                greyscale with monotonically increasing brightness.
		                This color scheme is named cubehelix because the r,g,b
		                values produced can be visualised as a squashed helix
		                around the diagonal in the r,g,b color cube.
		  gnuplot       gnuplot's traditional pm3d scheme
		                (black-blue-red-yellow)
		  gnuplot2      sequential color printable as gray
		                (black-blue-violet-yellow-white)
		  ocean         green-blue-white
		  rainbow       spectral purple-blue-green-yellow-orange-red colormap
		                with diverging luminance
		  seismic       diverging blue-white-red
		  nipy_spectral black-purple-blue-green-yellow-red-white spectrum,
		                originally from the Neuroimaging in Python project
		  terrain       mapmaker's colors, blue-green-yellow-brown-white,
		                originally from IGOR Pro
		  ============= =======================================================
		
		The following colormaps are redundant and may be removed in future
		versions.  It's recommended to use the names in the descriptions
		instead, which produce identical output:
		
		  =========  =======================================================
		  Colormap   Description
		  =========  =======================================================
		  gist_gray  identical to *gray*
		  gist_yarg  identical to *gray_r*
		  binary     identical to *gray_r*
		  =========  =======================================================
		
		.. rubric:: Footnotes
		
		.. [#] Rainbow colormaps, ``jet`` in particular, are considered a poor
		  choice for scientific visualization by many researchers: `Rainbow Color
		  Map (Still) Considered Harmful
		  <http://ieeexplore.ieee.org/document/4118486/?arnumber=4118486>`_
		
		.. [#] Resembles "BkBlAqGrYeOrReViWh200" from NCAR Command
		  Language. See `Color Table Gallery
		  <https://www.ncl.ucar.edu/Document/Graphics/color_table_gallery.shtml>`_
		
		.. [#] See `Diverging Color Maps for Scientific Visualization
		  <http://www.kennethmoreland.com/color-maps/>`_ by Kenneth Moreland.
		
		.. [#] See `A Color Map for Effective Black-and-White Rendering of
		  Color-Scale Images
		  <https://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m>`_
		  by Carey Rappaport
	**/
	static public function colormaps():Dynamic;
	/**
		Stack 1-D arrays as columns into a 2-D array.
		
		Take a sequence of 1-D arrays and stack them as columns
		to make a single 2-D array. 2-D arrays are stacked as-is,
		just like with `hstack`.  1-D arrays are turned into 2-D columns
		first.
		
		Parameters
		----------
		tup : sequence of 1-D or 2-D arrays.
		    Arrays to stack. All of them must have the same first dimension.
		
		Returns
		-------
		stacked : 2-D array
		    The array formed by stacking the given arrays.
		
		See Also
		--------
		stack, hstack, vstack, concatenate
		
		Examples
		--------
		>>> a = np.array((1,2,3))
		>>> b = np.array((2,3,4))
		>>> np.column_stack((a,b))
		array([[1, 2],
		       [2, 3],
		       [3, 4]])
	**/
	static public function column_stack(tup:Dynamic):Dynamic;
	/**
		Return a scalar type which is common to the input arrays.
		
		The return type will always be an inexact (i.e. floating point) scalar
		type, even if all the arrays are integer arrays. If one of the inputs is
		an integer array, the minimum precision type that is returned is a
		64-bit floating point dtype.
		
		All input arrays except int64 and uint64 can be safely cast to the
		returned dtype without loss of information.
		
		Parameters
		----------
		array1, array2, ... : ndarrays
		    Input arrays.
		
		Returns
		-------
		out : data type code
		    Data type code.
		
		See Also
		--------
		dtype, mintypecode
		
		Examples
		--------
		>>> np.common_type(np.arange(2, dtype=np.float32))
		<type 'numpy.float32'>
		>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))
		<type 'numpy.float64'>
		>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
		<type 'numpy.complex128'>
	**/
	static public function common_type(?arrays:python.VarArgs<Dynamic>):Dynamic;
	/**
		compare_chararrays(a, b, cmp_op, rstrip)
		
		Performs element-wise comparison of two string arrays using the
		comparison operator specified by `cmp_op`.
		
		Parameters
		----------
		a, b : array_like
		    Arrays to be compared.
		cmp_op : {"<", "<=", "==", ">=", ">", "!="}
		    Type of comparison.
		rstrip : Boolean
		    If True, the spaces at the end of Strings are removed before the comparison.
		
		Returns
		-------
		out : ndarray
		    The output array of type Boolean with the same shape as a and b.
		
		Raises
		------
		ValueError
		    If `cmp_op` is not valid.
		TypeError
		    If at least one of `a` or `b` is a non-string array
		
		Examples
		--------
		>>> a = np.array(["a", "b", "cde"])
		>>> b = np.array(["a", "a", "dec"])
		>>> np.compare_chararrays(a, b, ">", True)
		array([False,  True, False])
	**/
	static public function compare_chararrays(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return selected slices of an array along given axis.
		
		When working along a given axis, a slice along that axis is returned in
		`output` for each index where `condition` evaluates to True. When
		working on a 1-D array, `compress` is equivalent to `extract`.
		
		Parameters
		----------
		condition : 1-D array of bools
		    Array that selects which entries to return. If len(condition)
		    is less than the size of `a` along the given axis, then output is
		    truncated to the length of the condition array.
		a : array_like
		    Array from which to extract a part.
		axis : int, optional
		    Axis along which to take slices. If None (default), work on the
		    flattened array.
		out : ndarray, optional
		    Output array.  Its type is preserved and it must be of the right
		    shape to hold the output.
		
		Returns
		-------
		compressed_array : ndarray
		    A copy of `a` without the slices along axis for which `condition`
		    is false.
		
		See Also
		--------
		take, choose, diag, diagonal, select
		ndarray.compress : Equivalent method in ndarray
		np.extract: Equivalent method when working on 1-D arrays
		numpy.doc.ufuncs : Section "Output arguments"
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, 4], [5, 6]])
		>>> a
		array([[1, 2],
		       [3, 4],
		       [5, 6]])
		>>> np.compress([0, 1], a, axis=0)
		array([[3, 4]])
		>>> np.compress([False, True, True], a, axis=0)
		array([[3, 4],
		       [5, 6]])
		>>> np.compress([False, True], a, axis=1)
		array([[2],
		       [4],
		       [6]])
		
		Working on the flattened array does not return slices along an axis but
		selects elements.
		
		>>> np.compress([False, True], a)
		array([2])
	**/
	static public function compress(condition:Dynamic, a:Dynamic, ?axis:Dynamic, ?out:Dynamic):Dynamic;
	/**
		concatenate((a1, a2, ...), axis=0, out=None)
		
		Join a sequence of arrays along an existing axis.
		
		Parameters
		----------
		a1, a2, ... : sequence of array_like
		    The arrays must have the same shape, except in the dimension
		    corresponding to `axis` (the first, by default).
		axis : int, optional
		    The axis along which the arrays will be joined.  If axis is None,
		    arrays are flattened before use.  Default is 0.
		out : ndarray, optional
		    If provided, the destination to place the result. The shape must be
		    correct, matching that of what concatenate would have returned if no
		    out argument were specified.
		
		Returns
		-------
		res : ndarray
		    The concatenated array.
		
		See Also
		--------
		ma.concatenate : Concatenate function that preserves input masks.
		array_split : Split an array into multiple sub-arrays of equal or
		              near-equal size.
		split : Split array into a list of multiple sub-arrays of equal size.
		hsplit : Split array into multiple sub-arrays horizontally (column wise)
		vsplit : Split array into multiple sub-arrays vertically (row wise)
		dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
		stack : Stack a sequence of arrays along a new axis.
		hstack : Stack arrays in sequence horizontally (column wise)
		vstack : Stack arrays in sequence vertically (row wise)
		dstack : Stack arrays in sequence depth wise (along third dimension)
		block : Assemble arrays from blocks.
		
		Notes
		-----
		When one or more of the arrays to be concatenated is a MaskedArray,
		this function will return a MaskedArray object instead of an ndarray,
		but the input masks are *not* preserved. In cases where a MaskedArray
		is expected as input, use the ma.concatenate function from the masked
		array module instead.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, 4]])
		>>> b = np.array([[5, 6]])
		>>> np.concatenate((a, b), axis=0)
		array([[1, 2],
		       [3, 4],
		       [5, 6]])
		>>> np.concatenate((a, b.T), axis=1)
		array([[1, 2, 5],
		       [3, 4, 6]])
		>>> np.concatenate((a, b), axis=None)
		array([1, 2, 3, 4, 5, 6])
		
		This function will not preserve masking of MaskedArray inputs.
		
		>>> a = np.ma.arange(3)
		>>> a[1] = np.ma.masked
		>>> b = np.arange(2, 5)
		>>> a
		masked_array(data=[0, --, 2],
		             mask=[False,  True, False],
		       fill_value=999999)
		>>> b
		array([2, 3, 4])
		>>> np.concatenate([a, b])
		masked_array(data=[0, 1, 2, 2, 3, 4],
		             mask=False,
		       fill_value=999999)
		>>> np.ma.concatenate([a, b])
		masked_array(data=[0, --, 2, 2, 3, 4],
		             mask=[False,  True, False, False, False, False],
		       fill_value=999999)
	**/
	static public function concatenate(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the condition number of a matrix.
		
		This function is capable of returning the condition number using
		one of seven different norms, depending on the value of `p` (see
		Parameters below).
		
		Parameters
		----------
		x : (..., M, N) array_like
		    The matrix whose condition number is sought.
		p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
		    Order of the norm:
		
		    =====  ============================
		    p      norm for matrices
		    =====  ============================
		    None   2-norm, computed directly using the ``SVD``
		    'fro'  Frobenius norm
		    inf    max(sum(abs(x), axis=1))
		    -inf   min(sum(abs(x), axis=1))
		    1      max(sum(abs(x), axis=0))
		    -1     min(sum(abs(x), axis=0))
		    2      2-norm (largest sing. value)
		    -2     smallest singular value
		    =====  ============================
		
		    inf means the numpy.inf object, and the Frobenius norm is
		    the root-of-sum-of-squares norm.
		
		Returns
		-------
		c : {float, inf}
		    The condition number of the matrix. May be infinite.
		
		See Also
		--------
		numpy.linalg.norm
		
		Notes
		-----
		The condition number of `x` is defined as the norm of `x` times the
		norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
		(root-of-sum-of-squares) or one of a number of other matrix norms.
		
		References
		----------
		.. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
		       Academic Press, Inc., 1980, pg. 285.
		
		Examples
		--------
		>>> from numpy import linalg as LA
		>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
		>>> a
		array([[ 1,  0, -1],
		       [ 0,  1,  0],
		       [ 1,  0,  1]])
		>>> LA.cond(a)
		1.4142135623730951
		>>> LA.cond(a, 'fro')
		3.1622776601683795
		>>> LA.cond(a, np.inf)
		2.0
		>>> LA.cond(a, -np.inf)
		1.0
		>>> LA.cond(a, 1)
		2.0
		>>> LA.cond(a, -1)
		1.0
		>>> LA.cond(a, 2)
		1.4142135623730951
		>>> LA.cond(a, -2)
		0.70710678118654746
		>>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))
		0.70710678118654746
	**/
	static public function cond(x:Dynamic, ?p:Dynamic):Dynamic;
	/**
		conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the complex conjugate, element-wise.
		
		The complex conjugate of a complex number is obtained by changing the
		sign of its imaginary part.
		
		Parameters
		----------
		x : array_like
		    Input value.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The complex conjugate of `x`, with same dtype as `y`.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> np.conjugate(1+2j)
		(1-2j)
		
		>>> x = np.eye(2) + 1j * np.eye(2)
		>>> np.conjugate(x)
		array([[ 1.-1.j,  0.-0.j],
		       [ 0.-0.j,  1.-1.j]])
	**/
	static public function conj(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the complex conjugate, element-wise.
		
		The complex conjugate of a complex number is obtained by changing the
		sign of its imaginary part.
		
		Parameters
		----------
		x : array_like
		    Input value.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The complex conjugate of `x`, with same dtype as `y`.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> np.conjugate(1+2j)
		(1-2j)
		
		>>> x = np.eye(2) + 1j * np.eye(2)
		>>> np.conjugate(x)
		array([[ 1.-1.j,  0.-0.j],
		       [ 0.-0.j,  1.-1.j]])
	**/
	static public function conjugate(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Connect event with string *s* to *func*.  The signature of *func* is::
		
		  def func(event)
		
		where event is a :class:`matplotlib.backend_bases.Event`.  The
		following events are recognized
		
		- 'button_press_event'
		- 'button_release_event'
		- 'draw_event'
		- 'key_press_event'
		- 'key_release_event'
		- 'motion_notify_event'
		- 'pick_event'
		- 'resize_event'
		- 'scroll_event'
		- 'figure_enter_event',
		- 'figure_leave_event',
		- 'axes_enter_event',
		- 'axes_leave_event'
		- 'close_event'
		
		For the location events (button and key press/release), if the
		mouse is over the axes, the variable ``event.inaxes`` will be
		set to the :class:`~matplotlib.axes.Axes` the event occurs is
		over, and additionally, the variables ``event.xdata`` and
		``event.ydata`` will be defined.  This is the mouse location
		in data coords.  See
		:class:`~matplotlib.backend_bases.KeyEvent` and
		:class:`~matplotlib.backend_bases.MouseEvent` for more info.
		
		Return value is a connection id that can be used with
		:meth:`~matplotlib.backend_bases.Event.mpl_disconnect`.
		
		Examples
		--------
		Usage::
		
		    def on_press(event):
		        print('you pressed', event.button, event.xdata, event.ydata)
		
		    cid = canvas.mpl_connect('button_press_event', on_press)
	**/
	static public function connect(s:Dynamic, func:Dynamic):Dynamic;
	/**
		Plot contours.
		
		Call signature::
		
		    contour([X, Y,] Z, [levels], **kwargs)
		
		`.contour` and `.contourf` draw contour lines and filled contours,
		respectively.  Except as noted, function signatures and return values
		are the same for both versions.
		
		Parameters
		----------
		X, Y : array-like, optional
		    The coordinates of the values in *Z*.
		
		    *X* and *Y* must both be 2-D with the same shape as *Z* (e.g.
		    created via `numpy.meshgrid`), or they must both be 1-D such
		    that ``len(X) == M`` is the number of columns in *Z* and
		    ``len(Y) == N`` is the number of rows in *Z*.
		
		    If not given, they are assumed to be integer indices, i.e.
		    ``X = range(M)``, ``Y = range(N)``.
		
		Z : array-like(N, M)
		    The height values over which the contour is drawn.
		
		levels : int or array-like, optional
		    Determines the number and positions of the contour lines / regions.
		
		    If an int *n*, use *n* data intervals; i.e. draw *n+1* contour
		    lines. The level heights are automatically chosen.
		
		    If array-like, draw contour lines at the specified levels.
		    The values must be in increasing order.
		
		Returns
		-------
		c : `~.contour.QuadContourSet`
		
		Other Parameters
		----------------
		corner_mask : bool, optional
		    Enable/disable corner masking, which only has an effect if *Z* is
		    a masked array.  If ``False``, any quad touching a masked point is
		    masked out.  If ``True``, only the triangular corners of quads
		    nearest those points are always masked out, other triangular
		    corners comprising three unmasked points are contoured as usual.
		
		    Defaults to :rc:`contour.corner_mask`, which defaults to ``True``.
		
		colors : color string or sequence of colors, optional
		    The colors of the levels, i.e. the lines for `.contour` and the
		    areas for `.contourf`.
		
		    The sequence is cycled for the levels in ascending order. If the
		    sequence is shorter than the number of levels, it's repeated.
		
		    As a shortcut, single color strings may be used in place of
		    one-element lists, i.e. ``'red'`` instead of ``['red']`` to color
		    all levels with the same color. This shortcut does only work for
		    color strings, not for other ways of specifying colors.
		
		    By default (value *None*), the colormap specified by *cmap*
		    will be used.
		
		alpha : float, optional
		    The alpha blending value, between 0 (transparent) and 1 (opaque).
		
		cmap : str or `.Colormap`, optional
		    A `.Colormap` instance or registered colormap name. The colormap
		    maps the level values to colors.
		    Defaults to :rc:`image.cmap`.
		
		    If given, *colors* take precedence over *cmap*.
		
		norm : `~matplotlib.colors.Normalize`, optional
		    If a colormap is used, the `.Normalize` instance scales the level
		    values to the canonical colormap range [0, 1] for mapping to
		    colors. If not given, the default linear scaling is used.
		
		vmin, vmax : float, optional
		    If not *None*, either or both of these values will be supplied to
		    the `.Normalize` instance, overriding the default color scaling
		    based on *levels*.
		
		origin : {*None*, 'upper', 'lower', 'image'}, optional
		    Determines the orientation and exact position of *Z* by specifying
		    the position of ``Z[0, 0]``.  This is only relevant, if *X*, *Y*
		    are not given.
		
		    - *None*: ``Z[0, 0]`` is at X=0, Y=0 in the lower left corner.
		    - 'lower': ``Z[0, 0]`` is at X=0.5, Y=0.5 in the lower left corner.
		    - 'upper': ``Z[0, 0]`` is at X=N+0.5, Y=0.5 in the upper left
		      corner.
		    - 'image': Use the value from :rc:`image.origin`.
		
		extent : (x0, x1, y0, y1), optional
		    If *origin* is not *None*, then *extent* is interpreted as in
		    `.imshow`: it gives the outer pixel boundaries. In this case, the
		    position of Z[0,0] is the center of the pixel, not a corner. If
		    *origin* is *None*, then (*x0*, *y0*) is the position of Z[0,0],
		    and (*x1*, *y1*) is the position of Z[-1,-1].
		
		    This argument is ignored if *X* and *Y* are specified in the call
		    to contour.
		
		locator : ticker.Locator subclass, optional
		    The locator is used to determine the contour levels if they
		    are not given explicitly via *levels*.
		    Defaults to `~.ticker.MaxNLocator`.
		
		extend : {'neither', 'both', 'min', 'max'}, optional, default: 'neither'
		    Determines the ``contourf``-coloring of values that are outside the
		    *levels* range.
		
		    If 'neither', values outside the *levels* range are not colored.
		    If 'min', 'max' or 'both', color the values below, above or below
		    and above the *levels* range.
		
		    Values below ``min(levels)`` and above ``max(levels)`` are mapped
		    to the under/over values of the `.Colormap`. Note, that most
		    colormaps do not have dedicated colors for these by default, so
		    that the over and under values are the edge values of the colormap.
		    You may want to set these values explicitly using
		    `.Colormap.set_under` and `.Colormap.set_over`.
		
		    .. note::
		
		        An exising `.QuadContourSet` does not get notified if
		        properties of its colormap are changed. Therefore, an explicit
		        call `.QuadContourSet.changed()` is needed after modifying the
		        colormap. The explicit call can be left out, if a colorbar is
		        assigned to the `.QuadContourSet` because it internally calls
		        `.QuadContourSet.changed()`.
		
		    Example::
		
		        x = np.arange(1, 10)
		        y = x.reshape(-1, 1)
		        h = x * y
		
		        cs = plt.contourf(h, levels=[10, 30, 50],
		            colors=['#808080', '#A0A0A0', '#C0C0C0'], extend='both')
		        cs.cmap.set_over('red')
		        cs.cmap.set_under('blue')
		        cs.changed()
		
		xunits, yunits : registered units, optional
		    Override axis units by specifying an instance of a
		    :class:`matplotlib.units.ConversionInterface`.
		
		antialiased : bool, optional
		    Enable antialiasing, overriding the defaults.  For
		    filled contours, the default is *True*.  For line contours,
		    it is taken from :rc:`lines.antialiased`.
		
		Nchunk : int >= 0, optional
		    If 0, no subdivision of the domain.  Specify a positive integer to
		    divide the domain into subdomains of *nchunk* by *nchunk* quads.
		    Chunking reduces the maximum length of polygons generated by the
		    contouring algorithm which reduces the rendering workload passed
		    on to the backend and also requires slightly less RAM.  It can
		    however introduce rendering artifacts at chunk boundaries depending
		    on the backend, the *antialiased* flag and value of *alpha*.
		
		linewidths : float or sequence of float, optional
		    *Only applies to* `.contour`.
		
		    The line width of the contour lines.
		
		    If a number, all levels will be plotted with this linewidth.
		
		    If a sequence, the levels in ascending order will be plotted with
		    the linewidths in the order specified.
		
		    Defaults to :rc:`lines.linewidth`.
		
		linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional
		    *Only applies to* `.contour`.
		
		    If *linestyles* is *None*, the default is 'solid' unless the lines
		    are monochrome.  In that case, negative contours will take their
		    linestyle from :rc:`contour.negative_linestyle` setting.
		
		    *linestyles* can also be an iterable of the above strings
		    specifying a set of linestyles to be used. If this
		    iterable is shorter than the number of contour levels
		    it will be repeated as necessary.
		
		hatches : List[str], optional
		    *Only applies to* `.contourf`.
		
		    A list of cross hatch patterns to use on the filled areas.
		    If None, no hatching will be added to the contour.
		    Hatching is supported in the PostScript, PDF, SVG and Agg
		    backends only.
		
		Notes
		-----
		1. `.contourf` differs from the MATLAB version in that it does not draw
		   the polygon edges. To draw edges, add line contours with calls to
		   `.contour`.
		
		2. `.contourf` fills intervals that are closed at the top; that is, for
		   boundaries *z1* and *z2*, the filled region is::
		
		      z1 < Z <= z2
		
		   except for the lowest interval, which is closed on both sides (i.e.
		   it includes the lowest value).
	**/
	static public function contour(?args:python.VarArgs<Dynamic>, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Plot contours.
		
		Call signature::
		
		    contour([X, Y,] Z, [levels], **kwargs)
		
		`.contour` and `.contourf` draw contour lines and filled contours,
		respectively.  Except as noted, function signatures and return values
		are the same for both versions.
		
		Parameters
		----------
		X, Y : array-like, optional
		    The coordinates of the values in *Z*.
		
		    *X* and *Y* must both be 2-D with the same shape as *Z* (e.g.
		    created via `numpy.meshgrid`), or they must both be 1-D such
		    that ``len(X) == M`` is the number of columns in *Z* and
		    ``len(Y) == N`` is the number of rows in *Z*.
		
		    If not given, they are assumed to be integer indices, i.e.
		    ``X = range(M)``, ``Y = range(N)``.
		
		Z : array-like(N, M)
		    The height values over which the contour is drawn.
		
		levels : int or array-like, optional
		    Determines the number and positions of the contour lines / regions.
		
		    If an int *n*, use *n* data intervals; i.e. draw *n+1* contour
		    lines. The level heights are automatically chosen.
		
		    If array-like, draw contour lines at the specified levels.
		    The values must be in increasing order.
		
		Returns
		-------
		c : `~.contour.QuadContourSet`
		
		Other Parameters
		----------------
		corner_mask : bool, optional
		    Enable/disable corner masking, which only has an effect if *Z* is
		    a masked array.  If ``False``, any quad touching a masked point is
		    masked out.  If ``True``, only the triangular corners of quads
		    nearest those points are always masked out, other triangular
		    corners comprising three unmasked points are contoured as usual.
		
		    Defaults to :rc:`contour.corner_mask`, which defaults to ``True``.
		
		colors : color string or sequence of colors, optional
		    The colors of the levels, i.e. the lines for `.contour` and the
		    areas for `.contourf`.
		
		    The sequence is cycled for the levels in ascending order. If the
		    sequence is shorter than the number of levels, it's repeated.
		
		    As a shortcut, single color strings may be used in place of
		    one-element lists, i.e. ``'red'`` instead of ``['red']`` to color
		    all levels with the same color. This shortcut does only work for
		    color strings, not for other ways of specifying colors.
		
		    By default (value *None*), the colormap specified by *cmap*
		    will be used.
		
		alpha : float, optional
		    The alpha blending value, between 0 (transparent) and 1 (opaque).
		
		cmap : str or `.Colormap`, optional
		    A `.Colormap` instance or registered colormap name. The colormap
		    maps the level values to colors.
		    Defaults to :rc:`image.cmap`.
		
		    If given, *colors* take precedence over *cmap*.
		
		norm : `~matplotlib.colors.Normalize`, optional
		    If a colormap is used, the `.Normalize` instance scales the level
		    values to the canonical colormap range [0, 1] for mapping to
		    colors. If not given, the default linear scaling is used.
		
		vmin, vmax : float, optional
		    If not *None*, either or both of these values will be supplied to
		    the `.Normalize` instance, overriding the default color scaling
		    based on *levels*.
		
		origin : {*None*, 'upper', 'lower', 'image'}, optional
		    Determines the orientation and exact position of *Z* by specifying
		    the position of ``Z[0, 0]``.  This is only relevant, if *X*, *Y*
		    are not given.
		
		    - *None*: ``Z[0, 0]`` is at X=0, Y=0 in the lower left corner.
		    - 'lower': ``Z[0, 0]`` is at X=0.5, Y=0.5 in the lower left corner.
		    - 'upper': ``Z[0, 0]`` is at X=N+0.5, Y=0.5 in the upper left
		      corner.
		    - 'image': Use the value from :rc:`image.origin`.
		
		extent : (x0, x1, y0, y1), optional
		    If *origin* is not *None*, then *extent* is interpreted as in
		    `.imshow`: it gives the outer pixel boundaries. In this case, the
		    position of Z[0,0] is the center of the pixel, not a corner. If
		    *origin* is *None*, then (*x0*, *y0*) is the position of Z[0,0],
		    and (*x1*, *y1*) is the position of Z[-1,-1].
		
		    This argument is ignored if *X* and *Y* are specified in the call
		    to contour.
		
		locator : ticker.Locator subclass, optional
		    The locator is used to determine the contour levels if they
		    are not given explicitly via *levels*.
		    Defaults to `~.ticker.MaxNLocator`.
		
		extend : {'neither', 'both', 'min', 'max'}, optional, default: 'neither'
		    Determines the ``contourf``-coloring of values that are outside the
		    *levels* range.
		
		    If 'neither', values outside the *levels* range are not colored.
		    If 'min', 'max' or 'both', color the values below, above or below
		    and above the *levels* range.
		
		    Values below ``min(levels)`` and above ``max(levels)`` are mapped
		    to the under/over values of the `.Colormap`. Note, that most
		    colormaps do not have dedicated colors for these by default, so
		    that the over and under values are the edge values of the colormap.
		    You may want to set these values explicitly using
		    `.Colormap.set_under` and `.Colormap.set_over`.
		
		    .. note::
		
		        An exising `.QuadContourSet` does not get notified if
		        properties of its colormap are changed. Therefore, an explicit
		        call `.QuadContourSet.changed()` is needed after modifying the
		        colormap. The explicit call can be left out, if a colorbar is
		        assigned to the `.QuadContourSet` because it internally calls
		        `.QuadContourSet.changed()`.
		
		    Example::
		
		        x = np.arange(1, 10)
		        y = x.reshape(-1, 1)
		        h = x * y
		
		        cs = plt.contourf(h, levels=[10, 30, 50],
		            colors=['#808080', '#A0A0A0', '#C0C0C0'], extend='both')
		        cs.cmap.set_over('red')
		        cs.cmap.set_under('blue')
		        cs.changed()
		
		xunits, yunits : registered units, optional
		    Override axis units by specifying an instance of a
		    :class:`matplotlib.units.ConversionInterface`.
		
		antialiased : bool, optional
		    Enable antialiasing, overriding the defaults.  For
		    filled contours, the default is *True*.  For line contours,
		    it is taken from :rc:`lines.antialiased`.
		
		Nchunk : int >= 0, optional
		    If 0, no subdivision of the domain.  Specify a positive integer to
		    divide the domain into subdomains of *nchunk* by *nchunk* quads.
		    Chunking reduces the maximum length of polygons generated by the
		    contouring algorithm which reduces the rendering workload passed
		    on to the backend and also requires slightly less RAM.  It can
		    however introduce rendering artifacts at chunk boundaries depending
		    on the backend, the *antialiased* flag and value of *alpha*.
		
		linewidths : float or sequence of float, optional
		    *Only applies to* `.contour`.
		
		    The line width of the contour lines.
		
		    If a number, all levels will be plotted with this linewidth.
		
		    If a sequence, the levels in ascending order will be plotted with
		    the linewidths in the order specified.
		
		    Defaults to :rc:`lines.linewidth`.
		
		linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional
		    *Only applies to* `.contour`.
		
		    If *linestyles* is *None*, the default is 'solid' unless the lines
		    are monochrome.  In that case, negative contours will take their
		    linestyle from :rc:`contour.negative_linestyle` setting.
		
		    *linestyles* can also be an iterable of the above strings
		    specifying a set of linestyles to be used. If this
		    iterable is shorter than the number of contour levels
		    it will be repeated as necessary.
		
		hatches : List[str], optional
		    *Only applies to* `.contourf`.
		
		    A list of cross hatch patterns to use on the filled areas.
		    If None, no hatching will be added to the contour.
		    Hatching is supported in the PostScript, PDF, SVG and Agg
		    backends only.
		
		Notes
		-----
		1. `.contourf` differs from the MATLAB version in that it does not draw
		   the polygon edges. To draw edges, add line contours with calls to
		   `.contour`.
		
		2. `.contourf` fills intervals that are closed at the top; that is, for
		   boundaries *z1* and *z2*, the filled region is::
		
		      z1 < Z <= z2
		
		   except for the lowest interval, which is closed on both sides (i.e.
		   it includes the lowest value).
	**/
	static public function contourf(?args:python.VarArgs<Dynamic>, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Returns the discrete, linear convolution of two one-dimensional sequences.
		
		The convolution operator is often seen in signal processing, where it
		models the effect of a linear time-invariant system on a signal [1]_.  In
		probability theory, the sum of two independent random variables is
		distributed according to the convolution of their individual
		distributions.
		
		If `v` is longer than `a`, the arrays are swapped before computation.
		
		Parameters
		----------
		a : (N,) array_like
		    First one-dimensional input array.
		v : (M,) array_like
		    Second one-dimensional input array.
		mode : {'full', 'valid', 'same'}, optional
		    'full':
		      By default, mode is 'full'.  This returns the convolution
		      at each point of overlap, with an output shape of (N+M-1,). At
		      the end-points of the convolution, the signals do not overlap
		      completely, and boundary effects may be seen.
		
		    'same':
		      Mode 'same' returns output of length ``max(M, N)``.  Boundary
		      effects are still visible.
		
		    'valid':
		      Mode 'valid' returns output of length
		      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
		      for points where the signals overlap completely.  Values outside
		      the signal boundary have no effect.
		
		Returns
		-------
		out : ndarray
		    Discrete, linear convolution of `a` and `v`.
		
		See Also
		--------
		scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
		                           Transform.
		scipy.linalg.toeplitz : Used to construct the convolution operator.
		polymul : Polynomial multiplication. Same output as convolve, but also
		          accepts poly1d objects as input.
		
		Notes
		-----
		The discrete convolution operation is defined as
		
		.. math:: (a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]
		
		It can be shown that a convolution :math:`x(t) * y(t)` in time/space
		is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
		domain, after appropriate padding (padding is necessary to prevent
		circular convolution).  Since multiplication is more efficient (faster)
		than convolution, the function `scipy.signal.fftconvolve` exploits the
		FFT to calculate the convolution of large data-sets.
		
		References
		----------
		.. [1] Wikipedia, "Convolution",
		    https://en.wikipedia.org/wiki/Convolution
		
		Examples
		--------
		Note how the convolution operator flips the second array
		before "sliding" the two across one another:
		
		>>> np.convolve([1, 2, 3], [0, 1, 0.5])
		array([ 0. ,  1. ,  2.5,  4. ,  1.5])
		
		Only return the middle values of the convolution.
		Contains boundary effects, where zeros are taken
		into account:
		
		>>> np.convolve([1,2,3],[0,1,0.5], 'same')
		array([ 1. ,  2.5,  4. ])
		
		The two arrays are of the same length, so there
		is only one position where they completely overlap:
		
		>>> np.convolve([1,2,3],[0,1,0.5], 'valid')
		array([ 2.5])
	**/
	static public function convolve(a:Dynamic, v:Dynamic, ?mode:Dynamic):Dynamic;
	/**
		Set the colormap to "cool".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function cool():Dynamic;
	/**
		Set the colormap to "copper".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function copper():Dynamic;
	/**
		Return an array copy of the given object.
		
		Parameters
		----------
		a : array_like
		    Input data.
		order : {'C', 'F', 'A', 'K'}, optional
		    Controls the memory layout of the copy. 'C' means C-order,
		    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
		    'C' otherwise. 'K' means match the layout of `a` as closely
		    as possible. (Note that this function and :meth:`ndarray.copy` are very
		    similar, but have different default values for their order=
		    arguments.)
		
		Returns
		-------
		arr : ndarray
		    Array interpretation of `a`.
		
		Notes
		-----
		This is equivalent to:
		
		>>> np.array(a, copy=True)  #doctest: +SKIP
		
		Examples
		--------
		Create an array x, with a reference y and a copy z:
		
		>>> x = np.array([1, 2, 3])
		>>> y = x
		>>> z = np.copy(x)
		
		Note that, when we modify x, y changes, but not z:
		
		>>> x[0] = 10
		>>> x[0] == y[0]
		True
		>>> x[0] == z[0]
		False
	**/
	static public function copy(a:Dynamic, ?order:Dynamic):Dynamic;
	/**
		copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Change the sign of x1 to that of x2, element-wise.
		
		If both arguments are arrays or sequences, they have to be of the same
		length. If `x2` is a scalar, its sign will be copied to all elements of
		`x1`.
		
		Parameters
		----------
		x1 : array_like
		    Values to change the sign of.
		x2 : array_like
		    The sign of `x2` is copied to `x1`.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    The values of `x1` with the sign of `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Examples
		--------
		>>> np.copysign(1.3, -1)
		-1.3
		>>> 1/np.copysign(0, 1)
		inf
		>>> 1/np.copysign(0, -1)
		-inf
		
		>>> np.copysign([-1, 0, 1], -1.1)
		array([-1., -0., -1.])
		>>> np.copysign([-1, 0, 1], np.arange(3)-1)
		array([-1.,  0.,  1.])
	**/
	static public function copysign(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		copyto(dst, src, casting='same_kind', where=True)
		
		Copies values from one array to another, broadcasting as necessary.
		
		Raises a TypeError if the `casting` rule is violated, and if
		`where` is provided, it selects which elements to copy.
		
		.. versionadded:: 1.7.0
		
		Parameters
		----------
		dst : ndarray
		    The array into which values are copied.
		src : array_like
		    The array from which values are copied.
		casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
		    Controls what kind of data casting may occur when copying.
		
		      * 'no' means the data types should not be cast at all.
		      * 'equiv' means only byte-order changes are allowed.
		      * 'safe' means only casts which can preserve values are allowed.
		      * 'same_kind' means only safe casts or casts within a kind,
		        like float64 to float32, are allowed.
		      * 'unsafe' means any data conversions may be done.
		where : array_like of bool, optional
		    A boolean array which is broadcasted to match the dimensions
		    of `dst`, and selects elements to copy from `src` to `dst`
		    wherever it contains the value True.
	**/
	static public function copyto(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return Pearson product-moment correlation coefficients.
		
		Please refer to the documentation for `cov` for more detail.  The
		relationship between the correlation coefficient matrix, `R`, and the
		covariance matrix, `C`, is
		
		.. math:: R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }
		
		The values of `R` are between -1 and 1, inclusive.
		
		Parameters
		----------
		x : array_like
		    A 1-D or 2-D array containing multiple variables and observations.
		    Each row of `x` represents a variable, and each column a single
		    observation of all those variables. Also see `rowvar` below.
		y : array_like, optional
		    An additional set of variables and observations. `y` has the same
		    shape as `x`.
		rowvar : bool, optional
		    If `rowvar` is True (default), then each row represents a
		    variable, with observations in the columns. Otherwise, the relationship
		    is transposed: each column represents a variable, while the rows
		    contain observations.
		bias : _NoValue, optional
		    Has no effect, do not use.
		
		    .. deprecated:: 1.10.0
		ddof : _NoValue, optional
		    Has no effect, do not use.
		
		    .. deprecated:: 1.10.0
		
		Returns
		-------
		R : ndarray
		    The correlation coefficient matrix of the variables.
		
		See Also
		--------
		cov : Covariance matrix
		
		Notes
		-----
		Due to floating point rounding the resulting array may not be Hermitian,
		the diagonal elements may not be 1, and the elements may not satisfy the
		inequality abs(a) <= 1. The real and imaginary parts are clipped to the
		interval [-1,  1] in an attempt to improve on that situation but is not
		much help in the complex case.
		
		This function accepts but discards arguments `bias` and `ddof`.  This is
		for backwards compatibility with previous versions of this function.  These
		arguments had no effect on the return values of the function and can be
		safely ignored in this and previous versions of numpy.
	**/
	static public function corrcoef(x:Dynamic, ?y:Dynamic, ?rowvar:Dynamic, ?bias:Dynamic, ?ddof:Dynamic):Dynamic;
	/**
		Cross-correlation of two 1-dimensional sequences.
		
		This function computes the correlation as generally defined in signal
		processing texts::
		
		    c_{av}[k] = sum_n a[n+k] * conj(v[n])
		
		with a and v sequences being zero-padded where necessary and conj being
		the conjugate.
		
		Parameters
		----------
		a, v : array_like
		    Input sequences.
		mode : {'valid', 'same', 'full'}, optional
		    Refer to the `convolve` docstring.  Note that the default
		    is 'valid', unlike `convolve`, which uses 'full'.
		old_behavior : bool
		    `old_behavior` was removed in NumPy 1.10. If you need the old
		    behavior, use `multiarray.correlate`.
		
		Returns
		-------
		out : ndarray
		    Discrete cross-correlation of `a` and `v`.
		
		See Also
		--------
		convolve : Discrete, linear convolution of two one-dimensional sequences.
		multiarray.correlate : Old, no conjugate, version of correlate.
		
		Notes
		-----
		The definition of correlation above is not unique and sometimes correlation
		may be defined differently. Another common definition is::
		
		    c'_{av}[k] = sum_n a[n] conj(v[n+k])
		
		which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.
		
		Examples
		--------
		>>> np.correlate([1, 2, 3], [0, 1, 0.5])
		array([ 3.5])
		>>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
		array([ 2. ,  3.5,  3. ])
		>>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
		array([ 0.5,  2. ,  3.5,  3. ,  0. ])
		
		Using complex sequences:
		
		>>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
		array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
		
		Note that you get the time reversed, complex conjugated result
		when the two input sequences change places, i.e.,
		``c_{va}[k] = c^{*}_{av}[-k]``:
		
		>>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
		array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
	**/
	static public function correlate(a:Dynamic, v:Dynamic, ?mode:Dynamic):Dynamic;
	/**
		cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Cosine element-wise.
		
		Parameters
		----------
		x : array_like
		    Input array in radians.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding cosine values.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		If `out` is provided, the function writes the result into it,
		and returns a reference to `out`.  (See Examples)
		
		References
		----------
		M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
		New York, NY: Dover, 1972.
		
		Examples
		--------
		>>> np.cos(np.array([0, np.pi/2, np.pi]))
		array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
		>>>
		>>> # Example of providing the optional output parameter
		>>> out2 = np.cos([0.1], out1)
		>>> out2 is out1
		True
		>>>
		>>> # Example of ValueError due to provision of shape mis-matched `out`
		>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
	**/
	static public function cos(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Hyperbolic cosine, element-wise.
		
		Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array of same shape as `x`.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> np.cosh(0)
		1.0
		
		The hyperbolic cosine describes the shape of a hanging cable:
		
		>>> import matplotlib.pyplot as plt
		>>> x = np.linspace(-4, 4, 1000)
		>>> plt.plot(x, np.cosh(x))
		>>> plt.show()
	**/
	static public function cosh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Counts the number of non-zero values in the array ``a``.
		
		The word "non-zero" is in reference to the Python 2.x
		built-in method ``__nonzero__()`` (renamed ``__bool__()``
		in Python 3.x) of Python objects that tests an object's
		"truthfulness". For example, any number is considered
		truthful if it is nonzero, whereas any string is considered
		truthful if it is not the empty string. Thus, this function
		(recursively) counts how many elements in ``a`` (and in
		sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
		method evaluated to ``True``.
		
		Parameters
		----------
		a : array_like
		    The array for which to count non-zeros.
		axis : int or tuple, optional
		    Axis or tuple of axes along which to count non-zeros.
		    Default is None, meaning that non-zeros will be counted
		    along a flattened version of ``a``.
		
		    .. versionadded:: 1.12.0
		
		Returns
		-------
		count : int or array of int
		    Number of non-zero values in the array along a given axis.
		    Otherwise, the total number of non-zero values in the array
		    is returned.
		
		See Also
		--------
		nonzero : Return the coordinates of all the non-zero values.
		
		Examples
		--------
		>>> np.count_nonzero(np.eye(4))
		4
		>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
		5
		>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)
		array([1, 1, 1, 1, 1])
		>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)
		array([2, 3])
	**/
	static public function count_nonzero(a:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Estimate a covariance matrix, given data and weights.
		
		Covariance indicates the level to which two variables vary together.
		If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
		then the covariance matrix element :math:`C_{ij}` is the covariance of
		:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
		of :math:`x_i`.
		
		See the notes for an outline of the algorithm.
		
		Parameters
		----------
		m : array_like
		    A 1-D or 2-D array containing multiple variables and observations.
		    Each row of `m` represents a variable, and each column a single
		    observation of all those variables. Also see `rowvar` below.
		y : array_like, optional
		    An additional set of variables and observations. `y` has the same form
		    as that of `m`.
		rowvar : bool, optional
		    If `rowvar` is True (default), then each row represents a
		    variable, with observations in the columns. Otherwise, the relationship
		    is transposed: each column represents a variable, while the rows
		    contain observations.
		bias : bool, optional
		    Default normalization (False) is by ``(N - 1)``, where ``N`` is the
		    number of observations given (unbiased estimate). If `bias` is True,
		    then normalization is by ``N``. These values can be overridden by using
		    the keyword ``ddof`` in numpy versions >= 1.5.
		ddof : int, optional
		    If not ``None`` the default value implied by `bias` is overridden.
		    Note that ``ddof=1`` will return the unbiased estimate, even if both
		    `fweights` and `aweights` are specified, and ``ddof=0`` will return
		    the simple average. See the notes for the details. The default value
		    is ``None``.
		
		    .. versionadded:: 1.5
		fweights : array_like, int, optional
		    1-D array of integer frequency weights; the number of times each
		    observation vector should be repeated.
		
		    .. versionadded:: 1.10
		aweights : array_like, optional
		    1-D array of observation vector weights. These relative weights are
		    typically large for observations considered "important" and smaller for
		    observations considered less "important". If ``ddof=0`` the array of
		    weights can be used to assign probabilities to observation vectors.
		
		    .. versionadded:: 1.10
		
		Returns
		-------
		out : ndarray
		    The covariance matrix of the variables.
		
		See Also
		--------
		corrcoef : Normalized covariance matrix
		
		Notes
		-----
		Assume that the observations are in the columns of the observation
		array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
		steps to compute the weighted covariance are as follows::
		
		    >>> w = f * a
		    >>> v1 = np.sum(w)
		    >>> v2 = np.sum(w * a)
		    >>> m -= np.sum(m * w, axis=1, keepdims=True) / v1
		    >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)
		
		Note that when ``a == 1``, the normalization factor
		``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
		as it should.
		
		Examples
		--------
		Consider two variables, :math:`x_0` and :math:`x_1`, which
		correlate perfectly, but in opposite directions:
		
		>>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
		>>> x
		array([[0, 1, 2],
		       [2, 1, 0]])
		
		Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
		matrix shows this clearly:
		
		>>> np.cov(x)
		array([[ 1., -1.],
		       [-1.,  1.]])
		
		Note that element :math:`C_{0,1}`, which shows the correlation between
		:math:`x_0` and :math:`x_1`, is negative.
		
		Further, note how `x` and `y` are combined:
		
		>>> x = [-2.1, -1,  4.3]
		>>> y = [3,  1.1,  0.12]
		>>> X = np.stack((x, y), axis=0)
		>>> print(np.cov(X))
		[[ 11.71        -4.286     ]
		 [ -4.286        2.14413333]]
		>>> print(np.cov(x, y))
		[[ 11.71        -4.286     ]
		 [ -4.286        2.14413333]]
		>>> print(np.cov(x))
		11.71
	**/
	static public function cov(m:Dynamic, ?y:Dynamic, ?rowvar:Dynamic, ?bias:Dynamic, ?ddof:Dynamic, ?fweights:Dynamic, ?aweights:Dynamic):Dynamic;
	/**
		Return the cross product of two (arrays of) vectors.
		
		The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
		to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
		are defined by the last axis of `a` and `b` by default, and these axes
		can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
		2, the third component of the input vector is assumed to be zero and the
		cross product calculated accordingly.  In cases where both input vectors
		have dimension 2, the z-component of the cross product is returned.
		
		Parameters
		----------
		a : array_like
		    Components of the first vector(s).
		b : array_like
		    Components of the second vector(s).
		axisa : int, optional
		    Axis of `a` that defines the vector(s).  By default, the last axis.
		axisb : int, optional
		    Axis of `b` that defines the vector(s).  By default, the last axis.
		axisc : int, optional
		    Axis of `c` containing the cross product vector(s).  Ignored if
		    both input vectors have dimension 2, as the return is scalar.
		    By default, the last axis.
		axis : int, optional
		    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
		    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.
		
		Returns
		-------
		c : ndarray
		    Vector cross product(s).
		
		Raises
		------
		ValueError
		    When the dimension of the vector(s) in `a` and/or `b` does not
		    equal 2 or 3.
		
		See Also
		--------
		inner : Inner product
		outer : Outer product.
		ix_ : Construct index arrays.
		
		Notes
		-----
		.. versionadded:: 1.9.0
		
		Supports full broadcasting of the inputs.
		
		Examples
		--------
		Vector cross-product.
		
		>>> x = [1, 2, 3]
		>>> y = [4, 5, 6]
		>>> np.cross(x, y)
		array([-3,  6, -3])
		
		One vector with dimension 2.
		
		>>> x = [1, 2]
		>>> y = [4, 5, 6]
		>>> np.cross(x, y)
		array([12, -6, -3])
		
		Equivalently:
		
		>>> x = [1, 2, 0]
		>>> y = [4, 5, 6]
		>>> np.cross(x, y)
		array([12, -6, -3])
		
		Both vectors with dimension 2.
		
		>>> x = [1,2]
		>>> y = [4,5]
		>>> np.cross(x, y)
		-3
		
		Multiple vector cross-products. Note that the direction of the cross
		product vector is defined by the `right-hand rule`.
		
		>>> x = np.array([[1,2,3], [4,5,6]])
		>>> y = np.array([[4,5,6], [1,2,3]])
		>>> np.cross(x, y)
		array([[-3,  6, -3],
		       [ 3, -6,  3]])
		
		The orientation of `c` can be changed using the `axisc` keyword.
		
		>>> np.cross(x, y, axisc=0)
		array([[-3,  3],
		       [ 6, -6],
		       [-3,  3]])
		
		Change the vector definition of `x` and `y` using `axisa` and `axisb`.
		
		>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
		>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
		>>> np.cross(x, y)
		array([[ -6,  12,  -6],
		       [  0,   0,   0],
		       [  6, -12,   6]])
		>>> np.cross(x, y, axisa=0, axisb=0)
		array([[-24,  48, -24],
		       [-30,  60, -30],
		       [-36,  72, -36]])
	**/
	static public function cross(a:Dynamic, b:Dynamic, ?axisa:Dynamic, ?axisb:Dynamic, ?axisc:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Plot the cross-spectral density.
		
		The cross spectral density :math:`P_{xy}` by Welch's average
		periodogram method.  The vectors *x* and *y* are divided into
		*NFFT* length segments.  Each segment is detrended by function
		*detrend* and windowed by function *window*.  *noverlap* gives
		the length of the overlap between segments.  The product of
		the direct FFTs of *x* and *y* are averaged over each segment
		to compute :math:`P_{xy}`, with a scaling to correct for power
		loss due to windowing.
		
		If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
		padded to *NFFT*.
		
		Parameters
		----------
		x, y : 1-D arrays or sequences
		    Arrays or sequences containing the data.
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  This can be different from *NFFT*, which
		    specifies the number of data points used.  While not increasing
		    the actual resolution of the spectrum (the minimum distance between
		    resolvable peaks), this can give more points in the plot,
		    allowing for more detail. This corresponds to the *n* parameter
		    in the call to fft(). The default is None, which sets *pad_to*
		    equal to *NFFT*
		
		NFFT : int
		    The number of data points used in each block for the FFT.
		    A power 2 is most efficient.  The default value is 256.
		    This should *NOT* be used to get zero padding, or the scaling of the
		    result will be incorrect. Use *pad_to* for this instead.
		
		detrend : {'none', 'mean', 'linear'} or callable, default 'none'
		    The function applied to each segment before fft-ing, designed to
		    remove the mean or linear trend.  Unlike in MATLAB, where the
		    *detrend* parameter is a vector, in Matplotlib is it a function.
		    The :mod:`~matplotlib.mlab` module defines `.detrend_none`,
		    `.detrend_mean`, and `.detrend_linear`, but you can use a custom
		    function as well.  You can also use a string to choose one of the
		    functions: 'none' calls `.detrend_none`. 'mean' calls `.detrend_mean`.
		    'linear' calls `.detrend_linear`.
		
		scale_by_freq : bool, optional
		    Specifies whether the resulting density values should be scaled
		    by the scaling frequency, which gives density in units of Hz^-1.
		    This allows for integration over the returned frequency values.
		    The default is True for MATLAB compatibility.
		
		noverlap : int
		    The number of points of overlap between segments.
		    The default value is 0 (no overlap).
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		return_line : bool
		    Whether to include the line object plotted in the returned values.
		    Default is False.
		
		Returns
		-------
		Pxy : 1-D array
		    The values for the cross spectrum `P_{xy}` before scaling
		    (complex valued).
		
		freqs : 1-D array
		    The frequencies corresponding to the elements in *Pxy*.
		
		line : a :class:`~matplotlib.lines.Line2D` instance
		    The line created by this function.
		    Only returned if *return_line* is True.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See Also
		--------
		:func:`psd`
		    :func:`psd` is the equivalent to setting y=x.
		
		Notes
		-----
		For plotting, the power is plotted as
		:math:`10\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself
		is returned.
		
		References
		----------
		Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
		John Wiley & Sons (1986)
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function csd(x:Dynamic, y:Dynamic, ?NFFT:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?detrend:Dynamic, ?window:Dynamic, ?noverlap:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?scale_by_freq:Dynamic, ?return_line:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the cumulative product of elements along a given axis.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    Axis along which the cumulative product is computed.  By default
		    the input is flattened.
		dtype : dtype, optional
		    Type of the returned array, as well as of the accumulator in which
		    the elements are multiplied.  If *dtype* is not specified, it
		    defaults to the dtype of `a`, unless `a` has an integer dtype with
		    a precision less than that of the default platform integer.  In
		    that case, the default platform integer is used instead.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output
		    but the type of the resulting values will be cast if necessary.
		
		Returns
		-------
		cumprod : ndarray
		    A new array holding the result is returned unless `out` is
		    specified, in which case a reference to out is returned.
		
		See Also
		--------
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		Arithmetic is modular when using integer types, and no error is
		raised on overflow.
		
		Examples
		--------
		>>> a = np.array([1,2,3])
		>>> np.cumprod(a) # intermediate results 1, 1*2
		...               # total product 1*2*3 = 6
		array([1, 2, 6])
		>>> a = np.array([[1, 2, 3], [4, 5, 6]])
		>>> np.cumprod(a, dtype=float) # specify type of output
		array([   1.,    2.,    6.,   24.,  120.,  720.])
		
		The cumulative product for each column (i.e., over the rows) of `a`:
		
		>>> np.cumprod(a, axis=0)
		array([[ 1,  2,  3],
		       [ 4, 10, 18]])
		
		The cumulative product for each row (i.e. over the columns) of `a`:
		
		>>> np.cumprod(a,axis=1)
		array([[  1,   2,   6],
		       [  4,  20, 120]])
	**/
	static public function cumprod(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Return the cumulative product over the given axis.
		
		See Also
		--------
		cumprod : equivalent function; see for details.
	**/
	static public function cumproduct(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the cumulative sum of the elements along a given axis.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    Axis along which the cumulative sum is computed. The default
		    (None) is to compute the cumsum over the flattened array.
		dtype : dtype, optional
		    Type of the returned array and of the accumulator in which the
		    elements are summed.  If `dtype` is not specified, it defaults
		    to the dtype of `a`, unless `a` has an integer dtype with a
		    precision less than that of the default platform integer.  In
		    that case, the default platform integer is used.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output
		    but the type will be cast if necessary. See `doc.ufuncs`
		    (Section "Output arguments") for more details.
		
		Returns
		-------
		cumsum_along_axis : ndarray.
		    A new array holding the result is returned unless `out` is
		    specified, in which case a reference to `out` is returned. The
		    result has the same size as `a`, and the same shape as `a` if
		    `axis` is not None or `a` is a 1-d array.
		
		
		See Also
		--------
		sum : Sum array elements.
		
		trapz : Integration of array values using the composite trapezoidal rule.
		
		diff :  Calculate the n-th discrete difference along given axis.
		
		Notes
		-----
		Arithmetic is modular when using integer types, and no error is
		raised on overflow.
		
		Examples
		--------
		>>> a = np.array([[1,2,3], [4,5,6]])
		>>> a
		array([[1, 2, 3],
		       [4, 5, 6]])
		>>> np.cumsum(a)
		array([ 1,  3,  6, 10, 15, 21])
		>>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
		array([  1.,   3.,   6.,  10.,  15.,  21.])
		
		>>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
		array([[1, 2, 3],
		       [5, 7, 9]])
		>>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
		array([[ 1,  3,  6],
		       [ 4,  9, 15]])
	**/
	static public function cumsum(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Create a new `Cycler` object from a single positional argument,
		a pair of positional arguments, or the combination of keyword arguments.
		
		cycler(arg)
		cycler(label1=itr1[, label2=iter2[, ...]])
		cycler(label, itr)
		
		Form 1 simply copies a given `Cycler` object.
		
		Form 2 composes a `Cycler` as an inner product of the
		pairs of keyword arguments. In other words, all of the
		iterables are cycled simultaneously, as if through zip().
		
		Form 3 creates a `Cycler` from a label and an iterable.
		This is useful for when the label cannot be a keyword argument
		(e.g., an integer or a name that has a space in it).
		
		Parameters
		----------
		arg : Cycler
		    Copy constructor for Cycler (does a shallow copy of iterables).
		
		label : name
		    The property key. In the 2-arg form of the function,
		    the label can be any hashable object. In the keyword argument
		    form of the function, it must be a valid python identifier.
		
		itr : iterable
		    Finite length iterable of the property values.
		    Can be a single-property `Cycler` that would
		    be like a key change, but as a shallow copy.
		
		Returns
		-------
		cycler : Cycler
		    New `Cycler` for the given property
	**/
	static public function cycler(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Convert datetime objects to Matplotlib dates.
		
		Parameters
		----------
		d : `datetime.datetime` or `numpy.datetime64` or sequences of these
		
		Returns
		-------
		float or sequence of floats
		    Number of days (fraction part represents hours, minutes, seconds, ms)
		    since 0001-01-01 00:00:00 UTC, plus one.
		
		Notes
		-----
		The addition of one here is a historical artifact. Also, note that the
		Gregorian calendar is assumed; this is not universal practice.
		For details see the module docstring.
	**/
	static public function date2num(d:Dynamic):Dynamic;
	/**
		Convert a date string to a datenum using :func:`dateutil.parser.parse`.
		
		Parameters
		----------
		d : string or sequence of strings
		    The dates to convert.
		
		default : datetime instance, optional
		    The default date to use when fields are missing in *d*.
	**/
	static public function datestr2num(d:Dynamic, ?_default:Dynamic):Dynamic;
	/**
		datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
		
		Convert an array of datetimes into an array of strings.
		
		Parameters
		----------
		arr : array_like of datetime64
		    The array of UTC timestamps to format.
		unit : str
		    One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.
		timezone : {'naive', 'UTC', 'local'} or tzinfo
		    Timezone information to use when displaying the datetime. If 'UTC', end
		    with a Z to indicate UTC time. If 'local', convert to the local timezone
		    first, and suffix with a +-#### timezone offset. If a tzinfo object,
		    then do as with 'local', but use the specified timezone.
		casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
		    Casting to allow when changing between datetime units.
		
		Returns
		-------
		str_arr : ndarray
		    An array of strings the same shape as `arr`.
		
		Examples
		--------
		>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
		>>> d
		array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
		       '2002-10-27T07:30'], dtype='datetime64[m]')
		
		Setting the timezone to UTC shows the same information, but with a Z suffix
		
		>>> np.datetime_as_string(d, timezone='UTC')
		array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
		       '2002-10-27T07:30Z'], dtype='<U35')
		
		Note that we picked datetimes that cross a DST boundary. Passing in a
		``pytz`` timezone object will print the appropriate offset
		
		>>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
		array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
		       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')
		
		Passing in a unit will change the precision
		
		>>> np.datetime_as_string(d, unit='h')
		array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
		      dtype='<U32')
		>>> np.datetime_as_string(d, unit='s')
		array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
		       '2002-10-27T07:30:00'], dtype='<U38')
		
		'casting' can be used to specify whether precision can be changed
		
		>>> np.datetime_as_string(d, unit='h', casting='safe')
		TypeError: Cannot create a datetime string as units 'h' from a NumPy
		datetime with units 'm' according to the rule 'safe'
	**/
	static public function datetime_as_string(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		datetime_data(dtype, /)
		
		Get information about the step size of a date or time type.
		
		The returned tuple can be passed as the second argument of `numpy.datetime64` and
		`numpy.timedelta64`.
		
		Parameters
		----------
		dtype : dtype
		    The dtype object, which must be a `datetime64` or `timedelta64` type.
		
		Returns
		-------
		unit : str
		    The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype
		    is based.
		count : int
		    The number of base units in a step.
		
		Examples
		--------
		>>> dt_25s = np.dtype('timedelta64[25s]')
		>>> np.datetime_data(dt_25s)
		('s', 25)
		>>> np.array(10, dt_25s).astype('timedelta64[s]')
		array(250, dtype='timedelta64[s]')
		
		The result can be used to construct a datetime that uses the same units
		as a timedelta
		
		>>> np.datetime64('2010', np.datetime_data(dt_25s))
		numpy.datetime64('2010-01-01T00:00:00', '25s')
	**/
	static public function datetime_data(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		[*Deprecated*] Remove excess indentation from docstring *s*.
		
		Discards any leading blank lines, then removes up to n whitespace
		characters from each line, where n is the number of leading
		whitespace characters in the first line. It differs from
		textwrap.dedent in its deletion of leading blank lines and its use
		of the first non-blank line to determine the indentation.
		
		It is also faster in most cases.
		
		Notes
		-----
		.. deprecated:: 3.1
		   
	**/
	static public function dedent(s:Dynamic):Dynamic;
	/**
		deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Convert angles from degrees to radians.
		
		Parameters
		----------
		x : array_like
		    Angles in degrees.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding angle in radians.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		rad2deg : Convert angles from radians to degrees.
		unwrap : Remove large jumps in angle by wrapping.
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		``deg2rad(x)`` is ``x * pi / 180``.
		
		Examples
		--------
		>>> np.deg2rad(180)
		3.1415926535897931
	**/
	static public function deg2rad(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Convert angles from radians to degrees.
		
		Parameters
		----------
		x : array_like
		    Input array in radians.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray of floats
		    The corresponding degree values; if `out` was supplied this is a
		    reference to it.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		rad2deg : equivalent function
		
		Examples
		--------
		Convert a radian array to degrees
		
		>>> rad = np.arange(12.)*np.pi/6
		>>> np.degrees(rad)
		array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
		        270.,  300.,  330.])
		
		>>> out = np.zeros((rad.shape))
		>>> r = degrees(rad, out)
		>>> np.all(r == out)
		True
	**/
	static public function degrees(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Remove the `Axes` *ax* (defaulting to the current axes) from its figure.
		
		A KeyError is raised if the axes doesn't exist.
	**/
	static public function delaxes(?ax:Dynamic):Dynamic;
	/**
		Return a new array with sub-arrays along an axis deleted. For a one
		dimensional array, this returns those entries not returned by
		`arr[obj]`.
		
		Parameters
		----------
		arr : array_like
		  Input array.
		obj : slice, int or array of ints
		  Indicate which sub-arrays to remove.
		axis : int, optional
		  The axis along which to delete the subarray defined by `obj`.
		  If `axis` is None, `obj` is applied to the flattened array.
		
		Returns
		-------
		out : ndarray
		    A copy of `arr` with the elements specified by `obj` removed. Note
		    that `delete` does not occur in-place. If `axis` is None, `out` is
		    a flattened array.
		
		See Also
		--------
		insert : Insert elements into an array.
		append : Append elements at the end of an array.
		
		Notes
		-----
		Often it is preferable to use a boolean mask. For example:
		
		>>> mask = np.ones(len(arr), dtype=bool)
		>>> mask[[0,2,4]] = False
		>>> result = arr[mask,...]
		
		Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further
		use of `mask`.
		
		Examples
		--------
		>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
		>>> arr
		array([[ 1,  2,  3,  4],
		       [ 5,  6,  7,  8],
		       [ 9, 10, 11, 12]])
		>>> np.delete(arr, 1, 0)
		array([[ 1,  2,  3,  4],
		       [ 9, 10, 11, 12]])
		
		>>> np.delete(arr, np.s_[::2], 1)
		array([[ 2,  4],
		       [ 6,  8],
		       [10, 12]])
		>>> np.delete(arr, [1,3,5], None)
		array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])
	**/
	static public function delete(arr:Dynamic, obj:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		[*Deprecated*] Return x minus its mean along the specified axis.
		
		Parameters
		----------
		x : array or sequence
		    Array or sequence containing the data
		    Can have any dimensionality
		
		axis : integer
		    The axis along which to take the mean.  See numpy.mean for a
		    description of this argument.
		
		See Also
		--------
		detrend_mean : Same as `demean` except for the default *axis*.
		
		Notes
		-----
		.. deprecated:: 3.1
		   
	**/
	static public function demean(x:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Issues a DeprecationWarning, adds warning to `old_name`'s
		docstring, rebinds ``old_name.__name__`` and returns the new
		function object.
		
		This function may also be used as a decorator.
		
		Parameters
		----------
		func : function
		    The function to be deprecated.
		old_name : str, optional
		    The name of the function to be deprecated. Default is None, in
		    which case the name of `func` is used.
		new_name : str, optional
		    The new name for the function. Default is None, in which case the
		    deprecation message is that `old_name` is deprecated. If given, the
		    deprecation message is that `old_name` is deprecated and `new_name`
		    should be used instead.
		message : str, optional
		    Additional explanation of the deprecation.  Displayed in the
		    docstring after the warning.
		
		Returns
		-------
		old_func : function
		    The deprecated function.
		
		Examples
		--------
		Note that ``olduint`` returns a value after printing Deprecation
		Warning:
		
		>>> olduint = np.deprecate(np.uint)
		>>> olduint(6)
		/usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:
		DeprecationWarning: uint32 is deprecated
		  warnings.warn(str1, DeprecationWarning, stacklevel=2)
		6
	**/
	static public function deprecate(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):haxe.Constraints.Function;
	static public function deprecate_with_doc(msg:Dynamic):Dynamic;
	/**
		Decorator to mark a function, a class, or a property as deprecated.
		
		When deprecating a classmethod, a staticmethod, or a property, the
		``@deprecated`` decorator should go *under* the ``@classmethod``, etc.
		decorator (i.e., `deprecated` should directly decorate the underlying
		callable).
		
		Parameters
		----------
		since : str
		    The release at which this API became deprecated.  This is
		    required.
		
		message : str, optional
		    Override the default deprecation message.  The format
		    specifier `%(name)s` may be used for the name of the object,
		    and `%(alternative)s` may be used in the deprecation message
		    to insert the name of an alternative to the deprecated
		    object.
		
		name : str, optional
		    The name of the deprecated object; if not provided the name
		    is automatically determined from the passed in object,
		    though this is useful in the case of renamed functions, where
		    the new function is just assigned to the name of the
		    deprecated function.  For example::
		
		        def new_function():
		            ...
		        old_function = new_function
		
		alternative : str, optional
		    An alternative API that the user may use in place of the deprecated
		    API.  The deprecation warning will tell the user about this alternative
		    if provided.
		
		pending : bool, optional
		    If True, uses a PendingDeprecationWarning instead of a
		    DeprecationWarning.  Cannot be used together with *removal*.
		
		obj_type : str, optional
		    The object type being deprecated; by default, 'function' if decorating
		    a function and 'class' if decorating a class.
		
		addendum : str, optional
		    Additional text appended directly to the final message.
		
		removal : str, optional
		    The expected removal version.  With the default (an empty string), a
		    removal version is automatically computed from *since*.  Set to other
		    Falsy values to not schedule a removal date.  Cannot be used together
		    with *pending*.
		
		Examples
		--------
		
		    Basic example::
		
		        @deprecated('1.4.0')
		        def the_function_to_deprecate():
		            pass
	**/
	static public function deprecated(since:Dynamic, ?message:Dynamic, ?name:Dynamic, ?alternative:Dynamic, ?pending:Dynamic, ?obj_type:Dynamic, ?addendum:Dynamic, ?removal:Dynamic):Dynamic;
	/**
		Compute the determinant of an array.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Input array to compute determinants for.
		
		Returns
		-------
		det : (...) array_like
		    Determinant of `a`.
		
		See Also
		--------
		slogdet : Another way to represent the determinant, more suitable
		  for large matrices where underflow/overflow may occur.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		The determinant is computed via LU factorization using the LAPACK
		routine z/dgetrf.
		
		Examples
		--------
		The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:
		
		>>> a = np.array([[1, 2], [3, 4]])
		>>> np.linalg.det(a)
		-2.0
		
		Computing determinants for a stack of matrices:
		
		>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
		>>> a.shape
		(3, 2, 2)
		>>> np.linalg.det(a)
		array([-2., -3., -8.])
	**/
	static public function det(a:Dynamic):Dynamic;
	/**
		Return x with its trend removed.
		
		Parameters
		----------
		x : array or sequence
		    Array or sequence containing the data.
		
		key : [ 'default' | 'constant' | 'mean' | 'linear' | 'none'] or function
		    Specifies the detrend algorithm to use. 'default' is 'mean', which is
		    the same as `detrend_mean`. 'constant' is the same. 'linear' is
		    the same as `detrend_linear`. 'none' is the same as
		    `detrend_none`. The default is 'mean'. See the corresponding
		    functions for more details regarding the algorithms. Can also be a
		    function that carries out the detrend operation.
		
		axis : integer
		    The axis along which to do the detrending.
		
		See Also
		--------
		detrend_mean : Implementation of the 'mean' algorithm.
		detrend_linear : Implementation of the 'linear' algorithm.
		detrend_none : Implementation of the 'none' algorithm.
	**/
	static public function detrend(x:Dynamic, ?key:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return x minus best fit line; 'linear' detrending.
		
		Parameters
		----------
		y : 0-D or 1-D array or sequence
		    Array or sequence containing the data
		
		axis : integer
		    The axis along which to take the mean.  See numpy.mean for a
		    description of this argument.
		
		See Also
		--------
		detrend_mean : Another detrend algorithm.
		detrend_none : Another detrend algorithm.
		detrend : A wrapper around all the detrend algorithms.
	**/
	static public function detrend_linear(y:Dynamic):Dynamic;
	/**
		Return x minus the mean(x).
		
		Parameters
		----------
		x : array or sequence
		    Array or sequence containing the data
		    Can have any dimensionality
		
		axis : integer
		    The axis along which to take the mean.  See numpy.mean for a
		    description of this argument.
		
		See Also
		--------
		detrend_linear : Another detrend algorithm.
		detrend_none : Another detrend algorithm.
		detrend : A wrapper around all the detrend algorithms.
	**/
	static public function detrend_mean(x:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return x: no detrending.
		
		Parameters
		----------
		x : any object
		    An object containing the data
		
		axis : integer
		    This parameter is ignored.
		    It is included for compatibility with detrend_mean
		
		See Also
		--------
		detrend_mean : Another detrend algorithm.
		detrend_linear : Another detrend algorithm.
		detrend : A wrapper around all the detrend algorithms.
	**/
	static public function detrend_none(x:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Extract a diagonal or construct a diagonal array.
		
		See the more detailed documentation for ``numpy.diagonal`` if you use this
		function to extract a diagonal and wish to write to the resulting array;
		whether it returns a copy or a view depends on what version of numpy you
		are using.
		
		Parameters
		----------
		v : array_like
		    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
		    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
		    diagonal.
		k : int, optional
		    Diagonal in question. The default is 0. Use `k>0` for diagonals
		    above the main diagonal, and `k<0` for diagonals below the main
		    diagonal.
		
		Returns
		-------
		out : ndarray
		    The extracted diagonal or constructed diagonal array.
		
		See Also
		--------
		diagonal : Return specified diagonals.
		diagflat : Create a 2-D array with the flattened input as a diagonal.
		trace : Sum along diagonals.
		triu : Upper triangle of an array.
		tril : Lower triangle of an array.
		
		Examples
		--------
		>>> x = np.arange(9).reshape((3,3))
		>>> x
		array([[0, 1, 2],
		       [3, 4, 5],
		       [6, 7, 8]])
		
		>>> np.diag(x)
		array([0, 4, 8])
		>>> np.diag(x, k=1)
		array([1, 5])
		>>> np.diag(x, k=-1)
		array([3, 7])
		
		>>> np.diag(np.diag(x))
		array([[0, 0, 0],
		       [0, 4, 0],
		       [0, 0, 8]])
	**/
	static public function diag(v:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Return the indices to access the main diagonal of an array.
		
		This returns a tuple of indices that can be used to access the main
		diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape
		(n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for
		``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``
		for ``i = [0..n-1]``.
		
		Parameters
		----------
		n : int
		  The size, along each dimension, of the arrays for which the returned
		  indices can be used.
		
		ndim : int, optional
		  The number of dimensions.
		
		See also
		--------
		diag_indices_from
		
		Notes
		-----
		.. versionadded:: 1.4.0
		
		Examples
		--------
		Create a set of indices to access the diagonal of a (4, 4) array:
		
		>>> di = np.diag_indices(4)
		>>> di
		(array([0, 1, 2, 3]), array([0, 1, 2, 3]))
		>>> a = np.arange(16).reshape(4, 4)
		>>> a
		array([[ 0,  1,  2,  3],
		       [ 4,  5,  6,  7],
		       [ 8,  9, 10, 11],
		       [12, 13, 14, 15]])
		>>> a[di] = 100
		>>> a
		array([[100,   1,   2,   3],
		       [  4, 100,   6,   7],
		       [  8,   9, 100,  11],
		       [ 12,  13,  14, 100]])
		
		Now, we create indices to manipulate a 3-D array:
		
		>>> d3 = np.diag_indices(2, 3)
		>>> d3
		(array([0, 1]), array([0, 1]), array([0, 1]))
		
		And use it to set the diagonal of an array of zeros to 1:
		
		>>> a = np.zeros((2, 2, 2), dtype=int)
		>>> a[d3] = 1
		>>> a
		array([[[1, 0],
		        [0, 0]],
		       [[0, 0],
		        [0, 1]]])
	**/
	static public function diag_indices(n:Dynamic, ?ndim:Dynamic):Dynamic;
	/**
		Return the indices to access the main diagonal of an n-dimensional array.
		
		See `diag_indices` for full details.
		
		Parameters
		----------
		arr : array, at least 2-D
		
		See Also
		--------
		diag_indices
		
		Notes
		-----
		.. versionadded:: 1.4.0
	**/
	static public function diag_indices_from(arr:Dynamic):Dynamic;
	/**
		Create a two-dimensional array with the flattened input as a diagonal.
		
		Parameters
		----------
		v : array_like
		    Input data, which is flattened and set as the `k`-th
		    diagonal of the output.
		k : int, optional
		    Diagonal to set; 0, the default, corresponds to the "main" diagonal,
		    a positive (negative) `k` giving the number of the diagonal above
		    (below) the main.
		
		Returns
		-------
		out : ndarray
		    The 2-D output array.
		
		See Also
		--------
		diag : MATLAB work-alike for 1-D and 2-D arrays.
		diagonal : Return specified diagonals.
		trace : Sum along diagonals.
		
		Examples
		--------
		>>> np.diagflat([[1,2], [3,4]])
		array([[1, 0, 0, 0],
		       [0, 2, 0, 0],
		       [0, 0, 3, 0],
		       [0, 0, 0, 4]])
		
		>>> np.diagflat([1,2], 1)
		array([[0, 1, 0],
		       [0, 0, 2],
		       [0, 0, 0]])
	**/
	static public function diagflat(v:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Return specified diagonals.
		
		If `a` is 2-D, returns the diagonal of `a` with the given offset,
		i.e., the collection of elements of the form ``a[i, i+offset]``.  If
		`a` has more than two dimensions, then the axes specified by `axis1`
		and `axis2` are used to determine the 2-D sub-array whose diagonal is
		returned.  The shape of the resulting array can be determined by
		removing `axis1` and `axis2` and appending an index to the right equal
		to the size of the resulting diagonals.
		
		In versions of NumPy prior to 1.7, this function always returned a new,
		independent array containing a copy of the values in the diagonal.
		
		In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
		but depending on this fact is deprecated. Writing to the resulting
		array continues to work as it used to, but a FutureWarning is issued.
		
		Starting in NumPy 1.9 it returns a read-only view on the original array.
		Attempting to write to the resulting array will produce an error.
		
		In some future release, it will return a read/write view and writing to
		the returned array will alter your original array.  The returned array
		will have the same type as the input array.
		
		If you don't write to the array returned by this function, then you can
		just ignore all of the above.
		
		If you depend on the current behavior, then we suggest copying the
		returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
		of just ``np.diagonal(a)``. This will work with both past and future
		versions of NumPy.
		
		Parameters
		----------
		a : array_like
		    Array from which the diagonals are taken.
		offset : int, optional
		    Offset of the diagonal from the main diagonal.  Can be positive or
		    negative.  Defaults to main diagonal (0).
		axis1 : int, optional
		    Axis to be used as the first axis of the 2-D sub-arrays from which
		    the diagonals should be taken.  Defaults to first axis (0).
		axis2 : int, optional
		    Axis to be used as the second axis of the 2-D sub-arrays from
		    which the diagonals should be taken. Defaults to second axis (1).
		
		Returns
		-------
		array_of_diagonals : ndarray
		    If `a` is 2-D, then a 1-D array containing the diagonal and of the
		    same type as `a` is returned unless `a` is a `matrix`, in which case
		    a 1-D array rather than a (2-D) `matrix` is returned in order to
		    maintain backward compatibility.
		    
		    If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`
		    are removed, and a new axis inserted at the end corresponding to the
		    diagonal.
		
		Raises
		------
		ValueError
		    If the dimension of `a` is less than 2.
		
		See Also
		--------
		diag : MATLAB work-a-like for 1-D and 2-D arrays.
		diagflat : Create diagonal arrays.
		trace : Sum along diagonals.
		
		Examples
		--------
		>>> a = np.arange(4).reshape(2,2)
		>>> a
		array([[0, 1],
		       [2, 3]])
		>>> a.diagonal()
		array([0, 3])
		>>> a.diagonal(1)
		array([1])
		
		A 3-D example:
		
		>>> a = np.arange(8).reshape(2,2,2); a
		array([[[0, 1],
		        [2, 3]],
		       [[4, 5],
		        [6, 7]]])
		>>> a.diagonal(0, # Main diagonals of two arrays created by skipping
		...            0, # across the outer(left)-most axis last and
		...            1) # the "middle" (row) axis first.
		array([[0, 6],
		       [1, 7]])
		
		The sub-arrays whose main diagonals we just obtained; note that each
		corresponds to fixing the right-most (column) axis, and that the
		diagonals are "packed" in rows.
		
		>>> a[:,:,0] # main diagonal is [0 6]
		array([[0, 2],
		       [4, 6]])
		>>> a[:,:,1] # main diagonal is [1 7]
		array([[1, 3],
		       [5, 7]])
	**/
	static public function diagonal(a:Dynamic, ?offset:Dynamic, ?axis1:Dynamic, ?axis2:Dynamic):Dynamic;
	/**
		Calculate the n-th discrete difference along the given axis.
		
		The first difference is given by ``out[n] = a[n+1] - a[n]`` along
		the given axis, higher differences are calculated by using `diff`
		recursively.
		
		Parameters
		----------
		a : array_like
		    Input array
		n : int, optional
		    The number of times values are differenced. If zero, the input
		    is returned as-is.
		axis : int, optional
		    The axis along which the difference is taken, default is the
		    last axis.
		prepend, append : array_like, optional
		    Values to prepend or append to "a" along axis prior to
		    performing the difference.  Scalar values are expanded to
		    arrays with length 1 in the direction of axis and the shape
		    of the input array in along all other axes.  Otherwise the
		    dimension and shape must match "a" except along axis.
		
		Returns
		-------
		diff : ndarray
		    The n-th differences. The shape of the output is the same as `a`
		    except along `axis` where the dimension is smaller by `n`. The
		    type of the output is the same as the type of the difference
		    between any two elements of `a`. This is the same as the type of
		    `a` in most cases. A notable exception is `datetime64`, which
		    results in a `timedelta64` output array.
		
		See Also
		--------
		gradient, ediff1d, cumsum
		
		Notes
		-----
		Type is preserved for boolean arrays, so the result will contain
		`False` when consecutive elements are the same and `True` when they
		differ.
		
		For unsigned integer arrays, the results will also be unsigned. This
		should not be surprising, as the result is consistent with
		calculating the difference directly:
		
		>>> u8_arr = np.array([1, 0], dtype=np.uint8)
		>>> np.diff(u8_arr)
		array([255], dtype=uint8)
		>>> u8_arr[1,...] - u8_arr[0,...]
		array(255, np.uint8)
		
		If this is not desirable, then the array should be cast to a larger
		integer type first:
		
		>>> i16_arr = u8_arr.astype(np.int16)
		>>> np.diff(i16_arr)
		array([-1], dtype=int16)
		
		Examples
		--------
		>>> x = np.array([1, 2, 4, 7, 0])
		>>> np.diff(x)
		array([ 1,  2,  3, -7])
		>>> np.diff(x, n=2)
		array([  1,   1, -10])
		
		>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
		>>> np.diff(x)
		array([[2, 3, 4],
		       [5, 1, 2]])
		>>> np.diff(x, axis=0)
		array([[-1,  2,  0, -2]])
		
		>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
		>>> np.diff(x)
		array([1, 1], dtype='timedelta64[D]')
	**/
	static public function diff(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?prepend:Dynamic, ?append:Dynamic):Dynamic;
	/**
		Return the indices of the bins to which each value in input array belongs.
		
		=========  =============  ============================
		`right`    order of bins  returned index `i` satisfies
		=========  =============  ============================
		``False``  increasing     ``bins[i-1] <= x < bins[i]``
		``True``   increasing     ``bins[i-1] < x <= bins[i]``
		``False``  decreasing     ``bins[i-1] > x >= bins[i]``
		``True``   decreasing     ``bins[i-1] >= x > bins[i]``
		=========  =============  ============================
		
		If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
		returned as appropriate.
		
		Parameters
		----------
		x : array_like
		    Input array to be binned. Prior to NumPy 1.10.0, this array had to
		    be 1-dimensional, but can now have any shape.
		bins : array_like
		    Array of bins. It has to be 1-dimensional and monotonic.
		right : bool, optional
		    Indicating whether the intervals include the right or the left bin
		    edge. Default behavior is (right==False) indicating that the interval
		    does not include the right edge. The left bin end is open in this
		    case, i.e., bins[i-1] <= x < bins[i] is the default behavior for
		    monotonically increasing bins.
		
		Returns
		-------
		indices : ndarray of ints
		    Output array of indices, of same shape as `x`.
		
		Raises
		------
		ValueError
		    If `bins` is not monotonic.
		TypeError
		    If the type of the input is complex.
		
		See Also
		--------
		bincount, histogram, unique, searchsorted
		
		Notes
		-----
		If values in `x` are such that they fall outside the bin range,
		attempting to index `bins` with the indices that `digitize` returns
		will result in an IndexError.
		
		.. versionadded:: 1.10.0
		
		`np.digitize` is  implemented in terms of `np.searchsorted`. This means
		that a binary search is used to bin the values, which scales much better
		for larger number of bins than the previous linear search. It also removes
		the requirement for the input array to be 1-dimensional.
		
		For monotonically _increasing_ `bins`, the following are equivalent::
		
		    np.digitize(x, bins, right=True)
		    np.searchsorted(bins, x, side='left')
		
		Note that as the order of the arguments are reversed, the side must be too.
		The `searchsorted` call is marginally faster, as it does not do any
		monotonicity checks. Perhaps more importantly, it supports all dtypes.
		
		Examples
		--------
		>>> x = np.array([0.2, 6.4, 3.0, 1.6])
		>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
		>>> inds = np.digitize(x, bins)
		>>> inds
		array([1, 4, 3, 2])
		>>> for n in range(x.size):
		...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
		...
		0.0 <= 0.2 < 1.0
		4.0 <= 6.4 < 10.0
		2.5 <= 3.0 < 4.0
		1.0 <= 1.6 < 2.5
		
		>>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
		>>> bins = np.array([0, 5, 10, 15, 20])
		>>> np.digitize(x,bins,right=True)
		array([1, 2, 3, 4, 4])
		>>> np.digitize(x,bins,right=False)
		array([1, 3, 3, 4, 5])
	**/
	static public function digitize(x:Dynamic, bins:Dynamic, ?right:Dynamic):Dynamic;
	/**
		dirichlet(alpha, size=None)
		
		Draw samples from the Dirichlet distribution.
		
		Draw `size` samples of dimension k from a Dirichlet distribution. A
		Dirichlet-distributed random variable can be seen as a multivariate
		generalization of a Beta distribution. Dirichlet pdf is the conjugate
		prior of a multinomial in Bayesian inference.
		
		Parameters
		----------
		alpha : array
		    Parameter of the distribution (k dimension for sample of
		    dimension k).
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		samples : ndarray,
		    The drawn samples, of shape (size, alpha.ndim).
		
		Raises
		-------
		ValueError
		    If any value in alpha is less than or equal to zero
		
		Notes
		-----
		.. math:: X \approx \prod_{i=1}^{k}{x^{\alpha_i-1}_i}
		
		Uses the following property for computation: for each dimension,
		draw a random sample y_i from a standard gamma generator of shape
		`alpha_i`, then
		:math:`X = \frac{1}{\sum_{i=1}^k{y_i}} (y_1, \ldots, y_n)` is
		Dirichlet distributed.
		
		References
		----------
		.. [1] David McKay, "Information Theory, Inference and Learning
		       Algorithms," chapter 23,
		       http://www.inference.org.uk/mackay/itila/
		.. [2] Wikipedia, "Dirichlet distribution",
		       https://en.wikipedia.org/wiki/Dirichlet_distribution
		
		Examples
		--------
		Taking an example cited in Wikipedia, this distribution can be used if
		one wanted to cut strings (each of initial length 1.0) into K pieces
		with different lengths, where each piece had, on average, a designated
		average length, but allowing some variation in the relative sizes of
		the pieces.
		
		>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()
		
		>>> import matplotlib.pyplot as plt
		>>> plt.barh(range(20), s[0])
		>>> plt.barh(range(20), s[1], left=s[0], color='g')
		>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
		>>> plt.title("Lengths of Strings")
	**/
	static public function dirichlet(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Disconnect callback id cid
		
		Examples
		--------
		Usage::
		
		    cid = canvas.mpl_connect('button_press_event', on_press)
		    #...later
		    canvas.mpl_disconnect(cid)
	**/
	static public function disconnect(cid:Dynamic):Dynamic;
	/**
		Display a message on a device.
		
		Parameters
		----------
		mesg : str
		    Message to display.
		device : object
		    Device to write message. If None, defaults to ``sys.stdout`` which is
		    very similar to ``print``. `device` needs to have ``write()`` and
		    ``flush()`` methods.
		linefeed : bool, optional
		    Option whether to print a line feed or not. Defaults to True.
		
		Raises
		------
		AttributeError
		    If `device` does not have a ``write()`` or ``flush()`` method.
		
		Examples
		--------
		Besides ``sys.stdout``, a file-like object can also be used as it has
		both required methods:
		
		>>> from io import StringIO
		>>> buf = StringIO()
		>>> np.disp(u'"Display" in a file', device=buf)
		>>> buf.getvalue()
		'"Display" in a file\n'
	**/
	static public function disp(mesg:Dynamic, ?device:Dynamic, ?linefeed:Dynamic):Dynamic;
	/**
		true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns a true division of the inputs, element-wise.
		
		Instead of the Python traditional 'floor division', this returns a true
		division.  True division adjusts the output type to present the best
		answer, regardless of input types.
		
		Parameters
		----------
		x1 : array_like
		    Dividend array.
		x2 : array_like
		    Divisor array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		The floor division operator ``//`` was added in Python 2.2 making
		``//`` and ``/`` equivalent operators.  The default floor division
		operation of ``/`` can be replaced by true division with ``from
		__future__ import division``.
		
		In Python 3.0, ``//`` is the floor division operator and ``/`` the
		true division operator.  The ``true_divide(x1, x2)`` function is
		equivalent to true division in Python.
		
		Examples
		--------
		>>> x = np.arange(5)
		>>> np.true_divide(x, 4)
		array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
		
		>>> x/4
		array([0, 0, 0, 0, 1])
		>>> x//4
		array([0, 0, 0, 0, 1])
		
		>>> from __future__ import division
		>>> x/4
		array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
		>>> x//4
		array([0, 0, 0, 0, 1])
	**/
	static public function divide(args:haxe.extern.Rest<Dynamic>):Dynamic;
	static public var division : Dynamic;
	/**
		divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return element-wise quotient and remainder simultaneously.
		
		.. versionadded:: 1.13.0
		
		``np.divmod(x, y)`` is equivalent to ``(x // y, x % y)``, but faster
		because it avoids redundant work. It is used to implement the Python
		built-in function ``divmod`` on NumPy arrays.
		
		Parameters
		----------
		x1 : array_like
		    Dividend array.
		x2 : array_like
		    Divisor array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out1 : ndarray
		    Element-wise quotient resulting from floor division.
		    This is a scalar if both `x1` and `x2` are scalars.
		out2 : ndarray
		    Element-wise remainder from floor division.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		floor_divide : Equivalent to Python's ``//`` operator.
		remainder : Equivalent to Python's ``%`` operator.
		modf : Equivalent to ``divmod(x, 1)`` for positive ``x`` with the return
		       values switched.
		
		Examples
		--------
		>>> np.divmod(np.arange(5), 3)
		(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))
	**/
	static public function divmod(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		dot(a, b, out=None)
		
		Dot product of two arrays. Specifically,
		
		- If both `a` and `b` are 1-D arrays, it is inner product of vectors
		  (without complex conjugation).
		
		- If both `a` and `b` are 2-D arrays, it is matrix multiplication,
		  but using :func:`matmul` or ``a @ b`` is preferred.
		
		- If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`
		  and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.
		
		- If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
		  the last axis of `a` and `b`.
		
		- If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a
		  sum product over the last axis of `a` and the second-to-last axis of `b`::
		
		    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
		
		Parameters
		----------
		a : array_like
		    First argument.
		b : array_like
		    Second argument.
		out : ndarray, optional
		    Output argument. This must have the exact kind that would be returned
		    if it was not used. In particular, it must have the right type, must be
		    C-contiguous, and its dtype must be the dtype that would be returned
		    for `dot(a,b)`. This is a performance feature. Therefore, if these
		    conditions are not met, an exception is raised, instead of attempting
		    to be flexible.
		
		Returns
		-------
		output : ndarray
		    Returns the dot product of `a` and `b`.  If `a` and `b` are both
		    scalars or both 1-D arrays then a scalar is returned; otherwise
		    an array is returned.
		    If `out` is given, then it is returned.
		
		Raises
		------
		ValueError
		    If the last dimension of `a` is not the same size as
		    the second-to-last dimension of `b`.
		
		See Also
		--------
		vdot : Complex-conjugating dot product.
		tensordot : Sum products over arbitrary axes.
		einsum : Einstein summation convention.
		matmul : '@' operator as method with out parameter.
		
		Examples
		--------
		>>> np.dot(3, 4)
		12
		
		Neither argument is complex-conjugated:
		
		>>> np.dot([2j, 3j], [2j, 3j])
		(-13+0j)
		
		For 2-D arrays it is the matrix product:
		
		>>> a = [[1, 0], [0, 1]]
		>>> b = [[4, 1], [2, 2]]
		>>> np.dot(a, b)
		array([[4, 1],
		       [2, 2]])
		
		>>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
		>>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
		>>> np.dot(a, b)[2,3,2,1,2,2]
		499128
		>>> sum(a[2,3,2,:] * b[1,2,:,2])
		499128
	**/
	static public function dot(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return a sequence of equally spaced Matplotlib dates.
		
		The dates start at *dstart* and reach up to, but not including *dend*.
		They are spaced by *delta*.
		
		Parameters
		----------
		dstart, dend : `~datetime.datetime`
		    The date limits.
		delta : `datetime.timedelta`
		    Spacing of the dates.
		
		Returns
		-------
		drange : `numpy.array`
		    A list floats representing Matplotlib dates.
	**/
	static public function drange(dstart:Dynamic, dend:Dynamic, delta:Dynamic):Dynamic;
	/**
		Redraw the current figure.
		
		This is used to update a figure that has been altered, but not
		automatically re-drawn.  If interactive mode is on (:func:`.ion()`), this
		should be only rarely needed, but there may be ways to modify the state of
		a figure without marking it as `stale`.  Please report these cases as
		bugs.
		
		A more object-oriented alternative, given any
		:class:`~matplotlib.figure.Figure` instance, :attr:`fig`, that
		was created using a :mod:`~matplotlib.pyplot` function, is::
		
		    fig.canvas.draw_idle()
	**/
	static public function draw():Dynamic;
	/**
		Redraw all figures registered with the pyplot
		state machine.
	**/
	static public function draw_all(?force:Dynamic):Dynamic;
	static public function draw_if_interactive():Dynamic;
	/**
		Split array into multiple sub-arrays along the 3rd axis (depth).
		
		Please refer to the `split` documentation.  `dsplit` is equivalent
		to `split` with ``axis=2``, the array is always split along the third
		axis provided the array dimension is greater than or equal to 3.
		
		See Also
		--------
		split : Split an array into multiple sub-arrays of equal size.
		
		Examples
		--------
		>>> x = np.arange(16.0).reshape(2, 2, 4)
		>>> x
		array([[[  0.,   1.,   2.,   3.],
		        [  4.,   5.,   6.,   7.]],
		       [[  8.,   9.,  10.,  11.],
		        [ 12.,  13.,  14.,  15.]]])
		>>> np.dsplit(x, 2)
		[array([[[  0.,   1.],
		        [  4.,   5.]],
		       [[  8.,   9.],
		        [ 12.,  13.]]]),
		 array([[[  2.,   3.],
		        [  6.,   7.]],
		       [[ 10.,  11.],
		        [ 14.,  15.]]])]
		>>> np.dsplit(x, np.array([3, 6]))
		[array([[[  0.,   1.,   2.],
		        [  4.,   5.,   6.]],
		       [[  8.,   9.,  10.],
		        [ 12.,  13.,  14.]]]),
		 array([[[  3.],
		        [  7.]],
		       [[ 11.],
		        [ 15.]]]),
		 array([], dtype=float64)]
	**/
	static public function dsplit(ary:Dynamic, indices_or_sections:Dynamic):Dynamic;
	/**
		Stack arrays in sequence depth wise (along third axis).
		
		This is equivalent to concatenation along the third axis after 2-D arrays
		of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
		`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
		`dsplit`.
		
		This function makes most sense for arrays with up to 3 dimensions. For
		instance, for pixel-data with a height (first axis), width (second axis),
		and r/g/b channels (third axis). The functions `concatenate`, `stack` and
		`block` provide more general stacking and concatenation operations.
		
		Parameters
		----------
		tup : sequence of arrays
		    The arrays must have the same shape along all but the third axis.
		    1-D or 2-D arrays must have the same shape.
		
		Returns
		-------
		stacked : ndarray
		    The array formed by stacking the given arrays, will be at least 3-D.
		
		See Also
		--------
		stack : Join a sequence of arrays along a new axis.
		vstack : Stack along first axis.
		hstack : Stack along second axis.
		concatenate : Join a sequence of arrays along an existing axis.
		dsplit : Split array along third axis.
		
		Examples
		--------
		>>> a = np.array((1,2,3))
		>>> b = np.array((2,3,4))
		>>> np.dstack((a,b))
		array([[[1, 2],
		        [2, 3],
		        [3, 4]]])
		
		>>> a = np.array([[1],[2],[3]])
		>>> b = np.array([[2],[3],[4]])
		>>> np.dstack((a,b))
		array([[[1, 2]],
		       [[2, 3]],
		       [[3, 4]]])
	**/
	static public function dstack(tup:Dynamic):Dynamic;
	static public var e : Dynamic;
	/**
		The differences between consecutive elements of an array.
		
		Parameters
		----------
		ary : array_like
		    If necessary, will be flattened before the differences are taken.
		to_end : array_like, optional
		    Number(s) to append at the end of the returned differences.
		to_begin : array_like, optional
		    Number(s) to prepend at the beginning of the returned differences.
		
		Returns
		-------
		ediff1d : ndarray
		    The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.
		
		See Also
		--------
		diff, gradient
		
		Notes
		-----
		When applied to masked arrays, this function drops the mask information
		if the `to_begin` and/or `to_end` parameters are used.
		
		Examples
		--------
		>>> x = np.array([1, 2, 4, 7, 0])
		>>> np.ediff1d(x)
		array([ 1,  2,  3, -7])
		
		>>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
		array([-99,   1,   2,   3,  -7,  88,  99])
		
		The returned array is always 1D.
		
		>>> y = [[1, 2, 4], [1, 6, 24]]
		>>> np.ediff1d(y)
		array([ 1,  2, -3,  5, 18])
	**/
	static public function ediff1d(ary:Dynamic, ?to_end:Dynamic, ?to_begin:Dynamic):Dynamic;
	/**
		Compute the eigenvalues and right eigenvectors of a square array.
		
		Parameters
		----------
		a : (..., M, M) array
		    Matrices for which the eigenvalues and right eigenvectors will
		    be computed
		
		Returns
		-------
		w : (..., M) array
		    The eigenvalues, each repeated according to its multiplicity.
		    The eigenvalues are not necessarily ordered. The resulting
		    array will be of complex type, unless the imaginary part is
		    zero in which case it will be cast to a real type. When `a`
		    is real the resulting eigenvalues will be real (0 imaginary
		    part) or occur in conjugate pairs
		
		v : (..., M, M) array
		    The normalized (unit "length") eigenvectors, such that the
		    column ``v[:,i]`` is the eigenvector corresponding to the
		    eigenvalue ``w[i]``.
		
		Raises
		------
		LinAlgError
		    If the eigenvalue computation does not converge.
		
		See Also
		--------
		eigvals : eigenvalues of a non-symmetric array.
		
		eigh : eigenvalues and eigenvectors of a real symmetric or complex 
		       Hermitian (conjugate symmetric) array.
		
		eigvalsh : eigenvalues of a real symmetric or complex Hermitian
		           (conjugate symmetric) array.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		This is implemented using the _geev LAPACK routines which compute
		the eigenvalues and eigenvectors of general square arrays.
		
		The number `w` is an eigenvalue of `a` if there exists a vector
		`v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and
		`v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``
		for :math:`i \in \{0,...,M-1\}`.
		
		The array `v` of eigenvectors may not be of maximum rank, that is, some
		of the columns may be linearly dependent, although round-off error may
		obscure that fact. If the eigenvalues are all different, then theoretically
		the eigenvectors are linearly independent. Likewise, the (complex-valued)
		matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
		if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate
		transpose of `a`.
		
		Finally, it is emphasized that `v` consists of the *right* (as in
		right-hand side) eigenvectors of `a`.  A vector `y` satisfying
		``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*
		eigenvector of `a`, and, in general, the left and right eigenvectors
		of a matrix are not necessarily the (perhaps conjugate) transposes
		of each other.
		
		References
		----------
		G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
		Academic Press, Inc., 1980, Various pp.
		
		Examples
		--------
		>>> from numpy import linalg as LA
		
		(Almost) trivial example with real e-values and e-vectors.
		
		>>> w, v = LA.eig(np.diag((1, 2, 3)))
		>>> w; v
		array([ 1.,  2.,  3.])
		array([[ 1.,  0.,  0.],
		       [ 0.,  1.,  0.],
		       [ 0.,  0.,  1.]])
		
		Real matrix possessing complex e-values and e-vectors; note that the
		e-values are complex conjugates of each other.
		
		>>> w, v = LA.eig(np.array([[1, -1], [1, 1]]))
		>>> w; v
		array([ 1. + 1.j,  1. - 1.j])
		array([[ 0.70710678+0.j        ,  0.70710678+0.j        ],
		       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]])
		
		Complex-valued matrix with real e-values (but complex-valued e-vectors);
		note that a.conj().T = a, i.e., a is Hermitian.
		
		>>> a = np.array([[1, 1j], [-1j, 1]])
		>>> w, v = LA.eig(a)
		>>> w; v
		array([  2.00000000e+00+0.j,   5.98651912e-36+0.j]) # i.e., {2, 0}
		array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ],
		       [ 0.70710678+0.j        ,  0.00000000+0.70710678j]])
		
		Be careful about round-off error!
		
		>>> a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
		>>> # Theor. e-values are 1 +/- 1e-9
		>>> w, v = LA.eig(a)
		>>> w; v
		array([ 1.,  1.])
		array([[ 1.,  0.],
		       [ 0.,  1.]])
	**/
	static public function eig(a:Dynamic):Dynamic;
	/**
		Return the eigenvalues and eigenvectors of a complex Hermitian
		(conjugate symmetric) or a real symmetric matrix.
		
		Returns two objects, a 1-D array containing the eigenvalues of `a`, and
		a 2-D square array or matrix (depending on the input type) of the
		corresponding eigenvectors (in columns).
		
		Parameters
		----------
		a : (..., M, M) array
		    Hermitian or real symmetric matrices whose eigenvalues and
		    eigenvectors are to be computed.
		UPLO : {'L', 'U'}, optional
		    Specifies whether the calculation is done with the lower triangular
		    part of `a` ('L', default) or the upper triangular part ('U').
		    Irrespective of this value only the real parts of the diagonal will
		    be considered in the computation to preserve the notion of a Hermitian
		    matrix. It therefore follows that the imaginary part of the diagonal
		    will always be treated as zero.
		
		Returns
		-------
		w : (..., M) ndarray
		    The eigenvalues in ascending order, each repeated according to
		    its multiplicity.
		v : {(..., M, M) ndarray, (..., M, M) matrix}
		    The column ``v[:, i]`` is the normalized eigenvector corresponding
		    to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
		    a matrix object.
		
		Raises
		------
		LinAlgError
		    If the eigenvalue computation does not converge.
		
		See Also
		--------
		eigvalsh : eigenvalues of real symmetric or complex Hermitian
		           (conjugate symmetric) arrays.
		eig : eigenvalues and right eigenvectors for non-symmetric arrays.
		eigvals : eigenvalues of non-symmetric arrays.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
		_heevd
		
		The eigenvalues of real symmetric or complex Hermitian matrices are
		always real. [1]_ The array `v` of (column) eigenvectors is unitary
		and `a`, `w`, and `v` satisfy the equations
		``dot(a, v[:, i]) = w[i] * v[:, i]``.
		
		References
		----------
		.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
		       FL, Academic Press, Inc., 1980, pg. 222.
		
		Examples
		--------
		>>> from numpy import linalg as LA
		>>> a = np.array([[1, -2j], [2j, 5]])
		>>> a
		array([[ 1.+0.j,  0.-2.j],
		       [ 0.+2.j,  5.+0.j]])
		>>> w, v = LA.eigh(a)
		>>> w; v
		array([ 0.17157288,  5.82842712])
		array([[-0.92387953+0.j        , -0.38268343+0.j        ],
		       [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])
		
		>>> np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
		array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j])
		>>> np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
		array([ 0.+0.j,  0.+0.j])
		
		>>> A = np.matrix(a) # what happens if input is a matrix object
		>>> A
		matrix([[ 1.+0.j,  0.-2.j],
		        [ 0.+2.j,  5.+0.j]])
		>>> w, v = LA.eigh(A)
		>>> w; v
		array([ 0.17157288,  5.82842712])
		matrix([[-0.92387953+0.j        , -0.38268343+0.j        ],
		        [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])
		
		>>> # demonstrate the treatment of the imaginary part of the diagonal
		>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
		>>> a
		array([[ 5.+2.j,  9.-2.j],
		       [ 0.+2.j,  2.-1.j]])
		>>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
		>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
		>>> b
		array([[ 5.+0.j,  0.-2.j],
		       [ 0.+2.j,  2.+0.j]])
		>>> wa, va = LA.eigh(a)
		>>> wb, vb = LA.eig(b)
		>>> wa; wb
		array([ 1.,  6.])
		array([ 6.+0.j,  1.+0.j])
		>>> va; vb
		array([[-0.44721360-0.j        , -0.89442719+0.j        ],
		       [ 0.00000000+0.89442719j,  0.00000000-0.4472136j ]])
		array([[ 0.89442719+0.j       ,  0.00000000-0.4472136j],
		       [ 0.00000000-0.4472136j,  0.89442719+0.j       ]])
	**/
	static public function eigh(a:Dynamic, ?UPLO:Dynamic):Dynamic;
	/**
		Compute the eigenvalues of a general matrix.
		
		Main difference between `eigvals` and `eig`: the eigenvectors aren't
		returned.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    A complex- or real-valued matrix whose eigenvalues will be computed.
		
		Returns
		-------
		w : (..., M,) ndarray
		    The eigenvalues, each repeated according to its multiplicity.
		    They are not necessarily ordered, nor are they necessarily
		    real for real matrices.
		
		Raises
		------
		LinAlgError
		    If the eigenvalue computation does not converge.
		
		See Also
		--------
		eig : eigenvalues and right eigenvectors of general arrays
		eigvalsh : eigenvalues of real symmetric or complex Hermitian 
		           (conjugate symmetric) arrays.
		eigh : eigenvalues and eigenvectors of real symmetric or complex
		       Hermitian (conjugate symmetric) arrays.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		This is implemented using the _geev LAPACK routines which compute
		the eigenvalues and eigenvectors of general square arrays.
		
		Examples
		--------
		Illustration, using the fact that the eigenvalues of a diagonal matrix
		are its diagonal elements, that multiplying a matrix on the left
		by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
		of `Q`), preserves the eigenvalues of the "middle" matrix.  In other words,
		if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
		``A``:
		
		>>> from numpy import linalg as LA
		>>> x = np.random.random()
		>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
		>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
		(1.0, 1.0, 0.0)
		
		Now multiply a diagonal matrix by Q on one side and by Q.T on the other:
		
		>>> D = np.diag((-1,1))
		>>> LA.eigvals(D)
		array([-1.,  1.])
		>>> A = np.dot(Q, D)
		>>> A = np.dot(A, Q.T)
		>>> LA.eigvals(A)
		array([ 1., -1.])
	**/
	static public function eigvals(a:Dynamic):Dynamic;
	/**
		Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
		
		Main difference from eigh: the eigenvectors are not computed.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    A complex- or real-valued matrix whose eigenvalues are to be
		    computed.
		UPLO : {'L', 'U'}, optional
		    Specifies whether the calculation is done with the lower triangular
		    part of `a` ('L', default) or the upper triangular part ('U').
		    Irrespective of this value only the real parts of the diagonal will
		    be considered in the computation to preserve the notion of a Hermitian
		    matrix. It therefore follows that the imaginary part of the diagonal
		    will always be treated as zero.
		
		Returns
		-------
		w : (..., M,) ndarray
		    The eigenvalues in ascending order, each repeated according to
		    its multiplicity.
		
		Raises
		------
		LinAlgError
		    If the eigenvalue computation does not converge.
		
		See Also
		--------
		eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
		       (conjugate symmetric) arrays.
		eigvals : eigenvalues of general real or complex arrays.
		eig : eigenvalues and right eigenvectors of general real or complex
		      arrays.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		The eigenvalues are computed using LAPACK routines _syevd, _heevd
		
		Examples
		--------
		>>> from numpy import linalg as LA
		>>> a = np.array([[1, -2j], [2j, 5]])
		>>> LA.eigvalsh(a)
		array([ 0.17157288,  5.82842712])
		
		>>> # demonstrate the treatment of the imaginary part of the diagonal
		>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
		>>> a
		array([[ 5.+2.j,  9.-2.j],
		       [ 0.+2.j,  2.-1.j]])
		>>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
		>>> # with:
		>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
		>>> b
		array([[ 5.+0.j,  0.-2.j],
		       [ 0.+2.j,  2.+0.j]])
		>>> wa = LA.eigvalsh(a)
		>>> wb = LA.eigvals(b)
		>>> wa; wb
		array([ 1.,  6.])
		array([ 6.+0.j,  1.+0.j])
	**/
	static public function eigvalsh(a:Dynamic, ?UPLO:Dynamic):Dynamic;
	/**
		einsum(subscripts, *operands, out=None, dtype=None, order='K',
		       casting='safe', optimize=False)
		
		Evaluates the Einstein summation convention on the operands.
		
		Using the Einstein summation convention, many common multi-dimensional,
		linear algebraic array operations can be represented in a simple fashion.
		In *implicit* mode `einsum` computes these values.
		
		In *explicit* mode, `einsum` provides further flexibility to compute
		other array operations that might not be considered classical Einstein
		summation operations, by disabling, or forcing summation over specified
		subscript labels.
		
		See the notes and examples for clarification.
		
		Parameters
		----------
		subscripts : str
		    Specifies the subscripts for summation as comma separated list of
		    subscript labels. An implicit (classical Einstein summation)
		    calculation is performed unless the explicit indicator '->' is
		    included as well as subscript labels of the precise output form.
		operands : list of array_like
		    These are the arrays for the operation.
		out : ndarray, optional
		    If provided, the calculation is done into this array.
		dtype : {data-type, None}, optional
		    If provided, forces the calculation to use the data type specified.
		    Note that you may have to also give a more liberal `casting`
		    parameter to allow the conversions. Default is None.
		order : {'C', 'F', 'A', 'K'}, optional
		    Controls the memory layout of the output. 'C' means it should
		    be C contiguous. 'F' means it should be Fortran contiguous,
		    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
		    'K' means it should be as close to the layout as the inputs as
		    is possible, including arbitrarily permuted axes.
		    Default is 'K'.
		casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
		    Controls what kind of data casting may occur.  Setting this to
		    'unsafe' is not recommended, as it can adversely affect accumulations.
		
		      * 'no' means the data types should not be cast at all.
		      * 'equiv' means only byte-order changes are allowed.
		      * 'safe' means only casts which can preserve values are allowed.
		      * 'same_kind' means only safe casts or casts within a kind,
		        like float64 to float32, are allowed.
		      * 'unsafe' means any data conversions may be done.
		
		    Default is 'safe'.
		optimize : {False, True, 'greedy', 'optimal'}, optional
		    Controls if intermediate optimization should occur. No optimization
		    will occur if False and True will default to the 'greedy' algorithm.
		    Also accepts an explicit contraction list from the ``np.einsum_path``
		    function. See ``np.einsum_path`` for more details. Defaults to False.
		
		Returns
		-------
		output : ndarray
		    The calculation based on the Einstein summation convention.
		
		See Also
		--------
		einsum_path, dot, inner, outer, tensordot, linalg.multi_dot
		
		Notes
		-----
		.. versionadded:: 1.6.0
		
		The Einstein summation convention can be used to compute
		many multi-dimensional, linear algebraic array operations. `einsum`
		provides a succinct way of representing these.
		
		A non-exhaustive list of these operations,
		which can be computed by `einsum`, is shown below along with examples:
		
		* Trace of an array, :py:func:`numpy.trace`.
		* Return a diagonal, :py:func:`numpy.diag`.
		* Array axis summations, :py:func:`numpy.sum`.
		* Transpositions and permutations, :py:func:`numpy.transpose`.
		* Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.
		* Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.
		* Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.
		* Tensor contractions, :py:func:`numpy.tensordot`.
		* Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.
		
		The subscripts string is a comma-separated list of subscript labels,
		where each label refers to a dimension of the corresponding operand.
		Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``
		is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label
		appears only once, it is not summed, so ``np.einsum('i', a)`` produces a
		view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``
		describes traditional matrix multiplication and is equivalent to
		:py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one
		operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent
		to :py:func:`np.trace(a) <numpy.trace>`.
		
		In *implicit mode*, the chosen subscripts are important
		since the axes of the output are reordered alphabetically.  This
		means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
		``np.einsum('ji', a)`` takes its transpose. Additionally,
		``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,
		``np.einsum('ij,jh', a, b)`` returns the transpose of the
		multiplication since subscript 'h' precedes subscript 'i'.
		
		In *explicit mode* the output can be directly controlled by
		specifying output subscript labels.  This requires the
		identifier '->' as well as the list of output subscript labels.
		This feature increases the flexibility of the function since
		summing can be disabled or forced when required. The call
		``np.einsum('i->', a)`` is like :py:func:`np.sum(a, axis=-1) <numpy.sum>`,
		and ``np.einsum('ii->i', a)`` is like :py:func:`np.diag(a) <numpy.diag>`.
		The difference is that `einsum` does not allow broadcasting by default.
		Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the
		order of the output subscript labels and therefore returns matrix
		multiplication, unlike the example above in implicit mode.
		
		To enable and control broadcasting, use an ellipsis.  Default
		NumPy-style broadcasting is done by adding an ellipsis
		to the left of each term, like ``np.einsum('...ii->...i', a)``.
		To take the trace along the first and last axes,
		you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
		product with the left-most indices instead of rightmost, one can do
		``np.einsum('ij...,jk...->ik...', a, b)``.
		
		When there is only one operand, no axes are summed, and no output
		parameter is provided, a view into the operand is returned instead
		of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``
		produces a view (changed in version 1.10.0).
		
		`einsum` also provides an alternative way to provide the subscripts
		and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.
		If the output shape is not provided in this format `einsum` will be
		calculated in implicit mode, otherwise it will be performed explicitly.
		The examples below have corresponding `einsum` calls with the two
		parameter methods.
		
		.. versionadded:: 1.10.0
		
		Views returned from einsum are now writeable whenever the input array
		is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now
		have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`
		and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal
		of a 2D array.
		
		.. versionadded:: 1.12.0
		
		Added the ``optimize`` argument which will optimize the contraction order
		of an einsum expression. For a contraction with three or more operands this
		can greatly increase the computational efficiency at the cost of a larger
		memory footprint during computation.
		
		Typically a 'greedy' algorithm is applied which empirical tests have shown
		returns the optimal path in the majority of cases. In some cases 'optimal'
		will return the superlative path through a more expensive, exhaustive search.
		For iterative calculations it may be advisable to calculate the optimal path
		once and reuse that path by supplying it as an argument. An example is given
		below.
		
		See :py:func:`numpy.einsum_path` for more details.
		
		Examples
		--------
		>>> a = np.arange(25).reshape(5,5)
		>>> b = np.arange(5)
		>>> c = np.arange(6).reshape(2,3)
		
		Trace of a matrix:
		
		>>> np.einsum('ii', a)
		60
		>>> np.einsum(a, [0,0])
		60
		>>> np.trace(a)
		60
		
		Extract the diagonal (requires explicit form):
		
		>>> np.einsum('ii->i', a)
		array([ 0,  6, 12, 18, 24])
		>>> np.einsum(a, [0,0], [0])
		array([ 0,  6, 12, 18, 24])
		>>> np.diag(a)
		array([ 0,  6, 12, 18, 24])
		
		Sum over an axis (requires explicit form):
		
		>>> np.einsum('ij->i', a)
		array([ 10,  35,  60,  85, 110])
		>>> np.einsum(a, [0,1], [0])
		array([ 10,  35,  60,  85, 110])
		>>> np.sum(a, axis=1)
		array([ 10,  35,  60,  85, 110])
		
		For higher dimensional arrays summing a single axis can be done with ellipsis:
		
		>>> np.einsum('...j->...', a)
		array([ 10,  35,  60,  85, 110])
		>>> np.einsum(a, [Ellipsis,1], [Ellipsis])
		array([ 10,  35,  60,  85, 110])
		
		Compute a matrix transpose, or reorder any number of axes:
		
		>>> np.einsum('ji', c)
		array([[0, 3],
		       [1, 4],
		       [2, 5]])
		>>> np.einsum('ij->ji', c)
		array([[0, 3],
		       [1, 4],
		       [2, 5]])
		>>> np.einsum(c, [1,0])
		array([[0, 3],
		       [1, 4],
		       [2, 5]])
		>>> np.transpose(c)
		array([[0, 3],
		       [1, 4],
		       [2, 5]])
		
		Vector inner products:
		
		>>> np.einsum('i,i', b, b)
		30
		>>> np.einsum(b, [0], b, [0])
		30
		>>> np.inner(b,b)
		30
		
		Matrix vector multiplication:
		
		>>> np.einsum('ij,j', a, b)
		array([ 30,  80, 130, 180, 230])
		>>> np.einsum(a, [0,1], b, [1])
		array([ 30,  80, 130, 180, 230])
		>>> np.dot(a, b)
		array([ 30,  80, 130, 180, 230])
		>>> np.einsum('...j,j', a, b)
		array([ 30,  80, 130, 180, 230])
		
		Broadcasting and scalar multiplication:
		
		>>> np.einsum('..., ...', 3, c)
		array([[ 0,  3,  6],
		       [ 9, 12, 15]])
		>>> np.einsum(',ij', 3, c)
		array([[ 0,  3,  6],
		       [ 9, 12, 15]])
		>>> np.einsum(3, [Ellipsis], c, [Ellipsis])
		array([[ 0,  3,  6],
		       [ 9, 12, 15]])
		>>> np.multiply(3, c)
		array([[ 0,  3,  6],
		       [ 9, 12, 15]])
		
		Vector outer product:
		
		>>> np.einsum('i,j', np.arange(2)+1, b)
		array([[0, 1, 2, 3, 4],
		       [0, 2, 4, 6, 8]])
		>>> np.einsum(np.arange(2)+1, [0], b, [1])
		array([[0, 1, 2, 3, 4],
		       [0, 2, 4, 6, 8]])
		>>> np.outer(np.arange(2)+1, b)
		array([[0, 1, 2, 3, 4],
		       [0, 2, 4, 6, 8]])
		
		Tensor contraction:
		
		>>> a = np.arange(60.).reshape(3,4,5)
		>>> b = np.arange(24.).reshape(4,3,2)
		>>> np.einsum('ijk,jil->kl', a, b)
		array([[ 4400.,  4730.],
		       [ 4532.,  4874.],
		       [ 4664.,  5018.],
		       [ 4796.,  5162.],
		       [ 4928.,  5306.]])
		>>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
		array([[ 4400.,  4730.],
		       [ 4532.,  4874.],
		       [ 4664.,  5018.],
		       [ 4796.,  5162.],
		       [ 4928.,  5306.]])
		>>> np.tensordot(a,b, axes=([1,0],[0,1]))
		array([[ 4400.,  4730.],
		       [ 4532.,  4874.],
		       [ 4664.,  5018.],
		       [ 4796.,  5162.],
		       [ 4928.,  5306.]])
		
		Writeable returned arrays (since version 1.10.0):
		
		>>> a = np.zeros((3, 3))
		>>> np.einsum('ii->i', a)[:] = 1
		>>> a
		array([[ 1.,  0.,  0.],
		       [ 0.,  1.,  0.],
		       [ 0.,  0.,  1.]])
		
		Example of ellipsis use:
		
		>>> a = np.arange(6).reshape((3,2))
		>>> b = np.arange(12).reshape((4,3))
		>>> np.einsum('ki,jk->ij', a, b)
		array([[10, 28, 46, 64],
		       [13, 40, 67, 94]])
		>>> np.einsum('ki,...k->i...', a, b)
		array([[10, 28, 46, 64],
		       [13, 40, 67, 94]])
		>>> np.einsum('k...,jk', a, b)
		array([[10, 28, 46, 64],
		       [13, 40, 67, 94]])
		
		Chained array operations. For more complicated contractions, speed ups
		might be achieved by repeatedly computing a 'greedy' path or pre-computing the
		'optimal' path and repeatedly applying it, using an
		`einsum_path` insertion (since version 1.12.0). Performance improvements can be
		particularly significant with larger arrays:
		
		>>> a = np.ones(64).reshape(2,4,8)
		# Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)
		>>> for iteration in range(500):
		...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)
		# Sub-optimal `einsum` (due to repeated path calculation time): ~330ms
		>>> for iteration in range(500):
		...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')
		# Greedy `einsum` (faster optimal path approximation): ~160ms
		>>> for iteration in range(500):
		...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')
		# Optimal `einsum` (best usage pattern in some use cases): ~110ms
		>>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]
		>>> for iteration in range(500):
		...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)
	**/
	static public function einsum(?operands:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		einsum_path(subscripts, *operands, optimize='greedy')
		
		Evaluates the lowest cost contraction order for an einsum expression by
		considering the creation of intermediate arrays.
		
		Parameters
		----------
		subscripts : str
		    Specifies the subscripts for summation.
		*operands : list of array_like
		    These are the arrays for the operation.
		optimize : {bool, list, tuple, 'greedy', 'optimal'}
		    Choose the type of path. If a tuple is provided, the second argument is
		    assumed to be the maximum intermediate size created. If only a single
		    argument is provided the largest input or output array size is used
		    as a maximum intermediate size.
		
		    * if a list is given that starts with ``einsum_path``, uses this as the
		      contraction path
		    * if False no optimization is taken
		    * if True defaults to the 'greedy' algorithm
		    * 'optimal' An algorithm that combinatorially explores all possible
		      ways of contracting the listed tensors and choosest the least costly
		      path. Scales exponentially with the number of terms in the
		      contraction.
		    * 'greedy' An algorithm that chooses the best pair contraction
		      at each step. Effectively, this algorithm searches the largest inner,
		      Hadamard, and then outer products at each step. Scales cubically with
		      the number of terms in the contraction. Equivalent to the 'optimal'
		      path for most contractions.
		
		    Default is 'greedy'.
		
		Returns
		-------
		path : list of tuples
		    A list representation of the einsum path.
		string_repr : str
		    A printable representation of the einsum path.
		
		Notes
		-----
		The resulting path indicates which terms of the input contraction should be
		contracted first, the result of this contraction is then appended to the
		end of the contraction list. This list can then be iterated over until all
		intermediate contractions are complete.
		
		See Also
		--------
		einsum, linalg.multi_dot
		
		Examples
		--------
		
		We can begin with a chain dot example. In this case, it is optimal to
		contract the ``b`` and ``c`` tensors first as represented by the first
		element of the path ``(1, 2)``. The resulting tensor is added to the end
		of the contraction and the remaining contraction ``(0, 1)`` is then
		completed.
		
		>>> a = np.random.rand(2, 2)
		>>> b = np.random.rand(2, 5)
		>>> c = np.random.rand(5, 2)
		>>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
		>>> print(path_info[0])
		['einsum_path', (1, 2), (0, 1)]
		>>> print(path_info[1])
		  Complete contraction:  ij,jk,kl->il
		         Naive scaling:  4
		     Optimized scaling:  3
		      Naive FLOP count:  1.600e+02
		  Optimized FLOP count:  5.600e+01
		   Theoretical speedup:  2.857
		  Largest intermediate:  4.000e+00 elements
		-------------------------------------------------------------------------
		scaling                  current                                remaining
		-------------------------------------------------------------------------
		   3                   kl,jk->jl                                ij,jl->il
		   3                   jl,ij->il                                   il->il
		
		
		A more complex index transformation example.
		
		>>> I = np.random.rand(10, 10, 10, 10)
		>>> C = np.random.rand(10, 10)
		>>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
		                               optimize='greedy')
		
		>>> print(path_info[0])
		['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
		>>> print(path_info[1])
		  Complete contraction:  ea,fb,abcd,gc,hd->efgh
		         Naive scaling:  8
		     Optimized scaling:  5
		      Naive FLOP count:  8.000e+08
		  Optimized FLOP count:  8.000e+05
		   Theoretical speedup:  1000.000
		  Largest intermediate:  1.000e+04 elements
		--------------------------------------------------------------------------
		scaling                  current                                remaining
		--------------------------------------------------------------------------
		   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
		   5               bcde,fb->cdef                         gc,hd,cdef->efgh
		   5               cdef,gc->defg                            hd,defg->efgh
		   5               defg,hd->efgh                               efgh->efgh
	**/
	static public function einsum_path(?operands:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		empty(shape, dtype=float, order='C')
		
		Return a new array of given shape and type, without initializing entries.
		
		Parameters
		----------
		shape : int or tuple of int
		    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
		dtype : data-type, optional
		    Desired output data-type for the array, e.g, `numpy.int8`. Default is
		    `numpy.float64`.
		order : {'C', 'F'}, optional, default: 'C'
		    Whether to store multi-dimensional data in row-major
		    (C-style) or column-major (Fortran-style) order in
		    memory.
		
		Returns
		-------
		out : ndarray
		    Array of uninitialized (arbitrary) data of the given shape, dtype, and
		    order.  Object arrays will be initialized to None.
		
		See Also
		--------
		empty_like : Return an empty array with shape and type of input.
		ones : Return a new array setting values to one.
		zeros : Return a new array setting values to zero.
		full : Return a new array of given shape filled with value.
		
		
		Notes
		-----
		`empty`, unlike `zeros`, does not set the array values to zero,
		and may therefore be marginally faster.  On the other hand, it requires
		the user to manually set all the values in the array, and should be
		used with caution.
		
		Examples
		--------
		>>> np.empty([2, 2])
		array([[ -9.74499359e+001,   6.69583040e-309],
		       [  2.13182611e-314,   3.06959433e-309]])         #random
		
		>>> np.empty([2, 2], dtype=int)
		array([[-1073741821, -1067949133],
		       [  496041986,    19249760]])                     #random
	**/
	static public function empty(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		empty_like(prototype, dtype=None, order='K', subok=True)
		
		Return a new array with the same shape and type as a given array.
		
		Parameters
		----------
		prototype : array_like
		    The shape and data-type of `prototype` define these same attributes
		    of the returned array.
		dtype : data-type, optional
		    Overrides the data type of the result.
		
		    .. versionadded:: 1.6.0
		order : {'C', 'F', 'A', or 'K'}, optional
		    Overrides the memory layout of the result. 'C' means C-order,
		    'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
		    contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
		    as closely as possible.
		
		    .. versionadded:: 1.6.0
		subok : bool, optional.
		    If True, then the newly created array will use the sub-class
		    type of 'a', otherwise it will be a base-class array. Defaults
		    to True.
		
		Returns
		-------
		out : ndarray
		    Array of uninitialized (arbitrary) data with the same
		    shape and type as `prototype`.
		
		See Also
		--------
		ones_like : Return an array of ones with shape and type of input.
		zeros_like : Return an array of zeros with shape and type of input.
		full_like : Return a new array with shape of input filled with value.
		empty : Return a new uninitialized array.
		
		Notes
		-----
		This function does *not* initialize the returned array; to do that use
		`zeros_like` or `ones_like` instead.  It may be marginally faster than
		the functions that do set the array values.
		
		Examples
		--------
		>>> a = ([1,2,3], [4,5,6])                         # a is array-like
		>>> np.empty_like(a)
		array([[-1073741821, -1073741821,           3],    #random
		       [          0,           0, -1073741821]])
		>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
		>>> np.empty_like(a)
		array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random
		       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
	**/
	static public function empty_like(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Convert an epoch or sequence of epochs to the new date format,
		that is days since 0001.
	**/
	static public function epoch2num(e:Dynamic):Dynamic;
	/**
		equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return (x1 == x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays of the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		not_equal, greater_equal, less_equal, greater, less
		
		Examples
		--------
		>>> np.equal([0, 1, 3], np.arange(3))
		array([ True,  True, False])
		
		What is compared are values, not types. So an int (1) and an array of
		length one can evaluate as True:
		
		>>> np.equal(1, np.ones(1))
		array([ True])
	**/
	static public function equal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Plot y versus x as lines and/or markers with attached errorbars.
		
		*x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
		sizes. By default, this draws the data markers/lines as well the
		errorbars. Use fmt='none' to draw errorbars without any data markers.
		
		Parameters
		----------
		x, y : scalar or array-like
		    The data positions.
		
		xerr, yerr : scalar or array-like, shape(N,) or shape(2,N), optional
		    The errorbar sizes:
		
		    - scalar: Symmetric +/- values for all data points.
		    - shape(N,): Symmetric +/-values for each data point.
		    - shape(2,N): Separate - and + values for each bar. First row
		        contains the lower errors, the second row contains the
		        upper errors.
		    - *None*: No errorbar.
		
		    Note that all error arrays should have *positive* values.
		
		    See :doc:`/gallery/statistics/errorbar_features`
		    for an example on the usage of ``xerr`` and ``yerr``.
		
		fmt : plot format string, optional, default: ''
		    The format for the data points / data lines. See `.plot` for
		    details.
		
		    Use 'none' (case insensitive) to plot errorbars without any data
		    markers.
		
		ecolor : mpl color, optional, default: None
		    A matplotlib color arg which gives the color the errorbar lines.
		    If None, use the color of the line connecting the markers.
		
		elinewidth : scalar, optional, default: None
		    The linewidth of the errorbar lines. If None, the linewidth of
		    the current style is used.
		
		capsize : scalar, optional, default: None
		    The length of the error bar caps in points. If None, it will take
		    the value from :rc:`errorbar.capsize`.
		
		capthick : scalar, optional, default: None
		    An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
		    This setting is a more sensible name for the property that
		    controls the thickness of the error bar cap in points. For
		    backwards compatibility, if *mew* or *markeredgewidth* are given,
		    then they will over-ride *capthick*. This may change in future
		    releases.
		
		barsabove : bool, optional, default: False
		    If True, will plot the errorbars above the plot
		    symbols. Default is below.
		
		lolims, uplims, xlolims, xuplims : bool, optional, default: None
		    These arguments can be used to indicate that a value gives only
		    upper/lower limits. In that case a caret symbol is used to
		    indicate this. *lims*-arguments may be of the same type as *xerr*
		    and *yerr*.  To use limits with inverted axes, :meth:`set_xlim`
		    or :meth:`set_ylim` must be called before :meth:`errorbar`.
		
		errorevery : positive integer, optional, default: 1
		    Subsamples the errorbars. e.g., if errorevery=5, errorbars for
		    every 5-th datapoint will be plotted. The data plot itself still
		    shows all data points.
		
		Returns
		-------
		container : :class:`~.container.ErrorbarContainer`
		    The container contains:
		
		    - plotline: :class:`~matplotlib.lines.Line2D` instance of
		      x, y plot markers and/or line.
		    - caplines: A tuple of :class:`~matplotlib.lines.Line2D` instances
		      of the error bar caps.
		    - barlinecols: A tuple of
		      :class:`~matplotlib.collections.LineCollection` with the
		      horizontal and vertical error ranges.
		
		Other Parameters
		----------------
		**kwargs
		    All other keyword arguments are passed on to the plot
		    command for the markers. For example, this code makes big red
		    squares with thick green edges::
		
		        x,y,yerr = rand(3,10)
		        errorbar(x, y, yerr, marker='s', mfc='red',
		                 mec='green', ms=20, mew=4)
		
		    where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
		    property names, *markerfacecolor*, *markeredgecolor*, *markersize*
		    and *markeredgewidth*.
		
		    Valid kwargs for the marker properties are `.Lines2D` properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'xerr', 'y', 'yerr'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function errorbar(x:Dynamic, y:Dynamic, ?yerr:Dynamic, ?xerr:Dynamic, ?fmt:Dynamic, ?ecolor:Dynamic, ?elinewidth:Dynamic, ?capsize:Dynamic, ?barsabove:Dynamic, ?lolims:Dynamic, ?uplims:Dynamic, ?xlolims:Dynamic, ?xuplims:Dynamic, ?errorevery:Dynamic, ?capthick:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var euler_gamma : Dynamic;
	/**
		Plot identical parallel lines at the given positions.
		
		*positions* should be a 1D or 2D array-like object, with each row
		corresponding to a row or column of lines.
		
		This type of plot is commonly used in neuroscience for representing
		neural events, where it is usually called a spike raster, dot raster,
		or raster plot.
		
		However, it is useful in any situation where you wish to show the
		timing or position of multiple sets of discrete events, such as the
		arrival times of people to a business on each day of the month or the
		date of hurricanes each year of the last century.
		
		Parameters
		----------
		positions : 1D or 2D array-like object
		    Each value is an event. If *positions* is a 2D array-like, each
		    row corresponds to a row or a column of lines (depending on the
		    *orientation* parameter).
		
		orientation : {'horizontal', 'vertical'}, optional
		    Controls the direction of the event collections:
		
		        - 'horizontal' : the lines are arranged horizontally in rows,
		          and are vertical.
		        - 'vertical' : the lines are arranged vertically in columns,
		          and are horizontal.
		
		lineoffsets : scalar or sequence of scalars, optional, default: 1
		    The offset of the center of the lines from the origin, in the
		    direction orthogonal to *orientation*.
		
		linelengths : scalar or sequence of scalars, optional, default: 1
		    The total height of the lines (i.e. the lines stretches from
		    ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
		
		linewidths : scalar, scalar sequence or None, optional, default: None
		    The line width(s) of the event lines, in points. If it is None,
		    defaults to its rcParams setting.
		
		colors : color, sequence of colors or None, optional, default: None
		    The color(s) of the event lines. If it is None, defaults to its
		    rcParams setting.
		
		linestyles : str or tuple or a sequence of such values, optional
		    Default is 'solid'. Valid strings are ['solid', 'dashed',
		    'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
		    should be of the form::
		
		        (offset, onoffseq),
		
		    where *onoffseq* is an even length tuple of on and off ink
		    in points.
		
		**kwargs : optional
		    Other keyword arguments are line collection properties.  See
		    :class:`~matplotlib.collections.LineCollection` for a list of
		    the valid properties.
		
		Returns
		-------
		
		list : A list of :class:`~.collections.EventCollection` objects.
		    Contains the :class:`~.collections.EventCollection` that
		    were added.
		
		Notes
		-----
		
		For *linelengths*, *linewidths*, *colors*, and *linestyles*, if only
		a single value is given, that value is applied to all lines.  If an
		array-like is given, it must have the same length as *positions*, and
		each value will be applied to the corresponding row of the array.
		
		Examples
		--------
		
		.. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'colors', 'linelengths', 'lineoffsets', 'linestyles', 'linewidths', 'positions'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function eventplot(positions:Dynamic, ?orientation:Dynamic, ?lineoffsets:Dynamic, ?linelengths:Dynamic, ?linewidths:Dynamic, ?colors:Dynamic, ?linestyles:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Calculate the exponential of all elements in the input array.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise exponential of `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		expm1 : Calculate ``exp(x) - 1`` for all elements in the array.
		exp2  : Calculate ``2**x`` for all elements in the array.
		
		Notes
		-----
		The irrational number ``e`` is also known as Euler's number.  It is
		approximately 2.718281, and is the base of the natural logarithm,
		``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
		then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.
		
		For complex arguments, ``x = a + ib``, we can write
		:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
		known (it is the real argument, described above).  The second term,
		:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with
		magnitude 1 and a periodic phase.
		
		References
		----------
		.. [1] Wikipedia, "Exponential function",
		       https://en.wikipedia.org/wiki/Exponential_function
		.. [2] M. Abramovitz and I. A. Stegun, "Handbook of Mathematical Functions
		       with Formulas, Graphs, and Mathematical Tables," Dover, 1964, p. 69,
		       http://www.math.sfu.ca/~cbm/aands/page_69.htm
		
		Examples
		--------
		Plot the magnitude and phase of ``exp(x)`` in the complex plane:
		
		>>> import matplotlib.pyplot as plt
		
		>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
		>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
		>>> out = np.exp(xx)
		
		>>> plt.subplot(121)
		>>> plt.imshow(np.abs(out),
		...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
		>>> plt.title('Magnitude of exp(x)')
		
		>>> plt.subplot(122)
		>>> plt.imshow(np.angle(out),
		...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
		>>> plt.title('Phase (angle) of exp(x)')
		>>> plt.show()
	**/
	static public function exp(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Calculate `2**p` for all `p` in the input array.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Element-wise 2 to the power `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		power
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		
		
		Examples
		--------
		>>> np.exp2([2, 3])
		array([ 4.,  8.])
	**/
	static public function exp2(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Expand the shape of an array.
		
		Insert a new axis that will appear at the `axis` position in the expanded
		array shape.
		
		.. note:: Previous to NumPy 1.13.0, neither ``axis < -a.ndim - 1`` nor
		   ``axis > a.ndim`` raised errors or put the new axis where documented.
		   Those axis values are now deprecated and will raise an AxisError in the
		   future.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int
		    Position in the expanded axes where the new axis is placed.
		
		Returns
		-------
		res : ndarray
		    Output array. The number of dimensions is one greater than that of
		    the input array.
		
		See Also
		--------
		squeeze : The inverse operation, removing singleton dimensions
		reshape : Insert, remove, and combine dimensions, and resize existing ones
		doc.indexing, atleast_1d, atleast_2d, atleast_3d
		
		Examples
		--------
		>>> x = np.array([1,2])
		>>> x.shape
		(2,)
		
		The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:
		
		>>> y = np.expand_dims(x, axis=0)
		>>> y
		array([[1, 2]])
		>>> y.shape
		(1, 2)
		
		>>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,np.newaxis]
		>>> y
		array([[1],
		       [2]])
		>>> y.shape
		(2, 1)
		
		Note that some examples may use ``None`` instead of ``np.newaxis``.  These
		are the same objects:
		
		>>> np.newaxis is None
		True
	**/
	static public function expand_dims(a:Dynamic, axis:Dynamic):Dynamic;
	/**
		expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Calculate ``exp(x) - 1`` for all elements in the array.
		
		Parameters
		----------
		x : array_like
		   Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Element-wise exponential minus one: ``out = exp(x) - 1``.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		log1p : ``log(1 + x)``, the inverse of expm1.
		
		
		Notes
		-----
		This function provides greater precision than ``exp(x) - 1``
		for small values of ``x``.
		
		Examples
		--------
		The true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to
		about 32 significant digits. This example shows the superiority of
		expm1 in this case.
		
		>>> np.expm1(1e-10)
		1.00000000005e-10
		>>> np.exp(1e-10) - 1
		1.000000082740371e-10
	**/
	static public function expm1(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		exponential(scale=1.0, size=None)
		
		Draw samples from an exponential distribution.
		
		Its probability density function is
		
		.. math:: f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),
		
		for ``x > 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
		which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
		The rate parameter is an alternative, widely used parameterization
		of the exponential distribution [3]_.
		
		The exponential distribution is a continuous analogue of the
		geometric distribution.  It describes many common situations, such as
		the size of raindrops measured over many rainstorms [1]_, or the time
		between page requests to Wikipedia [2]_.
		
		Parameters
		----------
		scale : float or array_like of floats
		    The scale parameter, :math:`\beta = 1/\lambda`.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``scale`` is a scalar.  Otherwise,
		    ``np.array(scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized exponential distribution.
		
		References
		----------
		.. [1] Peyton Z. Peebles Jr., "Probability, Random Variables and
		       Random Signal Principles", 4th ed, 2001, p. 57.
		.. [2] Wikipedia, "Poisson process",
		       https://en.wikipedia.org/wiki/Poisson_process
		.. [3] Wikipedia, "Exponential distribution",
		       https://en.wikipedia.org/wiki/Exponential_distribution
	**/
	static public function exponential(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the elements of an array that satisfy some condition.
		
		This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
		`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.
		
		Note that `place` does the exact opposite of `extract`.
		
		Parameters
		----------
		condition : array_like
		    An array whose nonzero or True entries indicate the elements of `arr`
		    to extract.
		arr : array_like
		    Input array of the same size as `condition`.
		
		Returns
		-------
		extract : ndarray
		    Rank 1 array of values from `arr` where `condition` is True.
		
		See Also
		--------
		take, put, copyto, compress, place
		
		Examples
		--------
		>>> arr = np.arange(12).reshape((3, 4))
		>>> arr
		array([[ 0,  1,  2,  3],
		       [ 4,  5,  6,  7],
		       [ 8,  9, 10, 11]])
		>>> condition = np.mod(arr, 3)==0
		>>> condition
		array([[ True, False, False,  True],
		       [False, False,  True, False],
		       [False,  True, False, False]])
		>>> np.extract(condition, arr)
		array([0, 3, 6, 9])
		
		
		If `condition` is boolean:
		
		>>> arr[condition]
		array([0, 3, 6, 9])
	**/
	static public function extract(condition:Dynamic, arr:Dynamic):Dynamic;
	/**
		Return a 2-D array with ones on the diagonal and zeros elsewhere.
		
		Parameters
		----------
		N : int
		  Number of rows in the output.
		M : int, optional
		  Number of columns in the output. If None, defaults to `N`.
		k : int, optional
		  Index of the diagonal: 0 (the default) refers to the main diagonal,
		  a positive value refers to an upper diagonal, and a negative value
		  to a lower diagonal.
		dtype : data-type, optional
		  Data-type of the returned array.
		order : {'C', 'F'}, optional
		    Whether the output should be stored in row-major (C-style) or
		    column-major (Fortran-style) order in memory.
		
		    .. versionadded:: 1.14.0
		
		Returns
		-------
		I : ndarray of shape (N,M)
		  An array where all elements are equal to zero, except for the `k`-th
		  diagonal, whose values are equal to one.
		
		See Also
		--------
		identity : (almost) equivalent function
		diag : diagonal 2-D array from a 1-D array specified by the user.
		
		Examples
		--------
		>>> np.eye(2, dtype=int)
		array([[1, 0],
		       [0, 1]])
		>>> np.eye(3, k=1)
		array([[ 0.,  1.,  0.],
		       [ 0.,  0.,  1.],
		       [ 0.,  0.,  0.]])
	**/
	static public function eye(N:Dynamic, ?M:Dynamic, ?k:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		f(dfnum, dfden, size=None)
		
		Draw samples from an F distribution.
		
		Samples are drawn from an F distribution with specified parameters,
		`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
		freedom in denominator), where both parameters should be greater than
		zero.
		
		The random variate of the F distribution (also known as the
		Fisher distribution) is a continuous probability distribution
		that arises in ANOVA tests, and is the ratio of two chi-square
		variates.
		
		Parameters
		----------
		dfnum : float or array_like of floats
		    Degrees of freedom in numerator, should be > 0.
		dfden : float or array_like of float
		    Degrees of freedom in denominator, should be > 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``dfnum`` and ``dfden`` are both scalars.
		    Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Fisher distribution.
		
		See Also
		--------
		scipy.stats.f : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The F statistic is used to compare in-group variances to between-group
		variances. Calculating the distribution depends on the sampling, and
		so it is a function of the respective degrees of freedom in the
		problem.  The variable `dfnum` is the number of samples minus one, the
		between-groups degrees of freedom, while `dfden` is the within-groups
		degrees of freedom, the sum of the number of samples in each group
		minus the number of groups.
		
		References
		----------
		.. [1] Glantz, Stanton A. "Primer of Biostatistics.", McGraw-Hill,
		       Fifth Edition, 2002.
		.. [2] Wikipedia, "F-distribution",
		       https://en.wikipedia.org/wiki/F-distribution
		
		Examples
		--------
		An example from Glantz[1], pp 47-40:
		
		Two groups, children of diabetics (25 people) and children from people
		without diabetes (25 controls). Fasting blood glucose was measured,
		case group had a mean value of 86.1, controls had a mean value of
		82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
		data consistent with the null hypothesis that the parents diabetic
		status does not affect their children's blood glucose levels?
		Calculating the F statistic from the data gives a value of 36.01.
		
		Draw samples from the distribution:
		
		>>> dfnum = 1. # between group degrees of freedom
		>>> dfden = 48. # within groups degrees of freedom
		>>> s = np.random.f(dfnum, dfden, 1000)
		
		The lower bound for the top 1% of the samples is :
		
		>>> sort(s)[-10]
		7.61988120985
		
		So there is about a 1% chance that the F statistic will exceed 7.62,
		the measured value is 36, so the null hypothesis is rejected at the 1%
		level.
	**/
	static public function f(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the absolute values element-wise.
		
		This function returns the absolute values (positive magnitude) of the
		data in `x`. Complex values are not handled, use `absolute` to find the
		absolute values of complex data.
		
		Parameters
		----------
		x : array_like
		    The array of numbers for which the absolute values are required. If
		    `x` is a scalar, the result `y` will also be a scalar.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The absolute values of `x`, the returned values are always floats.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		absolute : Absolute values including `complex` types.
		
		Examples
		--------
		>>> np.fabs(-1)
		1.0
		>>> np.fabs([-1.2, 1.2])
		array([ 1.2,  1.2])
	**/
	static public function fabs(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		_fastCopyAndTranspose(a)
	**/
	static public function fastCopyAndTranspose(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the one-dimensional discrete Fourier Transform.
		
		This function computes the one-dimensional *n*-point discrete Fourier
		Transform (DFT) with the efficient Fast Fourier Transform (FFT)
		algorithm [CT].
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex.
		n : int, optional
		    Length of the transformed axis of the output.
		    If `n` is smaller than the length of the input, the input is cropped.
		    If it is larger, the input is padded with zeros.  If `n` is not given,
		    the length of the input along the axis specified by `axis` is used.
		axis : int, optional
		    Axis over which to compute the FFT.  If not given, the last axis is
		    used.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		
		Raises
		------
		IndexError
		    if `axes` is larger than the last axis of `a`.
		
		See Also
		--------
		numpy.fft : for definition of the DFT and conventions used.
		ifft : The inverse of `fft`.
		fft2 : The two-dimensional FFT.
		fftn : The *n*-dimensional FFT.
		rfftn : The *n*-dimensional FFT of real input.
		fftfreq : Frequency bins for given FFT parameters.
		
		Notes
		-----
		FFT (Fast Fourier Transform) refers to a way the discrete Fourier
		Transform (DFT) can be calculated efficiently, by using symmetries in the
		calculated terms.  The symmetry is highest when `n` is a power of 2, and
		the transform is therefore most efficient for these sizes.
		
		The DFT is defined, with the conventions used in this implementation, in
		the documentation for the `numpy.fft` module.
		
		References
		----------
		.. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
		        machine calculation of complex Fourier series," *Math. Comput.*
		        19: 297-301.
		
		Examples
		--------
		>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
		array([ -3.44505240e-16 +1.14383329e-17j,
		         8.00000000e+00 -5.71092652e-15j,
		         2.33482938e-16 +1.22460635e-16j,
		         1.64863782e-15 +1.77635684e-15j,
		         9.95839695e-17 +2.33482938e-16j,
		         0.00000000e+00 +1.66837030e-15j,
		         1.14383329e-17 +1.22460635e-16j,
		         -1.64863782e-15 +1.77635684e-15j])
		
		In this example, real input has an FFT which is Hermitian, i.e., symmetric
		in the real part and anti-symmetric in the imaginary part, as described in
		the `numpy.fft` documentation:
		
		>>> import matplotlib.pyplot as plt
		>>> t = np.arange(256)
		>>> sp = np.fft.fft(np.sin(t))
		>>> freq = np.fft.fftfreq(t.shape[-1])
		>>> plt.plot(freq, sp.real, freq, sp.imag)
		[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
		>>> plt.show()
	**/
	static public function fft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the 2-dimensional discrete Fourier Transform
		
		This function computes the *n*-dimensional discrete Fourier Transform
		over any axes in an *M*-dimensional array by means of the
		Fast Fourier Transform (FFT).  By default, the transform is computed over
		the last two axes of the input array, i.e., a 2-dimensional FFT.
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex
		s : sequence of ints, optional
		    Shape (length of each transformed axis) of the output
		    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
		    This corresponds to ``n`` for ``fft(x, n)``.
		    Along each axis, if the given shape is smaller than that of the input,
		    the input is cropped.  If it is larger, the input is padded with zeros.
		    if `s` is not given, the shape of the input along the axes specified
		    by `axes` is used.
		axes : sequence of ints, optional
		    Axes over which to compute the FFT.  If not given, the last two
		    axes are used.  A repeated index in `axes` means the transform over
		    that axis is performed multiple times.  A one-element sequence means
		    that a one-dimensional FFT is performed.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or the last two axes if `axes` is not given.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length, or `axes` not given and
		    ``len(s) != 2``.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		numpy.fft : Overall view of discrete Fourier transforms, with definitions
		     and conventions used.
		ifft2 : The inverse two-dimensional FFT.
		fft : The one-dimensional FFT.
		fftn : The *n*-dimensional FFT.
		fftshift : Shifts zero-frequency terms to the center of the array.
		    For two-dimensional input, swaps first and third quadrants, and second
		    and fourth quadrants.
		
		Notes
		-----
		`fft2` is just `fftn` with a different default for `axes`.
		
		The output, analogously to `fft`, contains the term for zero frequency in
		the low-order corner of the transformed axes, the positive frequency terms
		in the first half of these axes, the term for the Nyquist frequency in the
		middle of the axes and the negative frequency terms in the second half of
		the axes, in order of decreasingly negative frequency.
		
		See `fftn` for details and a plotting example, and `numpy.fft` for
		definitions and conventions used.
		
		
		Examples
		--------
		>>> a = np.mgrid[:5, :5][0]
		>>> np.fft.fft2(a)
		array([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,
		          0.0 +0.j        ,   0.0 +0.j        ],
		       [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
		          0.0 +0.j        ,   0.0 +0.j        ],
		       [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
		          0.0 +0.j        ,   0.0 +0.j        ],
		       [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
		            0.0 +0.j        ,   0.0 +0.j        ],
		       [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
		          0.0 +0.j        ,   0.0 +0.j        ]])
	**/
	static public function fft2(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Return the Discrete Fourier Transform sample frequencies.
		
		The returned float array `f` contains the frequency bin centers in cycles
		per unit of the sample spacing (with zero at the start).  For instance, if
		the sample spacing is in seconds, then the frequency unit is cycles/second.
		
		Given a window length `n` and a sample spacing `d`::
		
		  f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even
		  f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd
		
		Parameters
		----------
		n : int
		    Window length.
		d : scalar, optional
		    Sample spacing (inverse of the sampling rate). Defaults to 1.
		
		Returns
		-------
		f : ndarray
		    Array of length `n` containing the sample frequencies.
		
		Examples
		--------
		>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
		>>> fourier = np.fft.fft(signal)
		>>> n = signal.size
		>>> timestep = 0.1
		>>> freq = np.fft.fftfreq(n, d=timestep)
		>>> freq
		array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25])
	**/
	static public function fftfreq(n:Dynamic, ?d:Dynamic):Dynamic;
	/**
		Compute the N-dimensional discrete Fourier Transform.
		
		This function computes the *N*-dimensional discrete Fourier Transform over
		any number of axes in an *M*-dimensional array by means of the Fast Fourier
		Transform (FFT).
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex.
		s : sequence of ints, optional
		    Shape (length of each transformed axis) of the output
		    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
		    This corresponds to ``n`` for ``fft(x, n)``.
		    Along any axis, if the given shape is smaller than that of the input,
		    the input is cropped.  If it is larger, the input is padded with zeros.
		    if `s` is not given, the shape of the input along the axes specified
		    by `axes` is used.
		axes : sequence of ints, optional
		    Axes over which to compute the FFT.  If not given, the last ``len(s)``
		    axes are used, or all axes if `s` is also not specified.
		    Repeated indices in `axes` means that the transform over that axis is
		    performed multiple times.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or by a combination of `s` and `a`,
		    as explained in the parameters section above.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		numpy.fft : Overall view of discrete Fourier transforms, with definitions
		    and conventions used.
		ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
		fft : The one-dimensional FFT, with definitions and conventions used.
		rfftn : The *n*-dimensional FFT of real input.
		fft2 : The two-dimensional FFT.
		fftshift : Shifts zero-frequency terms to centre of array
		
		Notes
		-----
		The output, analogously to `fft`, contains the term for zero frequency in
		the low-order corner of all axes, the positive frequency terms in the
		first half of all axes, the term for the Nyquist frequency in the middle
		of all axes and the negative frequency terms in the second half of all
		axes, in order of decreasingly negative frequency.
		
		See `numpy.fft` for details, definitions and conventions used.
		
		Examples
		--------
		>>> a = np.mgrid[:3, :3, :3][0]
		>>> np.fft.fftn(a, axes=(1, 2))
		array([[[  0.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j]],
		       [[  9.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j]],
		       [[ 18.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j],
		        [  0.+0.j,   0.+0.j,   0.+0.j]]])
		>>> np.fft.fftn(a, (2, 2), axes=(0, 1))
		array([[[ 2.+0.j,  2.+0.j,  2.+0.j],
		        [ 0.+0.j,  0.+0.j,  0.+0.j]],
		       [[-2.+0.j, -2.+0.j, -2.+0.j],
		        [ 0.+0.j,  0.+0.j,  0.+0.j]]])
		
		>>> import matplotlib.pyplot as plt
		>>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
		...                      2 * np.pi * np.arange(200) / 34)
		>>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
		>>> FS = np.fft.fftn(S)
		>>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
		<matplotlib.image.AxesImage object at 0x...>
		>>> plt.show()
	**/
	static public function fftn(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Shift the zero-frequency component to the center of the spectrum.
		
		This function swaps half-spaces for all axes listed (defaults to all).
		Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.
		
		Parameters
		----------
		x : array_like
		    Input array.
		axes : int or shape tuple, optional
		    Axes over which to shift.  Default is None, which shifts all axes.
		
		Returns
		-------
		y : ndarray
		    The shifted array.
		
		See Also
		--------
		ifftshift : The inverse of `fftshift`.
		
		Examples
		--------
		>>> freqs = np.fft.fftfreq(10, 0.1)
		>>> freqs
		array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
		>>> np.fft.fftshift(freqs)
		array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
		
		Shift the zero-frequency component only along the second axis:
		
		>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
		>>> freqs
		array([[ 0.,  1.,  2.],
		       [ 3.,  4., -4.],
		       [-3., -2., -1.]])
		>>> np.fft.fftshift(freqs, axes=(1,))
		array([[ 2.,  0.,  1.],
		       [-4.,  3.,  4.],
		       [-1., -3., -2.]])
	**/
	static public function fftshift(x:Dynamic, ?axes:Dynamic):Dynamic;
	/**
		Calculate the width and height for a figure with a specified aspect ratio.
		
		While the height is taken from :rc:`figure.figsize`, the width is
		adjusted to match the desired aspect ratio. Additionally, it is ensured
		that the width is in the range [4., 16.] and the height is in the range
		[2., 16.]. If necessary, the default height is adjusted to ensure this.
		
		Parameters
		----------
		arg : scalar or 2d array
		    If a scalar, this defines the aspect ratio (i.e. the ratio height /
		    width).
		    In case of an array the aspect ratio is number of rows / number of
		    columns, so that the array could be fitted in the figure undistorted.
		
		Returns
		-------
		width, height
		    The figure size in inches.
		
		Notes
		-----
		If you want to create an axes within the figure, that still preserves the
		aspect ratio, be sure to create it with equal width and height. See
		examples below.
		
		Thanks to Fernando Perez for this function.
		
		Examples
		--------
		Make a figure twice as tall as it is wide::
		
		    w, h = figaspect(2.)
		    fig = Figure(figsize=(w, h))
		    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
		    ax.imshow(A, **kwargs)
		
		Make a figure with the proper aspect for an array::
		
		    A = rand(5,3)
		    w, h = figaspect(A)
		    fig = Figure(figsize=(w, h))
		    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
		    ax.imshow(A, **kwargs)
	**/
	static public function figaspect(arg:Dynamic):Dynamic;
	/**
		Add a non-resampled image to the figure.
		
		The image is attached to the lower or upper left corner depending on
		*origin*.
		
		Parameters
		----------
		X
		    The image data. This is an array of one of the following shapes:
		
		    - MxN: luminance (grayscale) values
		    - MxNx3: RGB values
		    - MxNx4: RGBA values
		
		xo, yo : int
		    The *x* /*y* image offset in pixels.
		
		alpha : None or float
		    The alpha blending value.
		
		norm : :class:`matplotlib.colors.Normalize`
		    A :class:`.Normalize` instance to map the luminance to the
		    interval [0, 1].
		
		cmap : str or :class:`matplotlib.colors.Colormap`
		    The colormap to use. Default: :rc:`image.cmap`.
		
		vmin, vmax : scalar
		    If *norm* is not given, these values set the data limits for the
		    colormap.
		
		origin : {'upper', 'lower'}
		    Indicates where the [0, 0] index of the array is in the upper left
		    or lower left corner of the axes. Defaults to :rc:`image.origin`.
		
		resize : bool
		    If *True*, resize the figure to match the given image size.
		
		Returns
		-------
		:class:`matplotlib.image.FigureImage`
		
		Other Parameters
		----------------
		**kwargs
		    Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
		
		Notes
		-----
		figimage complements the axes image
		(:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
		to fit the current axes.  If you want a resampled image to
		fill the entire figure, you can define an
		:class:`~matplotlib.axes.Axes` with extent [0,0,1,1].
		
		
		Examples::
		
		    f = plt.figure()
		    nx = int(f.get_figwidth() * f.dpi)
		    ny = int(f.get_figheight() * f.dpi)
		    data = np.random.random((ny, nx))
		    f.figimage(data)
		    plt.show()
	**/
	static public function figimage(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Place a legend on the figure.
		
		To make a legend from existing artists on every axes::
		
		  figlegend()
		
		To make a legend for a list of lines and labels::
		
		  figlegend(
		      (line1, line2, line3),
		      ('label1', 'label2', 'label3'),
		      loc='upper right')
		
		These can also be specified by keyword::
		
		  figlegend(
		      handles=(line1, line2, line3),
		      labels=('label1', 'label2', 'label3'),
		      loc='upper right')
		
		Parameters
		----------
		
		handles : sequence of `.Artist`, optional
		    A list of Artists (lines, patches) to be added to the legend.
		    Use this together with *labels*, if you need full control on what
		    is shown in the legend and the automatic mechanism described above
		    is not sufficient.
		
		    The length of handles and labels should be the same in this
		    case. If they are not, they are truncated to the smaller length.
		
		labels : sequence of strings, optional
		    A list of labels to show next to the artists.
		    Use this together with *handles*, if you need full control on what
		    is shown in the legend and the automatic mechanism described above
		    is not sufficient.
		
		Other Parameters
		----------------
		
		
		loc : str or pair of floats, default: :rc:`legend.loc` ('best' for axes, 'upper right' for figures)
		    The location of the legend.
		
		    The strings
		    ``'upper left', 'upper right', 'lower left', 'lower right'``
		    place the legend at the corresponding corner of the axes/figure.
		
		    The strings
		    ``'upper center', 'lower center', 'center left', 'center right'``
		    place the legend at the center of the corresponding edge of the
		    axes/figure.
		
		    The string ``'center'`` places the legend at the center of the axes/figure.
		
		    The string ``'best'`` places the legend at the location, among the nine
		    locations defined so far, with the minimum overlap with other drawn
		    artists.  This option can be quite slow for plots with large amounts of
		    data; your plotting speed may benefit from providing a specific location.
		
		    The location can also be a 2-tuple giving the coordinates of the lower-left
		    corner of the legend in axes coordinates (in which case *bbox_to_anchor*
		    will be ignored).
		
		    For back-compatibility, ``'center right'`` (but no other location) can also
		    be spelled ``'right'``, and each "string" locations can also be given as a
		    numeric value:
		
		        ===============   =============
		        Location String   Location Code
		        ===============   =============
		        'best'            0
		        'upper right'     1
		        'upper left'      2
		        'lower left'      3
		        'lower right'     4
		        'right'           5
		        'center left'     6
		        'center right'    7
		        'lower center'    8
		        'upper center'    9
		        'center'          10
		        ===============   =============
		
		bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats
		    Box that is used to position the legend in conjunction with *loc*.
		    Defaults to `axes.bbox` (if called as a method to `.Axes.legend`) or
		    `figure.bbox` (if `.Figure.legend`).  This argument allows arbitrary
		    placement of the legend.
		
		    Bbox coordinates are interpreted in the coordinate system given by
		    `bbox_transform`, with the default transform
		    Axes or Figure coordinates, depending on which ``legend`` is called.
		
		    If a 4-tuple or `.BboxBase` is given, then it specifies the bbox
		    ``(x, y, width, height)`` that the legend is placed in.
		    To put the legend in the best location in the bottom right
		    quadrant of the axes (or figure)::
		
		        loc='best', bbox_to_anchor=(0.5, 0., 0.5, 0.5)
		
		    A 2-tuple ``(x, y)`` places the corner of the legend specified by *loc* at
		    x, y.  For example, to put the legend's upper right-hand corner in the
		    center of the axes (or figure) the following keywords can be used::
		
		        loc='upper right', bbox_to_anchor=(0.5, 0.5)
		
		ncol : integer
		    The number of columns that the legend has. Default is 1.
		
		prop : None or :class:`matplotlib.font_manager.FontProperties` or dict
		    The font properties of the legend. If None (default), the current
		    :data:`matplotlib.rcParams` will be used.
		
		fontsize : int or float or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}
		    Controls the font size of the legend. If the value is numeric the
		    size will be the absolute font size in points. String values are
		    relative to the current default font size. This argument is only
		    used if `prop` is not specified.
		
		numpoints : None or int
		    The number of marker points in the legend when creating a legend
		    entry for a `.Line2D` (line).
		    Default is ``None``, which will take the value from
		    :rc:`legend.numpoints`.
		
		scatterpoints : None or int
		    The number of marker points in the legend when creating
		    a legend entry for a `.PathCollection` (scatter plot).
		    Default is ``None``, which will take the value from
		    :rc:`legend.scatterpoints`.
		
		scatteryoffsets : iterable of floats
		    The vertical offset (relative to the font size) for the markers
		    created for a scatter plot legend entry. 0.0 is at the base the
		    legend text, and 1.0 is at the top. To draw all markers at the
		    same height, set to ``[0.5]``. Default is ``[0.375, 0.5, 0.3125]``.
		
		markerscale : None or int or float
		    The relative size of legend markers compared with the originally
		    drawn ones.
		    Default is ``None``, which will take the value from
		    :rc:`legend.markerscale`.
		
		markerfirst : bool
		    If *True*, legend marker is placed to the left of the legend label.
		    If *False*, legend marker is placed to the right of the legend
		    label.
		    Default is *True*.
		
		frameon : None or bool
		    Control whether the legend should be drawn on a patch
		    (frame).
		    Default is ``None``, which will take the value from
		    :rc:`legend.frameon`.
		
		fancybox : None or bool
		    Control whether round edges should be enabled around the
		    :class:`~matplotlib.patches.FancyBboxPatch` which makes up the
		    legend's background.
		    Default is ``None``, which will take the value from
		    :rc:`legend.fancybox`.
		
		shadow : None or bool
		    Control whether to draw a shadow behind the legend.
		    Default is ``None``, which will take the value from
		    :rc:`legend.shadow`.
		
		framealpha : None or float
		    Control the alpha transparency of the legend's background.
		    Default is ``None``, which will take the value from
		    :rc:`legend.framealpha`.  If shadow is activated and
		    *framealpha* is ``None``, the default value is ignored.
		
		facecolor : None or "inherit" or a color spec
		    Control the legend's background color.
		    Default is ``None``, which will take the value from
		    :rc:`legend.facecolor`.  If ``"inherit"``, it will take
		    :rc:`axes.facecolor`.
		
		edgecolor : None or "inherit" or a color spec
		    Control the legend's background patch edge color.
		    Default is ``None``, which will take the value from
		    :rc:`legend.edgecolor` If ``"inherit"``, it will take
		    :rc:`axes.edgecolor`.
		
		mode : {"expand", None}
		    If `mode` is set to ``"expand"`` the legend will be horizontally
		    expanded to fill the axes area (or `bbox_to_anchor` if defines
		    the legend's size).
		
		bbox_transform : None or :class:`matplotlib.transforms.Transform`
		    The transform for the bounding box (`bbox_to_anchor`). For a value
		    of ``None`` (default) the Axes'
		    :data:`~matplotlib.axes.Axes.transAxes` transform will be used.
		
		title : str or None
		    The legend's title. Default is no title (``None``).
		
		title_fontsize: str or None
		    The fontsize of the legend's title.  Default is the default fontsize.
		
		borderpad : float or None
		    The fractional whitespace inside the legend border.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.borderpad`.
		
		labelspacing : float or None
		    The vertical space between the legend entries.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.labelspacing`.
		
		handlelength : float or None
		    The length of the legend handles.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.handlelength`.
		
		handletextpad : float or None
		    The pad between the legend handle and text.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.handletextpad`.
		
		borderaxespad : float or None
		    The pad between the axes and legend border.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.borderaxespad`.
		
		columnspacing : float or None
		    The spacing between columns.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.columnspacing`.
		
		handler_map : dict or None
		    The custom dictionary mapping instances or types to a legend
		    handler. This `handler_map` updates the default handler map
		    found at :func:`matplotlib.legend.Legend.get_legend_handler_map`.
		
		
		
		Returns
		-------
		:class:`matplotlib.legend.Legend` instance
		
		Notes
		-----
		Not all kinds of artist are supported by the legend command. See
		:doc:`/tutorials/intermediate/legend_guide` for details.
	**/
	static public function figlegend(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return whether the figure with the given id exists.
	**/
	static public function fignum_exists(num:Dynamic):Dynamic;
	/**
		Add text to figure.
		
		Parameters
		----------
		x, y : float
		    The position to place the text. By default, this is in figure
		    coordinates, floats in [0, 1]. The coordinate system can be changed
		    using the *transform* keyword.
		
		s : str
		    The text string.
		
		fontdict : dictionary, optional, default: None
		    A dictionary to override the default text properties. If fontdict
		    is None, the defaults are determined by your rc parameters. A
		    property in *kwargs* override the same property in fontdict.
		
		withdash : boolean, optional, default: False
		    Creates a `~matplotlib.text.TextWithDash` instance instead of a
		    `~matplotlib.text.Text` instance.
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.text.Text` properties
		    Other miscellaneous text parameters.
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  backgroundcolor: color
		  bbox: dict with properties for `.patches.FancyBboxPatch`
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  figure: `.Figure`
		  fontfamily or family: {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'}
		  fontproperties or font_properties: `.font_manager.FontProperties`
		  fontsize or size: {size in points, 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}
		  fontstretch or stretch: {a numeric value in range 0-1000, 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'}
		  fontstyle or style: {'normal', 'italic', 'oblique'}
		  fontvariant or variant: {'normal', 'small-caps'}
		  fontweight or weight: {a numeric value in range 0-1000, 'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'}
		  gid: str
		  horizontalalignment or ha: {'center', 'right', 'left'}
		  in_layout: bool
		  label: object
		  linespacing: float (multiple of font size)
		  multialignment or ma: {'left', 'right', 'center'}
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  position: (float, float)
		  rasterized: bool or None
		  rotation: {angle in degrees, 'vertical', 'horizontal'}
		  rotation_mode: {None, 'default', 'anchor'}
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  text: object
		  transform: `.Transform`
		  url: str
		  usetex: bool or None
		  verticalalignment or va: {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
		  visible: bool
		  wrap: bool
		  x: float
		  y: float
		  zorder: float
		
		Returns
		-------
		text : `~.text.Text`
		
		See Also
		--------
		.Axes.text
		.pyplot.text
	**/
	static public function figtext(x:Dynamic, y:Dynamic, s:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Create a new figure.
		
		Parameters
		----------
		num : integer or string, optional, default: None
		    If not provided, a new figure will be created, and the figure number
		    will be incremented. The figure objects holds this number in a `number`
		    attribute.
		    If num is provided, and a figure with this id already exists, make
		    it active, and returns a reference to it. If this figure does not
		    exists, create it and returns it.
		    If num is a string, the window title will be set to this figure's
		    `num`.
		
		figsize : (float, float), optional, default: None
		    width, height in inches. If not provided, defaults to
		    :rc:`figure.figsize` = ``[6.4, 4.8]``.
		
		dpi : integer, optional, default: None
		    resolution of the figure. If not provided, defaults to
		    :rc:`figure.dpi` = ``100``.
		
		facecolor : color spec
		    the background color. If not provided, defaults to
		    :rc:`figure.facecolor` = ``'w'``.
		
		edgecolor : color spec
		    the border color. If not provided, defaults to
		    :rc:`figure.edgecolor` = ``'w'``.
		
		frameon : bool, optional, default: True
		    If False, suppress drawing the figure frame.
		
		FigureClass : subclass of `~matplotlib.figure.Figure`
		    Optionally use a custom `.Figure` instance.
		
		clear : bool, optional, default: False
		    If True and the figure already exists, then it is cleared.
		
		Returns
		-------
		figure : `~matplotlib.figure.Figure`
		    The `.Figure` instance returned will also be passed to
		    new_figure_manager in the backends, which allows to hook custom
		    `.Figure` classes into the pyplot interface. Additional kwargs will be
		    passed to the `.Figure` init function.
		
		Notes
		-----
		If you are creating many figures, make sure you explicitly call
		:func:`.pyplot.close` on the figures you are not using, because this will
		enable pyplot to properly clean up the memory.
		
		`~matplotlib.rcParams` defines the default values, which can be modified
		in the matplotlibrc file.
	**/
	static public function figure(?num:Dynamic, ?figsize:Dynamic, ?dpi:Dynamic, ?facecolor:Dynamic, ?edgecolor:Dynamic, ?frameon:Dynamic, ?FigureClass:Dynamic, ?clear:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Plot filled polygons.
		
		Parameters
		----------
		*args : sequence of x, y, [color]
		    Each polygon is defined by the lists of *x* and *y* positions of
		    its nodes, optionally followed by a *color* specifier. See
		    :mod:`matplotlib.colors` for supported color specifiers. The
		    standard color cycle is used for polygons without a color
		    specifier.
		
		    You can plot multiple polygons by providing multiple *x*, *y*,
		    *[color]* groups.
		
		    For example, each of the following is legal::
		
		        ax.fill(x, y)                    # a polygon with default color
		        ax.fill(x, y, "b")               # a blue polygon
		        ax.fill(x, y, x2, y2)            # two polygons
		        ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
		
		data : indexable object, optional
		    An object with labelled data. If given, provide the label names to
		    plot in *x* and *y*, e.g.::
		
		        ax.fill("time", "signal",
		                data={"time": [0, 1, 2], "signal": [0, 1, 0]})
		
		Returns
		-------
		a list of :class:`~matplotlib.patches.Polygon`
		
		Other Parameters
		----------------
		**kwargs : :class:`~matplotlib.patches.Polygon` properties
		
		Notes
		-----
		Use :meth:`fill_between` if you would like to fill the region between
		two curves.
	**/
	static public function fill(?args:python.VarArgs<Dynamic>, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Fill the area between two horizontal curves.
		
		The curves are defined by the points (*x*, *y1*) and (*x*, *y2*). This
		creates one or multiple polygons describing the filled area.
		
		You may exclude some horizontal sections from filling using *where*.
		
		By default, the edges connect the given points directly. Use *step* if
		the filling should be a step function, i.e. constant in between *x*.
		
		
		Parameters
		----------
		x : array (length N)
		    The x coordinates of the nodes defining the curves.
		
		y1 : array (length N) or scalar
		    The y coordinates of the nodes defining the first curve.
		
		y2 : array (length N) or scalar, optional, default: 0
		    The y coordinates of the nodes defining the second curve.
		
		where : array of bool (length N), optional, default: None
		    Define *where* to exclude some horizontal regions from being
		    filled. The filled regions are defined by the coordinates
		    ``x[where]``.  More precisely, fill between ``x[i]`` and ``x[i+1]``
		    if ``where[i] and where[i+1]``.  Note that this definition implies
		    that an isolated *True* value between two *False* values in
		    *where* will not result in filling.  Both sides of the *True*
		    position remain unfilled due to the adjacent *False* values.
		
		interpolate : bool, optional
		    This option is only relevant if *where* is used and the two curves
		    are crossing each other.
		
		    Semantically, *where* is often used for *y1* > *y2* or similar.
		    By default, the nodes of the polygon defining the filled region
		    will only be placed at the positions in the *x* array.  Such a
		    polygon cannot describe the above semantics close to the
		    intersection.  The x-sections containing the intersection are
		    simply clipped.
		
		    Setting *interpolate* to *True* will calculate the actual
		    intersection point and extend the filled region up to this point.
		
		step : {'pre', 'post', 'mid'}, optional
		    Define *step* if the filling should be a step function,
		    i.e. constant in between *x*. The value determines where the
		    step will occur:
		
		    - 'pre': The y value is continued constantly to the left from
		      every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
		      value ``y[i]``.
		    - 'post': The y value is continued constantly to the right from
		      every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
		      value ``y[i]``.
		    - 'mid': Steps occur half-way between the *x* positions.
		
		Other Parameters
		----------------
		**kwargs
		    All other keyword arguments are passed on to `.PolyCollection`.
		    They control the `.Polygon` properties:
		
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		Returns
		-------
		`.PolyCollection`
		    A `.PolyCollection` containing the plotted polygons.
		
		See Also
		--------
		fill_betweenx : Fill between two sets of x-values.
		
		Notes
		-----
		.. [notes section required to get data note injection right]
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'where', 'x', 'y1', 'y2'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function fill_between(x:Dynamic, y1:Dynamic, ?y2:Dynamic, ?where:Dynamic, ?interpolate:Dynamic, ?step:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Fill the area between two vertical curves.
		
		The curves are defined by the points (*x1*, *y*) and (*x2*, *y*). This
		creates one or multiple polygons describing the filled area.
		
		You may exclude some vertical sections from filling using *where*.
		
		By default, the edges connect the given points directly. Use *step* if
		the filling should be a step function, i.e. constant in between *y*.
		
		
		Parameters
		----------
		y : array (length N)
		    The y coordinates of the nodes defining the curves.
		
		x1 : array (length N) or scalar
		    The x coordinates of the nodes defining the first curve.
		
		x2 : array (length N) or scalar, optional, default: 0
		    The x coordinates of the nodes defining the second curve.
		
		where : array of bool (length N), optional, default: None
		    Define *where* to exclude some vertical regions from being
		    filled. The filled regions are defined by the coordinates
		    ``y[where]``.  More precisely, fill between ``y[i]`` and ``y[i+1]``
		    if ``where[i] and where[i+1]``.  Note that this definition implies
		    that an isolated *True* value between two *False* values in
		    *where* will not result in filling.  Both sides of the *True*
		    position remain unfilled due to the adjacent *False* values.
		
		interpolate : bool, optional
		    This option is only relevant if *where* is used and the two curves
		    are crossing each other.
		
		    Semantically, *where* is often used for *x1* > *x2* or similar.
		    By default, the nodes of the polygon defining the filled region
		    will only be placed at the positions in the *y* array.  Such a
		    polygon cannot describe the above semantics close to the
		    intersection.  The y-sections containing the intersection are
		    simply clipped.
		
		    Setting *interpolate* to *True* will calculate the actual
		    intersection point and extend the filled region up to this point.
		
		step : {'pre', 'post', 'mid'}, optional
		    Define *step* if the filling should be a step function,
		    i.e. constant in between *y*. The value determines where the
		    step will occur:
		
		    - 'pre': The y value is continued constantly to the left from
		      every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
		      value ``y[i]``.
		    - 'post': The y value is continued constantly to the right from
		      every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
		      value ``y[i]``.
		    - 'mid': Steps occur half-way between the *x* positions.
		
		Other Parameters
		----------------
		**kwargs
		    All other keyword arguments are passed on to `.PolyCollection`.
		    They control the `.Polygon` properties:
		
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		Returns
		-------
		`.PolyCollection`
		    A `.PolyCollection` containing the plotted polygons.
		
		See Also
		--------
		fill_between : Fill between two sets of y-values.
		
		Notes
		-----
		.. [notes section required to get data note injection right]
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'where', 'x1', 'x2', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function fill_betweenx(y:Dynamic, x1:Dynamic, ?x2:Dynamic, ?where:Dynamic, ?step:Dynamic, ?interpolate:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Fill the main diagonal of the given array of any dimensionality.
		
		For an array `a` with ``a.ndim >= 2``, the diagonal is the list of
		locations with indices ``a[i, ..., i]`` all identical. This function
		modifies the input array in-place, it does not return a value.
		
		Parameters
		----------
		a : array, at least 2-D.
		  Array whose diagonal is to be filled, it gets modified in-place.
		
		val : scalar
		  Value to be written on the diagonal, its type must be compatible with
		  that of the array a.
		
		wrap : bool
		  For tall matrices in NumPy version up to 1.6.2, the
		  diagonal "wrapped" after N columns. You can have this behavior
		  with this option. This affects only tall matrices.
		
		See also
		--------
		diag_indices, diag_indices_from
		
		Notes
		-----
		.. versionadded:: 1.4.0
		
		This functionality can be obtained via `diag_indices`, but internally
		this version uses a much faster implementation that never constructs the
		indices and uses simple slicing.
		
		Examples
		--------
		>>> a = np.zeros((3, 3), int)
		>>> np.fill_diagonal(a, 5)
		>>> a
		array([[5, 0, 0],
		       [0, 5, 0],
		       [0, 0, 5]])
		
		The same function can operate on a 4-D array:
		
		>>> a = np.zeros((3, 3, 3, 3), int)
		>>> np.fill_diagonal(a, 4)
		
		We only show a few blocks for clarity:
		
		>>> a[0, 0]
		array([[4, 0, 0],
		       [0, 0, 0],
		       [0, 0, 0]])
		>>> a[1, 1]
		array([[0, 0, 0],
		       [0, 4, 0],
		       [0, 0, 0]])
		>>> a[2, 2]
		array([[0, 0, 0],
		       [0, 0, 0],
		       [0, 0, 4]])
		
		The wrap option affects only tall matrices:
		
		>>> # tall matrices no wrap
		>>> a = np.zeros((5, 3),int)
		>>> fill_diagonal(a, 4)
		>>> a
		array([[4, 0, 0],
		       [0, 4, 0],
		       [0, 0, 4],
		       [0, 0, 0],
		       [0, 0, 0]])
		
		>>> # tall matrices wrap
		>>> a = np.zeros((5, 3),int)
		>>> fill_diagonal(a, 4, wrap=True)
		>>> a
		array([[4, 0, 0],
		       [0, 4, 0],
		       [0, 0, 4],
		       [0, 0, 0],
		       [4, 0, 0]])
		
		>>> # wide matrices
		>>> a = np.zeros((3, 5),int)
		>>> fill_diagonal(a, 4, wrap=True)
		>>> a
		array([[4, 0, 0, 0, 0],
		       [0, 4, 0, 0, 0],
		       [0, 0, 4, 0, 0]])
	**/
	static public function fill_diagonal(a:Dynamic, val:Dynamic, ?wrap:Dynamic):Dynamic;
	/**
		Determine common type following standard coercion rules.
		
		Parameters
		----------
		array_types : sequence
		    A list of dtypes or dtype convertible objects representing arrays.
		scalar_types : sequence
		    A list of dtypes or dtype convertible objects representing scalars.
		
		Returns
		-------
		datatype : dtype
		    The common data type, which is the maximum of `array_types` ignoring
		    `scalar_types`, unless the maximum of `scalar_types` is of a
		    different kind (`dtype.kind`). If the kind is not understood, then
		    None is returned.
		
		See Also
		--------
		dtype, common_type, can_cast, mintypecode
		
		Examples
		--------
		>>> np.find_common_type([], [np.int64, np.float32, complex])
		dtype('complex128')
		>>> np.find_common_type([np.int64, np.float32], [])
		dtype('float64')
		
		The standard casting rules ensure that a scalar cannot up-cast an
		array unless the scalar is of a fundamentally different kind of data
		(i.e. under a different hierarchy in the data type hierarchy) then
		the array:
		
		>>> np.find_common_type([np.float32], [np.int64, np.float64])
		dtype('float32')
		
		Complex is of a different type, so it up-casts the float in the
		`array_types` argument:
		
		>>> np.find_common_type([np.float32], [complex])
		dtype('complex128')
		
		Type specifier strings are convertible to dtypes and can therefore
		be used instead of dtypes:
		
		>>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
		dtype('complex128')
	**/
	static public function find_common_type(array_types:Dynamic, scalar_types:Dynamic):Dynamic;
	/**
		Find artist objects.
		
		Recursively find all `.Artist` instances contained in the artist.
		
		Parameters
		----------
		match
		    A filter criterion for the matches. This can be
		
		    - *None*: Return all objects contained in artist.
		    - A function with signature ``def match(artist: Artist) -> bool``.
		      The result will only contain artists for which the function
		      returns *True*.
		    - A class instance: e.g., `.Line2D`. The result will only contain
		      artists of this class or its subclasses (``isinstance`` check).
		
		include_self : bool
		    Include *self* in the list to be checked for a match.
		
		Returns
		-------
		artists : list of `.Artist`
	**/
	static public function findobj(?o:Dynamic, ?match:Dynamic, ?include_self:Dynamic):Dynamic;
	/**
		Round to nearest integer towards zero.
		
		Round an array of floats element-wise to nearest integer towards zero.
		The rounded values are returned as floats.
		
		Parameters
		----------
		x : array_like
		    An array of floats to be rounded
		y : ndarray, optional
		    Output array
		
		Returns
		-------
		out : ndarray of floats
		    The array of rounded numbers
		
		See Also
		--------
		trunc, floor, ceil
		around : Round to given number of decimals
		
		Examples
		--------
		>>> np.fix(3.14)
		3.0
		>>> np.fix(3)
		3.0
		>>> np.fix([2.1, 2.9, -2.1, -2.9])
		array([ 2.,  2., -2., -2.])
	**/
	static public function fix(x:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Set the colormap to "flag".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function flag():Dynamic;
	/**
		Return indices that are non-zero in the flattened version of a.
		
		This is equivalent to np.nonzero(np.ravel(a))[0].
		
		Parameters
		----------
		a : array_like
		    Input data.
		
		Returns
		-------
		res : ndarray
		    Output array, containing the indices of the elements of `a.ravel()`
		    that are non-zero.
		
		See Also
		--------
		nonzero : Return the indices of the non-zero elements of the input array.
		ravel : Return a 1-D array containing the elements of the input array.
		
		Examples
		--------
		>>> x = np.arange(-2, 3)
		>>> x
		array([-2, -1,  0,  1,  2])
		>>> np.flatnonzero(x)
		array([0, 1, 3, 4])
		
		Use the indices of the non-zero elements as an index array to extract
		these elements:
		
		>>> x.ravel()[np.flatnonzero(x)]
		array([-2, -1,  1,  2])
	**/
	static public function flatnonzero(a:Dynamic):Dynamic;
	/**
		Return a generator of flattened nested containers
		
		For example:
		
		    >>> from matplotlib.cbook import flatten
		    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])
		    >>> print(list(flatten(l)))
		    ['John', 'Hunter', 1, 23, 42, 5, 23]
		
		By: Composite of Holger Krekel and Luther Blissett
		From: https://code.activestate.com/recipes/121294/
		and Recipe 1.12 in cookbook
	**/
	static public function flatten(seq:Dynamic, ?scalarp:Dynamic):Dynamic;
	/**
		Reverse the order of elements in an array along the given axis.
		
		The shape of the array is preserved, but the elements are reordered.
		
		.. versionadded:: 1.12.0
		
		Parameters
		----------
		m : array_like
		    Input array.
		axis : None or int or tuple of ints, optional
		     Axis or axes along which to flip over. The default,
		     axis=None, will flip over all of the axes of the input array.
		     If axis is negative it counts from the last to the first axis.
		
		     If axis is a tuple of ints, flipping is performed on all of the axes
		     specified in the tuple.
		
		     .. versionchanged:: 1.15.0
		        None and tuples of axes are supported
		
		Returns
		-------
		out : array_like
		    A view of `m` with the entries of axis reversed.  Since a view is
		    returned, this operation is done in constant time.
		
		See Also
		--------
		flipud : Flip an array vertically (axis=0).
		fliplr : Flip an array horizontally (axis=1).
		
		Notes
		-----
		flip(m, 0) is equivalent to flipud(m).
		
		flip(m, 1) is equivalent to fliplr(m).
		
		flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.
		
		flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
		positions.
		
		flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
		position 0 and position 1.
		
		Examples
		--------
		>>> A = np.arange(8).reshape((2,2,2))
		>>> A
		array([[[0, 1],
		        [2, 3]],
		       [[4, 5],
		        [6, 7]]])
		>>> flip(A, 0)
		array([[[4, 5],
		        [6, 7]],
		       [[0, 1],
		        [2, 3]]])
		>>> flip(A, 1)
		array([[[2, 3],
		        [0, 1]],
		       [[6, 7],
		        [4, 5]]])
		>>> np.flip(A)
		array([[[7, 6],
		        [5, 4]],
		       [[3, 2],
		        [1, 0]]])
		>>> np.flip(A, (0, 2))
		array([[[5, 4],
		        [7, 6]],
		       [[1, 0],
		        [3, 2]]])
		>>> A = np.random.randn(3,4,5)
		>>> np.all(flip(A,2) == A[:,:,::-1,...])
		True
	**/
	static public function flip(m:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Flip array in the left/right direction.
		
		Flip the entries in each row in the left/right direction.
		Columns are preserved, but appear in a different order than before.
		
		Parameters
		----------
		m : array_like
		    Input array, must be at least 2-D.
		
		Returns
		-------
		f : ndarray
		    A view of `m` with the columns reversed.  Since a view
		    is returned, this operation is :math:`\mathcal O(1)`.
		
		See Also
		--------
		flipud : Flip array in the up/down direction.
		rot90 : Rotate array counterclockwise.
		
		Notes
		-----
		Equivalent to m[:,::-1]. Requires the array to be at least 2-D.
		
		Examples
		--------
		>>> A = np.diag([1.,2.,3.])
		>>> A
		array([[ 1.,  0.,  0.],
		       [ 0.,  2.,  0.],
		       [ 0.,  0.,  3.]])
		>>> np.fliplr(A)
		array([[ 0.,  0.,  1.],
		       [ 0.,  2.,  0.],
		       [ 3.,  0.,  0.]])
		
		>>> A = np.random.randn(2,3,5)
		>>> np.all(np.fliplr(A) == A[:,::-1,...])
		True
	**/
	static public function fliplr(m:Dynamic):Dynamic;
	/**
		Flip array in the up/down direction.
		
		Flip the entries in each column in the up/down direction.
		Rows are preserved, but appear in a different order than before.
		
		Parameters
		----------
		m : array_like
		    Input array.
		
		Returns
		-------
		out : array_like
		    A view of `m` with the rows reversed.  Since a view is
		    returned, this operation is :math:`\mathcal O(1)`.
		
		See Also
		--------
		fliplr : Flip array in the left/right direction.
		rot90 : Rotate array counterclockwise.
		
		Notes
		-----
		Equivalent to ``m[::-1,...]``.
		Does not require the array to be two-dimensional.
		
		Examples
		--------
		>>> A = np.diag([1.0, 2, 3])
		>>> A
		array([[ 1.,  0.,  0.],
		       [ 0.,  2.,  0.],
		       [ 0.,  0.,  3.]])
		>>> np.flipud(A)
		array([[ 0.,  0.,  3.],
		       [ 0.,  2.,  0.],
		       [ 1.,  0.,  0.]])
		
		>>> A = np.random.randn(2,3,5)
		>>> np.all(np.flipud(A) == A[::-1,...])
		True
		
		>>> np.flipud([1,2])
		array([2, 1])
	**/
	static public function flipud(m:Dynamic):Dynamic;
	/**
		float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		First array elements raised to powers from second array, element-wise.
		
		Raise each base in `x1` to the positionally-corresponding power in `x2`.
		`x1` and `x2` must be broadcastable to the same shape. This differs from
		the power function in that integers, float16, and float32  are promoted to
		floats with a minimum precision of float64 so that the result is always
		inexact.  The intent is that the function will return a usable result for
		negative powers and seldom overflow for positive powers.
		
		.. versionadded:: 1.12.0
		
		Parameters
		----------
		x1 : array_like
		    The bases.
		x2 : array_like
		    The exponents.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The bases in `x1` raised to the exponents in `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		power : power function that preserves type
		
		Examples
		--------
		Cube each element in a list.
		
		>>> x1 = range(6)
		>>> x1
		[0, 1, 2, 3, 4, 5]
		>>> np.float_power(x1, 3)
		array([   0.,    1.,    8.,   27.,   64.,  125.])
		
		Raise the bases to different exponents.
		
		>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
		>>> np.float_power(x1, x2)
		array([  0.,   1.,   8.,  27.,  16.,   5.])
		
		The effect of broadcasting.
		
		>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
		>>> x2
		array([[1, 2, 3, 3, 2, 1],
		       [1, 2, 3, 3, 2, 1]])
		>>> np.float_power(x1, x2)
		array([[  0.,   1.,   8.,  27.,  16.,   5.],
		       [  0.,   1.,   8.,  27.,  16.,   5.]])
	**/
	static public function float_power(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the floor of the input, element-wise.
		
		The floor of the scalar `x` is the largest integer `i`, such that
		`i <= x`.  It is often denoted as :math:`\lfloor x \rfloor`.
		
		Parameters
		----------
		x : array_like
		    Input data.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The floor of each element in `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		ceil, trunc, rint
		
		Notes
		-----
		Some spreadsheet programs calculate the "floor-towards-zero", in other
		words ``floor(-2.5) == -2``.  NumPy instead uses the definition of
		`floor` where `floor(-2.5) == -3`.
		
		Examples
		--------
		>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
		>>> np.floor(a)
		array([-2., -2., -1.,  0.,  1.,  1.,  2.])
	**/
	static public function floor(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the largest integer smaller or equal to the division of the inputs.
		It is equivalent to the Python ``//`` operator and pairs with the
		Python ``%`` (`remainder`), function so that ``b = a % b + b * (a // b)``
		up to roundoff.
		
		Parameters
		----------
		x1 : array_like
		    Numerator.
		x2 : array_like
		    Denominator.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    y = floor(`x1`/`x2`)
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		remainder : Remainder complementary to floor_divide.
		divmod : Simultaneous floor division and remainder.
		divide : Standard division.
		floor : Round a number to the nearest integer toward minus infinity.
		ceil : Round a number to the nearest integer toward infinity.
		
		Examples
		--------
		>>> np.floor_divide(7,3)
		2
		>>> np.floor_divide([1., 2., 3., 4.], 2.5)
		array([ 0.,  0.,  1.,  1.])
	**/
	static public function floor_divide(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Element-wise maximum of array elements.
		
		Compare two arrays and returns a new array containing the element-wise
		maxima. If one of the elements being compared is a NaN, then the
		non-nan element is returned. If both elements are NaNs then the first
		is returned.  The latter distinction is important for complex NaNs,
		which are defined as at least one of the real or imaginary parts being
		a NaN. The net effect is that NaNs are ignored when possible.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays holding the elements to be compared. They must have
		    the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The maximum of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		fmin :
		    Element-wise minimum of two arrays, ignores NaNs.
		maximum :
		    Element-wise maximum of two arrays, propagates NaNs.
		amax :
		    The maximum value of an array along a given axis, propagates NaNs.
		nanmax :
		    The maximum value of an array along a given axis, ignores NaNs.
		
		minimum, amin, nanmin
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		The fmax is equivalent to ``np.where(x1 >= x2, x1, x2)`` when neither
		x1 nor x2 are NaNs, but it is faster and does proper broadcasting.
		
		Examples
		--------
		>>> np.fmax([2, 3, 4], [1, 5, 2])
		array([ 2.,  5.,  4.])
		
		>>> np.fmax(np.eye(2), [0.5, 2])
		array([[ 1. ,  2. ],
		       [ 0.5,  2. ]])
		
		>>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
		array([  0.,   0.,  NaN])
	**/
	static public function fmax(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Element-wise minimum of array elements.
		
		Compare two arrays and returns a new array containing the element-wise
		minima. If one of the elements being compared is a NaN, then the
		non-nan element is returned. If both elements are NaNs then the first
		is returned.  The latter distinction is important for complex NaNs,
		which are defined as at least one of the real or imaginary parts being
		a NaN. The net effect is that NaNs are ignored when possible.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays holding the elements to be compared. They must have
		    the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The minimum of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		fmax :
		    Element-wise maximum of two arrays, ignores NaNs.
		minimum :
		    Element-wise minimum of two arrays, propagates NaNs.
		amin :
		    The minimum value of an array along a given axis, propagates NaNs.
		nanmin :
		    The minimum value of an array along a given axis, ignores NaNs.
		
		maximum, amax, nanmax
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		The fmin is equivalent to ``np.where(x1 <= x2, x1, x2)`` when neither
		x1 nor x2 are NaNs, but it is faster and does proper broadcasting.
		
		Examples
		--------
		>>> np.fmin([2, 3, 4], [1, 5, 2])
		array([1, 3, 2])
		
		>>> np.fmin(np.eye(2), [0.5, 2])
		array([[ 0.5,  0. ],
		       [ 0. ,  1. ]])
		
		>>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])
		array([  0.,   0.,  NaN])
	**/
	static public function fmin(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the element-wise remainder of division.
		
		This is the NumPy implementation of the C library function fmod, the
		remainder has the same sign as the dividend `x1`. It is equivalent to
		the Matlab(TM) ``rem`` function and should not be confused with the
		Python modulus operator ``x1 % x2``.
		
		Parameters
		----------
		x1 : array_like
		    Dividend.
		x2 : array_like
		    Divisor.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : array_like
		    The remainder of the division of `x1` by `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		remainder : Equivalent to the Python ``%`` operator.
		divide
		
		Notes
		-----
		The result of the modulo operation for negative dividend and divisors
		is bound by conventions. For `fmod`, the sign of result is the sign of
		the dividend, while for `remainder` the sign of the result is the sign
		of the divisor. The `fmod` function is equivalent to the Matlab(TM)
		``rem`` function.
		
		Examples
		--------
		>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
		array([-1,  0, -1,  1,  0,  1])
		>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
		array([1, 0, 1, 1, 0, 1])
		
		>>> np.fmod([5, 3], [2, 2.])
		array([ 1.,  1.])
		>>> a = np.arange(-3, 3).reshape(3, 2)
		>>> a
		array([[-3, -2],
		       [-1,  0],
		       [ 1,  2]])
		>>> np.fmod(a, [2,2])
		array([[-1,  0],
		       [-1,  0],
		       [ 1,  0]])
	**/
	static public function fmod(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Format a floating-point scalar as a decimal string in positional notation.
		
		Provides control over rounding, trimming and padding. Uses and assumes
		IEEE unbiased rounding. Uses the "Dragon4" algorithm.
		
		Parameters
		----------
		x : python float or numpy floating scalar
		    Value to format.
		precision : non-negative integer or None, optional
		    Maximum number of digits to print. May be None if `unique` is
		    `True`, but must be an integer if unique is `False`.
		unique : boolean, optional
		    If `True`, use a digit-generation strategy which gives the shortest
		    representation which uniquely identifies the floating-point number from
		    other values of the same type, by judicious rounding. If `precision`
		    was omitted, print out all necessary digits, otherwise digit generation
		    is cut off after `precision` digits and the remaining value is rounded.
		    If `False`, digits are generated as if printing an infinite-precision
		    value and stopping after `precision` digits, rounding the remaining
		    value.
		fractional : boolean, optional
		    If `True`, the cutoff of `precision` digits refers to the total number
		    of digits after the decimal point, including leading zeros.
		    If `False`, `precision` refers to the total number of significant
		    digits, before or after the decimal point, ignoring leading zeros.
		trim : one of 'k', '.', '0', '-', optional
		    Controls post-processing trimming of trailing digits, as follows:
		
		    * 'k' : keep trailing zeros, keep decimal point (no trimming)
		    * '.' : trim all trailing zeros, leave decimal point
		    * '0' : trim all but the zero before the decimal point. Insert the
		      zero if it is missing.
		    * '-' : trim trailing zeros and any trailing decimal point
		sign : boolean, optional
		    Whether to show the sign for positive values.
		pad_left : non-negative integer, optional
		    Pad the left side of the string with whitespace until at least that
		    many characters are to the left of the decimal point.
		pad_right : non-negative integer, optional
		    Pad the right side of the string with whitespace until at least that
		    many characters are to the right of the decimal point.
		
		Returns
		-------
		rep : string
		    The string representation of the floating point value
		
		See Also
		--------
		format_float_scientific
		
		Examples
		--------
		>>> np.format_float_positional(np.float32(np.pi))
		'3.1415927'
		>>> np.format_float_positional(np.float16(np.pi))
		'3.14'
		>>> np.format_float_positional(np.float16(0.3))
		'0.3'
		>>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
		'0.3000488281'
	**/
	static public function format_float_positional(x:Dynamic, ?precision:Dynamic, ?unique:Dynamic, ?fractional:Dynamic, ?trim:Dynamic, ?sign:Dynamic, ?pad_left:Dynamic, ?pad_right:Dynamic):String;
	/**
		Format a floating-point scalar as a decimal string in scientific notation.
		
		Provides control over rounding, trimming and padding. Uses and assumes
		IEEE unbiased rounding. Uses the "Dragon4" algorithm.
		
		Parameters
		----------
		x : python float or numpy floating scalar
		    Value to format.
		precision : non-negative integer or None, optional
		    Maximum number of digits to print. May be None if `unique` is
		    `True`, but must be an integer if unique is `False`.
		unique : boolean, optional
		    If `True`, use a digit-generation strategy which gives the shortest
		    representation which uniquely identifies the floating-point number from
		    other values of the same type, by judicious rounding. If `precision`
		    was omitted, print all necessary digits, otherwise digit generation is
		    cut off after `precision` digits and the remaining value is rounded.
		    If `False`, digits are generated as if printing an infinite-precision
		    value and stopping after `precision` digits, rounding the remaining
		    value.
		trim : one of 'k', '.', '0', '-', optional
		    Controls post-processing trimming of trailing digits, as follows:
		
		    * 'k' : keep trailing zeros, keep decimal point (no trimming)
		    * '.' : trim all trailing zeros, leave decimal point
		    * '0' : trim all but the zero before the decimal point. Insert the
		      zero if it is missing.
		    * '-' : trim trailing zeros and any trailing decimal point
		sign : boolean, optional
		    Whether to show the sign for positive values.
		pad_left : non-negative integer, optional
		    Pad the left side of the string with whitespace until at least that
		    many characters are to the left of the decimal point.
		exp_digits : non-negative integer, optional
		    Pad the exponent with zeros until it contains at least this many digits.
		    If omitted, the exponent will be at least 2 digits.
		
		Returns
		-------
		rep : string
		    The string representation of the floating point value
		
		See Also
		--------
		format_float_positional
		
		Examples
		--------
		>>> np.format_float_scientific(np.float32(np.pi))
		'3.1415927e+00'
		>>> s = np.float32(1.23e24)
		>>> np.format_float_scientific(s, unique=False, precision=15)
		'1.230000071797338e+24'
		>>> np.format_float_scientific(s, exp_digits=4)
		'1.23e+0024'
	**/
	static public function format_float_scientific(x:Dynamic, ?precision:Dynamic, ?unique:Dynamic, ?trim:Dynamic, ?sign:Dynamic, ?pad_left:Dynamic, ?exp_digits:Dynamic):String;
	/**
		frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Decompose the elements of x into mantissa and twos exponent.
		
		Returns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.
		The mantissa is lies in the open interval(-1, 1), while the twos
		exponent is a signed integer.
		
		Parameters
		----------
		x : array_like
		    Array of numbers to be decomposed.
		out1 : ndarray, optional
		    Output array for the mantissa. Must have the same shape as `x`.
		out2 : ndarray, optional
		    Output array for the exponent. Must have the same shape as `x`.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		mantissa : ndarray
		    Floating values between -1 and 1.
		    This is a scalar if `x` is a scalar.
		exponent : ndarray
		    Integer exponents of 2.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		ldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.
		
		Notes
		-----
		Complex dtypes are not supported, they will raise a TypeError.
		
		Examples
		--------
		>>> x = np.arange(9)
		>>> y1, y2 = np.frexp(x)
		>>> y1
		array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,
		        0.5  ])
		>>> y2
		array([0, 1, 2, 2, 3, 3, 3, 3, 4])
		>>> y1 * 2**y2
		array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])
	**/
	static public function frexp(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		frombuffer(buffer, dtype=float, count=-1, offset=0)
		
		Interpret a buffer as a 1-dimensional array.
		
		Parameters
		----------
		buffer : buffer_like
		    An object that exposes the buffer interface.
		dtype : data-type, optional
		    Data-type of the returned array; default: float.
		count : int, optional
		    Number of items to read. ``-1`` means all data in the buffer.
		offset : int, optional
		    Start reading the buffer from this offset (in bytes); default: 0.
		
		Notes
		-----
		If the buffer has data that is not in machine byte-order, this should
		be specified as part of the data-type, e.g.::
		
		  >>> dt = np.dtype(int)
		  >>> dt = dt.newbyteorder('>')
		  >>> np.frombuffer(buf, dtype=dt)
		
		The data of the resulting array will not be byteswapped, but will be
		interpreted correctly.
		
		Examples
		--------
		>>> s = 'hello world'
		>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
		array(['w', 'o', 'r', 'l', 'd'],
		      dtype='|S1')
		
		>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
		array([1, 2], dtype=uint8)
		>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
		array([1, 2, 3], dtype=uint8)
	**/
	static public function frombuffer(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		fromfile(file, dtype=float, count=-1, sep='')
		
		Construct an array from data in a text or binary file.
		
		A highly efficient way of reading binary data with a known data-type,
		as well as parsing simply formatted text files.  Data written using the
		`tofile` method can be read using this function.
		
		Parameters
		----------
		file : file or str
		    Open file object or filename.
		dtype : data-type
		    Data type of the returned array.
		    For binary files, it is used to determine the size and byte-order
		    of the items in the file.
		count : int
		    Number of items to read. ``-1`` means all items (i.e., the complete
		    file).
		sep : str
		    Separator between items if file is a text file.
		    Empty ("") separator means the file should be treated as binary.
		    Spaces (" ") in the separator match zero or more whitespace characters.
		    A separator consisting only of spaces must match at least one
		    whitespace.
		
		See also
		--------
		load, save
		ndarray.tofile
		loadtxt : More flexible way of loading data from a text file.
		
		Notes
		-----
		Do not rely on the combination of `tofile` and `fromfile` for
		data storage, as the binary files generated are are not platform
		independent.  In particular, no byte-order or data-type information is
		saved.  Data can be stored in the platform independent ``.npy`` format
		using `save` and `load` instead.
		
		Examples
		--------
		Construct an ndarray:
		
		>>> dt = np.dtype([('time', [('min', int), ('sec', int)]),
		...                ('temp', float)])
		>>> x = np.zeros((1,), dtype=dt)
		>>> x['time']['min'] = 10; x['temp'] = 98.25
		>>> x
		array([((10, 0), 98.25)],
		      dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])
		
		Save the raw data to disk:
		
		>>> import os
		>>> fname = os.tmpnam()
		>>> x.tofile(fname)
		
		Read the raw data from disk:
		
		>>> np.fromfile(fname, dtype=dt)
		array([((10, 0), 98.25)],
		      dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])
		
		The recommended way to store and load data:
		
		>>> np.save(fname, x)
		>>> np.load(fname + '.npy')
		array([((10, 0), 98.25)],
		      dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])
	**/
	static public function fromfile(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Construct an array by executing a function over each coordinate.
		
		The resulting array therefore has a value ``fn(x, y, z)`` at
		coordinate ``(x, y, z)``.
		
		Parameters
		----------
		function : callable
		    The function is called with N parameters, where N is the rank of
		    `shape`.  Each parameter represents the coordinates of the array
		    varying along a specific axis.  For example, if `shape`
		    were ``(2, 2)``, then the parameters would be
		    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
		shape : (N,) tuple of ints
		    Shape of the output array, which also determines the shape of
		    the coordinate arrays passed to `function`.
		dtype : data-type, optional
		    Data-type of the coordinate arrays passed to `function`.
		    By default, `dtype` is float.
		
		Returns
		-------
		fromfunction : any
		    The result of the call to `function` is passed back directly.
		    Therefore the shape of `fromfunction` is completely determined by
		    `function`.  If `function` returns a scalar value, the shape of
		    `fromfunction` would not match the `shape` parameter.
		
		See Also
		--------
		indices, meshgrid
		
		Notes
		-----
		Keywords other than `dtype` are passed to `function`.
		
		Examples
		--------
		>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
		array([[ True, False, False],
		       [False,  True, False],
		       [False, False,  True]])
		
		>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
		array([[0, 1, 2],
		       [1, 2, 3],
		       [2, 3, 4]])
	**/
	static public function fromfunction(_function:Dynamic, shape:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		fromiter(iterable, dtype, count=-1)
		
		Create a new 1-dimensional array from an iterable object.
		
		Parameters
		----------
		iterable : iterable object
		    An iterable object providing data for the array.
		dtype : data-type
		    The data-type of the returned array.
		count : int, optional
		    The number of items to read from *iterable*.  The default is -1,
		    which means all data is read.
		
		Returns
		-------
		out : ndarray
		    The output array.
		
		Notes
		-----
		Specify `count` to improve performance.  It allows ``fromiter`` to
		pre-allocate the output array, instead of resizing it on demand.
		
		Examples
		--------
		>>> iterable = (x*x for x in range(5))
		>>> np.fromiter(iterable, float)
		array([  0.,   1.,   4.,   9.,  16.])
	**/
	static public function fromiter(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		frompyfunc(func, nin, nout)
		
		Takes an arbitrary Python function and returns a NumPy ufunc.
		
		Can be used, for example, to add broadcasting to a built-in Python
		function (see Examples section).
		
		Parameters
		----------
		func : Python function object
		    An arbitrary Python function.
		nin : int
		    The number of input arguments.
		nout : int
		    The number of objects returned by `func`.
		
		Returns
		-------
		out : ufunc
		    Returns a NumPy universal function (``ufunc``) object.
		
		See Also
		--------
		vectorize : evaluates pyfunc over input arrays using broadcasting rules of numpy
		
		Notes
		-----
		The returned ufunc always returns PyObject arrays.
		
		Examples
		--------
		Use frompyfunc to add broadcasting to the Python function ``oct``:
		
		>>> oct_array = np.frompyfunc(oct, 1, 1)
		>>> oct_array(np.array((10, 30, 100)))
		array([012, 036, 0144], dtype=object)
		>>> np.array((oct(10), oct(30), oct(100))) # for comparison
		array(['012', '036', '0144'],
		      dtype='|S4')
	**/
	static public function frompyfunc(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Construct an array from a text file, using regular expression parsing.
		
		The returned array is always a structured array, and is constructed from
		all matches of the regular expression in the file. Groups in the regular
		expression are converted to fields of the structured array.
		
		Parameters
		----------
		file : str or file
		    File name or file object to read.
		regexp : str or regexp
		    Regular expression used to parse the file.
		    Groups in the regular expression correspond to fields in the dtype.
		dtype : dtype or list of dtypes
		    Dtype for the structured array.
		encoding : str, optional
		    Encoding used to decode the inputfile. Does not apply to input streams.
		
		    .. versionadded:: 1.14.0
		
		Returns
		-------
		output : ndarray
		    The output array, containing the part of the content of `file` that
		    was matched by `regexp`. `output` is always a structured array.
		
		Raises
		------
		TypeError
		    When `dtype` is not a valid dtype for a structured array.
		
		See Also
		--------
		fromstring, loadtxt
		
		Notes
		-----
		Dtypes for structured arrays can be specified in several forms, but all
		forms specify at least the data type and field name. For details see
		`doc.structured_arrays`.
		
		Examples
		--------
		>>> f = open('test.dat', 'w')
		>>> f.write("1312 foo\n1534  bar\n444   qux")
		>>> f.close()
		
		>>> regexp = r"(\d+)\s+(...)"  # match [digits, whitespace, anything]
		>>> output = np.fromregex('test.dat', regexp,
		...                       [('num', np.int64), ('key', 'S3')])
		>>> output
		array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],
		      dtype=[('num', '<i8'), ('key', '|S3')])
		>>> output['num']
		array([1312, 1534,  444], dtype=int64)
	**/
	static public function fromregex(file:Dynamic, regexp:Dynamic, dtype:Dynamic, ?encoding:Dynamic):Dynamic;
	/**
		fromstring(string, dtype=float, count=-1, sep='')
		
		A new 1-D array initialized from text data in a string.
		
		Parameters
		----------
		string : str
		    A string containing the data.
		dtype : data-type, optional
		    The data type of the array; default: float.  For binary input data,
		    the data must be in exactly this format.
		count : int, optional
		    Read this number of `dtype` elements from the data.  If this is
		    negative (the default), the count will be determined from the
		    length of the data.
		sep : str, optional
		    The string separating numbers in the data; extra whitespace between
		    elements is also ignored.
		
		    .. deprecated:: 1.14
		        If this argument is not provided, `fromstring` falls back on the
		        behaviour of `frombuffer` after encoding unicode string inputs as
		        either utf-8 (python 3), or the default encoding (python 2).
		
		Returns
		-------
		arr : ndarray
		    The constructed array.
		
		Raises
		------
		ValueError
		    If the string is not the correct size to satisfy the requested
		    `dtype` and `count`.
		
		See Also
		--------
		frombuffer, fromfile, fromiter
		
		Examples
		--------
		>>> np.fromstring('1 2', dtype=int, sep=' ')
		array([1, 2])
		>>> np.fromstring('1, 2', dtype=int, sep=',')
		array([1, 2])
	**/
	static public function fromstring(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return a new array of given shape and type, filled with `fill_value`.
		
		Parameters
		----------
		shape : int or sequence of ints
		    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
		fill_value : scalar
		    Fill value.
		dtype : data-type, optional
		    The desired data-type for the array  The default, `None`, means
		     `np.array(fill_value).dtype`.
		order : {'C', 'F'}, optional
		    Whether to store multidimensional data in C- or Fortran-contiguous
		    (row- or column-wise) order in memory.
		
		Returns
		-------
		out : ndarray
		    Array of `fill_value` with the given shape, dtype, and order.
		
		See Also
		--------
		full_like : Return a new array with shape of input filled with value.
		empty : Return a new uninitialized array.
		ones : Return a new array setting values to one.
		zeros : Return a new array setting values to zero.
		
		Examples
		--------
		>>> np.full((2, 2), np.inf)
		array([[ inf,  inf],
		       [ inf,  inf]])
		>>> np.full((2, 2), 10)
		array([[10, 10],
		       [10, 10]])
	**/
	static public function full(shape:Dynamic, fill_value:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Return a full array with the same shape and type as a given array.
		
		Parameters
		----------
		a : array_like
		    The shape and data-type of `a` define these same attributes of
		    the returned array.
		fill_value : scalar
		    Fill value.
		dtype : data-type, optional
		    Overrides the data type of the result.
		order : {'C', 'F', 'A', or 'K'}, optional
		    Overrides the memory layout of the result. 'C' means C-order,
		    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
		    'C' otherwise. 'K' means match the layout of `a` as closely
		    as possible.
		subok : bool, optional.
		    If True, then the newly created array will use the sub-class
		    type of 'a', otherwise it will be a base-class array. Defaults
		    to True.
		
		Returns
		-------
		out : ndarray
		    Array of `fill_value` with the same shape and type as `a`.
		
		See Also
		--------
		empty_like : Return an empty array with shape and type of input.
		ones_like : Return an array of ones with shape and type of input.
		zeros_like : Return an array of zeros with shape and type of input.
		full : Return a new array of given shape filled with value.
		
		Examples
		--------
		>>> x = np.arange(6, dtype=int)
		>>> np.full_like(x, 1)
		array([1, 1, 1, 1, 1, 1])
		>>> np.full_like(x, 0.1)
		array([0, 0, 0, 0, 0, 0])
		>>> np.full_like(x, 0.1, dtype=np.double)
		array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
		>>> np.full_like(x, np.nan, dtype=np.double)
		array([ nan,  nan,  nan,  nan,  nan,  nan])
		
		>>> y = np.arange(6, dtype=np.double)
		>>> np.full_like(y, 0.1)
		array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
	**/
	static public function full_like(a:Dynamic, fill_value:Dynamic, ?dtype:Dynamic, ?order:Dynamic, ?subok:Dynamic):Dynamic;
	/**
		Compute the future value.
		
		Given:
		 * a present value, `pv`
		 * an interest `rate` compounded once per period, of which
		   there are
		 * `nper` total
		 * a (fixed) payment, `pmt`, paid either
		 * at the beginning (`when` = {'begin', 1}) or the end
		   (`when` = {'end', 0}) of each period
		
		Return:
		   the value at the end of the `nper` periods
		
		Parameters
		----------
		rate : scalar or array_like of shape(M, )
		    Rate of interest as decimal (not per cent) per period
		nper : scalar or array_like of shape(M, )
		    Number of compounding periods
		pmt : scalar or array_like of shape(M, )
		    Payment
		pv : scalar or array_like of shape(M, )
		    Present value
		when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
		    When payments are due ('begin' (1) or 'end' (0)).
		    Defaults to {'end', 0}.
		
		Returns
		-------
		out : ndarray
		    Future values.  If all input is scalar, returns a scalar float.  If
		    any input is array_like, returns future values for each input element.
		    If multiple inputs are array_like, they all must have the same shape.
		
		Notes
		-----
		The future value is computed by solving the equation::
		
		 fv +
		 pv*(1+rate)**nper +
		 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0
		
		or, when ``rate == 0``::
		
		 fv + pv + pmt * nper == 0
		
		References
		----------
		.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
		   Open Document Format for Office Applications (OpenDocument)v1.2,
		   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
		   Pre-Draft 12. Organization for the Advancement of Structured Information
		   Standards (OASIS). Billerica, MA, USA. [ODT Document].
		   Available:
		   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
		   OpenDocument-formula-20090508.odt
		
		Examples
		--------
		What is the future value after 10 years of saving $100 now, with
		an additional monthly savings of $100.  Assume the interest rate is
		5% (annually) compounded monthly?
		
		>>> np.fv(0.05/12, 10*12, -100, -100)
		15692.928894335748
		
		By convention, the negative sign represents cash flow out (i.e. money not
		available today).  Thus, saving $100 a month at 5% annual interest leads
		to $15,692.93 available to spend in 10 years.
		
		If any input is array_like, returns an array of equal shape.  Let's
		compare different interest rates from the example above.
		
		>>> a = np.array((0.05, 0.06, 0.07))/12
		>>> np.fv(a, 10*12, -100, -100)
		array([ 15692.92889434,  16569.87435405,  17509.44688102])
	**/
	static public function fv(rate:Dynamic, nper:Dynamic, pmt:Dynamic, pv:Dynamic, ?when:Dynamic):Dynamic;
	/**
		gamma(shape, scale=1.0, size=None)
		
		Draw samples from a Gamma distribution.
		
		Samples are drawn from a Gamma distribution with specified parameters,
		`shape` (sometimes designated "k") and `scale` (sometimes designated
		"theta"), where both parameters are > 0.
		
		Parameters
		----------
		shape : float or array_like of floats
		    The shape of the gamma distribution. Should be greater than zero.
		scale : float or array_like of floats, optional
		    The scale of the gamma distribution. Should be greater than zero.
		    Default is equal to 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``shape`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized gamma distribution.
		
		See Also
		--------
		scipy.stats.gamma : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Gamma distribution is
		
		.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},
		
		where :math:`k` is the shape and :math:`\theta` the scale,
		and :math:`\Gamma` is the Gamma function.
		
		The Gamma distribution is often used to model the times to failure of
		electronic components, and arises naturally in processes for which the
		waiting times between Poisson distributed events are relevant.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Gamma Distribution." From MathWorld--A
		       Wolfram Web Resource.
		       http://mathworld.wolfram.com/GammaDistribution.html
		.. [2] Wikipedia, "Gamma distribution",
		       https://en.wikipedia.org/wiki/Gamma_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
		>>> s = np.random.gamma(shape, scale, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> import scipy.special as sps
		>>> count, bins, ignored = plt.hist(s, 50, density=True)
		>>> y = bins**(shape-1)*(np.exp(-bins/scale) /
		...                      (sps.gamma(shape)*scale**shape))
		>>> plt.plot(bins, y, linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function gamma(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Get the current :class:`~matplotlib.axes.Axes` instance on the
		current figure matching the given keyword args, or create one.
		
		Examples
		--------
		To get the current polar axes on the current figure::
		
		    plt.gca(projection='polar')
		
		If the current axes doesn't exist, or isn't a polar one, the appropriate
		axes will be created and then returned.
		
		See Also
		--------
		matplotlib.figure.Figure.gca : The figure's gca method.
	**/
	static public function gca(?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns the greatest common divisor of ``|x1|`` and ``|x2|``
		
		Parameters
		----------
		x1, x2 : array_like, int
		    Arrays of values
		
		Returns
		-------
		y : ndarray or scalar
		    The greatest common divisor of the absolute value of the inputs
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		lcm : The lowest common multiple
		
		Examples
		--------
		>>> np.gcd(12, 20)
		4
		>>> np.gcd.reduce([15, 25, 35])
		5
		>>> np.gcd(np.arange(6), 20)
		array([20,  1,  2,  1,  4,  5])
	**/
	static public function gcd(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Get the current figure.
		
		If no current figure exists, a new one is created using
		`~.pyplot.figure()`.
	**/
	static public function gcf():Dynamic;
	/**
		Get the current colorable artist.  Specifically, returns the
		current :class:`~matplotlib.cm.ScalarMappable` instance (image or
		patch collection), or *None* if no images or patch collections
		have been defined.  The commands :func:`~matplotlib.pyplot.imshow`
		and :func:`~matplotlib.pyplot.figimage` create
		:class:`~matplotlib.image.Image` instances, and the commands
		:func:`~matplotlib.pyplot.pcolor` and
		:func:`~matplotlib.pyplot.scatter` create
		:class:`~matplotlib.collections.Collection` instances.  The
		current image is an attribute of the current axes, or the nearest
		earlier axes in the current figure that contains an image.
		
		Notes
		-----
		Historically, the only colorable artists were images; hence the name
		``gci`` (get current image).
	**/
	static public function gci():Dynamic;
	/**
		Load data from a text file, with missing values handled as specified.
		
		Each line past the first `skip_header` lines is split at the `delimiter`
		character, and characters following the `comments` character are discarded.
		
		Parameters
		----------
		fname : file, str, pathlib.Path, list of str, generator
		    File, filename, list, or generator to read.  If the filename
		    extension is `.gz` or `.bz2`, the file is first decompressed. Note
		    that generators must return byte strings in Python 3k.  The strings
		    in a list or produced by a generator are treated as lines.
		dtype : dtype, optional
		    Data type of the resulting array.
		    If None, the dtypes will be determined by the contents of each
		    column, individually.
		comments : str, optional
		    The character used to indicate the start of a comment.
		    All the characters occurring on a line after a comment are discarded
		delimiter : str, int, or sequence, optional
		    The string used to separate values.  By default, any consecutive
		    whitespaces act as delimiter.  An integer or sequence of integers
		    can also be provided as width(s) of each field.
		skiprows : int, optional
		    `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.
		skip_header : int, optional
		    The number of lines to skip at the beginning of the file.
		skip_footer : int, optional
		    The number of lines to skip at the end of the file.
		converters : variable, optional
		    The set of functions that convert the data of a column to a value.
		    The converters can also be used to provide a default value
		    for missing data: ``converters = {3: lambda s: float(s or 0)}``.
		missing : variable, optional
		    `missing` was removed in numpy 1.10. Please use `missing_values`
		    instead.
		missing_values : variable, optional
		    The set of strings corresponding to missing data.
		filling_values : variable, optional
		    The set of values to be used as default when the data are missing.
		usecols : sequence, optional
		    Which columns to read, with 0 being the first.  For example,
		    ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.
		names : {None, True, str, sequence}, optional
		    If `names` is True, the field names are read from the first line after
		    the first `skip_header` lines.  This line can optionally be proceeded
		    by a comment delimiter. If `names` is a sequence or a single-string of
		    comma-separated names, the names will be used to define the field names
		    in a structured dtype. If `names` is None, the names of the dtype
		    fields will be used, if any.
		excludelist : sequence, optional
		    A list of names to exclude. This list is appended to the default list
		    ['return','file','print']. Excluded names are appended an underscore:
		    for example, `file` would become `file_`.
		deletechars : str, optional
		    A string combining invalid characters that must be deleted from the
		    names.
		defaultfmt : str, optional
		    A format used to define default field names, such as "f%i" or "f_%02i".
		autostrip : bool, optional
		    Whether to automatically strip white spaces from the variables.
		replace_space : char, optional
		    Character(s) used in replacement of white spaces in the variables
		    names. By default, use a '_'.
		case_sensitive : {True, False, 'upper', 'lower'}, optional
		    If True, field names are case sensitive.
		    If False or 'upper', field names are converted to upper case.
		    If 'lower', field names are converted to lower case.
		unpack : bool, optional
		    If True, the returned array is transposed, so that arguments may be
		    unpacked using ``x, y, z = loadtxt(...)``
		usemask : bool, optional
		    If True, return a masked array.
		    If False, return a regular array.
		loose : bool, optional
		    If True, do not raise errors for invalid values.
		invalid_raise : bool, optional
		    If True, an exception is raised if an inconsistency is detected in the
		    number of columns.
		    If False, a warning is emitted and the offending lines are skipped.
		max_rows : int,  optional
		    The maximum number of rows to read. Must not be used with skip_footer
		    at the same time.  If given, the value must be at least 1. Default is
		    to read the entire file.
		
		    .. versionadded:: 1.10.0
		encoding : str, optional
		    Encoding used to decode the inputfile. Does not apply when `fname` is
		    a file object.  The special value 'bytes' enables backward compatibility
		    workarounds that ensure that you receive byte arrays when possible
		    and passes latin1 encoded strings to converters. Override this value to
		    receive unicode arrays and pass strings as input to converters.  If set
		    to None the system default is used. The default value is 'bytes'.
		
		    .. versionadded:: 1.14.0
		
		Returns
		-------
		out : ndarray
		    Data read from the text file. If `usemask` is True, this is a
		    masked array.
		
		See Also
		--------
		numpy.loadtxt : equivalent function when no data is missing.
		
		Notes
		-----
		* When spaces are used as delimiters, or when no delimiter has been given
		  as input, there should not be any missing data between two fields.
		* When the variables are named (either by a flexible dtype or with `names`,
		  there must not be any header in the file (else a ValueError
		  exception is raised).
		* Individual values are not stripped of spaces by default.
		  When using a custom converter, make sure the function does remove spaces.
		
		References
		----------
		.. [1] NumPy User Guide, section `I/O with NumPy
		       <https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html>`_.
		
		Examples
		---------
		>>> from io import StringIO
		>>> import numpy as np
		
		Comma delimited file with mixed dtype
		
		>>> s = StringIO(u"1,1.3,abcde")
		>>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),
		... ('mystring','S5')], delimiter=",")
		>>> data
		array((1, 1.3, 'abcde'),
		      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])
		
		Using dtype = None
		
		>>> s.seek(0) # needed for StringIO example only
		>>> data = np.genfromtxt(s, dtype=None,
		... names = ['myint','myfloat','mystring'], delimiter=",")
		>>> data
		array((1, 1.3, 'abcde'),
		      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])
		
		Specifying dtype and names
		
		>>> s.seek(0)
		>>> data = np.genfromtxt(s, dtype="i8,f8,S5",
		... names=['myint','myfloat','mystring'], delimiter=",")
		>>> data
		array((1, 1.3, 'abcde'),
		      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])
		
		An example with fixed-width columns
		
		>>> s = StringIO(u"11.3abcde")
		>>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],
		...     delimiter=[1,3,5])
		>>> data
		array((1, 1.3, 'abcde'),
		      dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '|S5')])
	**/
	static public function genfromtxt(fname:Dynamic, ?dtype:Dynamic, ?comments:Dynamic, ?delimiter:Dynamic, ?skip_header:Dynamic, ?skip_footer:Dynamic, ?converters:Dynamic, ?missing_values:Dynamic, ?filling_values:Dynamic, ?usecols:Dynamic, ?names:Dynamic, ?excludelist:Dynamic, ?deletechars:Dynamic, ?replace_space:Dynamic, ?autostrip:Dynamic, ?case_sensitive:Dynamic, ?defaultfmt:Dynamic, ?unpack:Dynamic, ?usemask:Dynamic, ?loose:Dynamic, ?invalid_raise:Dynamic, ?max_rows:Dynamic, ?encoding:Dynamic):Dynamic;
	/**
		geometric(p, size=None)
		
		Draw samples from the geometric distribution.
		
		Bernoulli trials are experiments with one of two outcomes:
		success or failure (an example of such an experiment is flipping
		a coin).  The geometric distribution models the number of trials
		that must be run in order to achieve success.  It is therefore
		supported on the positive integers, ``k = 1, 2, ...``.
		
		The probability mass function of the geometric distribution is
		
		.. math:: f(k) = (1 - p)^{k - 1} p
		
		where `p` is the probability of success of an individual trial.
		
		Parameters
		----------
		p : float or array_like of floats
		    The probability of success of an individual trial.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``p`` is a scalar.  Otherwise,
		    ``np.array(p).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized geometric distribution.
		
		Examples
		--------
		Draw ten thousand values from the geometric distribution,
		with the probability of an individual success equal to 0.35:
		
		>>> z = np.random.geometric(p=0.35, size=10000)
		
		How many trials succeeded after a single run?
		
		>>> (z == 1).sum() / 10000.
		0.34889999999999999 #random
	**/
	static public function geometric(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return numbers spaced evenly on a log scale (a geometric progression).
		
		This is similar to `logspace`, but with endpoints specified directly.
		Each output sample is a constant multiple of the previous.
		
		.. versionchanged:: 1.16.0
		    Non-scalar `start` and `stop` are now supported.
		
		Parameters
		----------
		start : array_like
		    The starting value of the sequence.
		stop : array_like
		    The final value of the sequence, unless `endpoint` is False.
		    In that case, ``num + 1`` values are spaced over the
		    interval in log-space, of which all but the last (a sequence of
		    length `num`) are returned.
		num : integer, optional
		    Number of samples to generate.  Default is 50.
		endpoint : boolean, optional
		    If true, `stop` is the last sample. Otherwise, it is not included.
		    Default is True.
		dtype : dtype
		    The type of the output array.  If `dtype` is not given, infer the data
		    type from the other input arguments.
		axis : int, optional
		    The axis in the result to store the samples.  Relevant only if start
		    or stop are array-like.  By default (0), the samples will be along a
		    new axis inserted at the beginning. Use -1 to get an axis at the end.
		
		    .. versionadded:: 1.16.0
		
		Returns
		-------
		samples : ndarray
		    `num` samples, equally spaced on a log scale.
		
		See Also
		--------
		logspace : Similar to geomspace, but with endpoints specified using log
		           and base.
		linspace : Similar to geomspace, but with arithmetic instead of geometric
		           progression.
		arange : Similar to linspace, with the step size specified instead of the
		         number of samples.
		
		Notes
		-----
		If the inputs or dtype are complex, the output will follow a logarithmic
		spiral in the complex plane.  (There are an infinite number of spirals
		passing through two points; the output will follow the shortest such path.)
		
		Examples
		--------
		>>> np.geomspace(1, 1000, num=4)
		array([    1.,    10.,   100.,  1000.])
		>>> np.geomspace(1, 1000, num=3, endpoint=False)
		array([   1.,   10.,  100.])
		>>> np.geomspace(1, 1000, num=4, endpoint=False)
		array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])
		>>> np.geomspace(1, 256, num=9)
		array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])
		
		Note that the above may not produce exact integers:
		
		>>> np.geomspace(1, 256, num=9, dtype=int)
		array([  1,   2,   4,   7,  16,  32,  63, 127, 256])
		>>> np.around(np.geomspace(1, 256, num=9)).astype(int)
		array([  1,   2,   4,   8,  16,  32,  64, 128, 256])
		
		Negative, decreasing, and complex inputs are allowed:
		
		>>> np.geomspace(1000, 1, num=4)
		array([ 1000.,   100.,    10.,     1.])
		>>> np.geomspace(-1000, -1, num=4)
		array([-1000.,  -100.,   -10.,    -1.])
		>>> np.geomspace(1j, 1000j, num=4)  # Straight line
		array([ 0.   +1.j,  0.  +10.j,  0. +100.j,  0.+1000.j])
		>>> np.geomspace(-1+0j, 1+0j, num=5)  # Circle
		array([-1.00000000+0.j        , -0.70710678+0.70710678j,
		        0.00000000+1.j        ,  0.70710678+0.70710678j,
		        1.00000000+0.j        ])
		
		Graphical illustration of ``endpoint`` parameter:
		
		>>> import matplotlib.pyplot as plt
		>>> N = 10
		>>> y = np.zeros(N)
		>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')
		>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')
		>>> plt.axis([0.5, 2000, 0, 3])
		>>> plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')
		>>> plt.show()
	**/
	static public function geomspace(start:Dynamic, stop:Dynamic, ?num:Dynamic, ?endpoint:Dynamic, ?dtype:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return the value of object's property.  *property* is an optional string
		for the property you want to return
		
		Example usage::
		
		    getp(obj)  # get all the object properties
		    getp(obj, 'linestyle')  # get the linestyle property
		
		*obj* is a :class:`Artist` instance, e.g.,
		:class:`~matplotlib.lines.Line2D` or an instance of a
		:class:`~matplotlib.axes.Axes` or :class:`matplotlib.text.Text`.
		If the *property* is 'somename', this function returns
		
		  obj.get_somename()
		
		:func:`getp` can be used to query all the gettable properties with
		``getp(obj)``. Many properties have aliases for shorter typing, e.g.
		'lw' is an alias for 'linewidth'.  In the output, aliases and full
		property names will be listed as:
		
		  property or alias = value
		
		e.g.:
		
		  linewidth or lw = 2
	**/
	static public function get(obj:Dynamic, ?property:Dynamic):Dynamic;
	/**
		Find the wrapper for the array with the highest priority.
		
		In case of ties, leftmost wins. If no wrapper is found, return None
	**/
	static public function get_array_wrap(?args:python.VarArgs<Dynamic>):Dynamic;
	/**
		Return the name of the current backend.
		
		See Also
		--------
		matplotlib.use
	**/
	static public function get_backend():Dynamic;
	/**
		Get a colormap instance, defaulting to rc values if *name* is None.
		
		Colormaps added with :func:`register_cmap` take precedence over
		built-in colormaps.
		
		If *name* is a :class:`matplotlib.colors.Colormap` instance, it will be
		returned.
		
		If *lut* is not None it must be an integer giving the number of
		entries desired in the lookup table, and *name* must be a standard
		mpl colormap name.
	**/
	static public function get_cmap(?name:Dynamic, ?lut:Dynamic):Dynamic;
	/**
		Return the figure manager of the current figure.
		
		The figure manager is a container for the actual backend-depended window
		that displays the figure on screen.
		
		If if no current figure exists, a new one is created an its figure
		manager is returned.
		
		Returns
		-------
		manager : `.FigureManagerBase` or backend-dependent subclass thereof
	**/
	static public function get_current_fig_manager():Dynamic;
	/**
		Return a list of existing figure labels.
	**/
	static public function get_figlabels():Dynamic;
	/**
		Return a list of existing figure numbers.
	**/
	static public function get_fignums():Dynamic;
	/**
		Return the directory that contains the NumPy \*.h header files.
		
		Extension modules that need to compile against NumPy should use this
		function to locate the appropriate include directory.
		
		Notes
		-----
		When using ``distutils``, for example in ``setup.py``.
		::
		
		    import numpy as np
		    ...
		    Extension('extension_name', ...
		            include_dirs=[np.get_include()])
		    ...
	**/
	static public function get_include():Dynamic;
	/**
		Get a sorted list of all of the plotting commands.
	**/
	static public function get_plot_commands():Dynamic;
	/**
		Return the current print options.
		
		Returns
		-------
		print_opts : dict
		    Dictionary of current print options with keys
		
		      - precision : int
		      - threshold : int
		      - edgeitems : int
		      - linewidth : int
		      - suppress : bool
		      - nanstr : str
		      - infstr : str
		      - formatter : dict of callables
		      - sign : str
		
		    For a full description of these options, see `set_printoptions`.
		
		See Also
		--------
		set_printoptions, set_string_function
	**/
	static public function get_printoptions():python.Dict<Dynamic, Dynamic>;
	/**
		[*Deprecated*] Helper function for generating docstrings related to scales.
		
		Notes
		-----
		.. deprecated:: 3.1
		   get_scale_docs() is considered private API since 3.1 and will be removed from the public API in 3.3.
	**/
	static public function get_scale_docs():Dynamic;
	static public function get_scale_names():Dynamic;
	/**
		get_state()
		
		Return a tuple representing the internal state of the generator.
		
		For more details, see `set_state`.
		
		Returns
		-------
		out : tuple(str, ndarray of 624 uints, int, int, float)
		    The returned tuple has the following items:
		
		    1. the string 'MT19937'.
		    2. a 1-D array of 624 unsigned integer keys.
		    3. an integer ``pos``.
		    4. an integer ``has_gauss``.
		    5. a float ``cached_gaussian``.
		
		See Also
		--------
		set_state
		
		Notes
		-----
		`set_state` and `get_state` are not needed to work with any of the
		random distributions in NumPy. If the internal state is manually altered,
		the user should know exactly what he/she is doing.
	**/
	static public function get_state(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the size of the buffer used in ufuncs.
		
		Returns
		-------
		getbufsize : int
		    Size of ufunc buffer in bytes.
	**/
	static public function getbufsize():Int;
	/**
		Get the current way of handling floating-point errors.
		
		Returns
		-------
		res : dict
		    A dictionary with keys "divide", "over", "under", and "invalid",
		    whose values are from the strings "ignore", "print", "log", "warn",
		    "raise", and "call". The keys represent possible floating-point
		    exceptions, and the values define how these exceptions are handled.
		
		See Also
		--------
		geterrcall, seterr, seterrcall
		
		Notes
		-----
		For complete documentation of the types of floating-point exceptions and
		treatment options, see `seterr`.
		
		Examples
		--------
		>>> np.geterr()
		{'over': 'warn', 'divide': 'warn', 'invalid': 'warn',
		'under': 'ignore'}
		>>> np.arange(3.) / np.arange(3.)
		array([ NaN,   1.,   1.])
		
		>>> oldsettings = np.seterr(all='warn', over='raise')
		>>> np.geterr()
		{'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}
		>>> np.arange(3.) / np.arange(3.)
		__main__:1: RuntimeWarning: invalid value encountered in divide
		array([ NaN,   1.,   1.])
	**/
	static public function geterr():python.Dict<Dynamic, Dynamic>;
	/**
		Return the current callback function used on floating-point errors.
		
		When the error handling for a floating-point error (one of "divide",
		"over", "under", or "invalid") is set to 'call' or 'log', the function
		that is called or the log instance that is written to is returned by
		`geterrcall`. This function or log instance has been set with
		`seterrcall`.
		
		Returns
		-------
		errobj : callable, log instance or None
		    The current error handler. If no handler was set through `seterrcall`,
		    ``None`` is returned.
		
		See Also
		--------
		seterrcall, seterr, geterr
		
		Notes
		-----
		For complete documentation of the types of floating-point exceptions and
		treatment options, see `seterr`.
		
		Examples
		--------
		>>> np.geterrcall()  # we did not yet set a handler, returns None
		
		>>> oldsettings = np.seterr(all='call')
		>>> def err_handler(type, flag):
		...     print("Floating point error (%s), with flag %s" % (type, flag))
		>>> oldhandler = np.seterrcall(err_handler)
		>>> np.array([1, 2, 3]) / 0.0
		Floating point error (divide by zero), with flag 1
		array([ Inf,  Inf,  Inf])
		
		>>> cur_handler = np.geterrcall()
		>>> cur_handler is err_handler
		True
	**/
	static public function geterrcall():Dynamic;
	/**
		geterrobj()
		
		Return the current object that defines floating-point error handling.
		
		The error object contains all information that defines the error handling
		behavior in NumPy. `geterrobj` is used internally by the other
		functions that get and set error handling behavior (`geterr`, `seterr`,
		`geterrcall`, `seterrcall`).
		
		Returns
		-------
		errobj : list
		    The error object, a list containing three elements:
		    [internal numpy buffer size, error mask, error callback function].
		
		    The error mask is a single integer that holds the treatment information
		    on all four floating point errors. The information for each error type
		    is contained in three bits of the integer. If we print it in base 8, we
		    can see what treatment is set for "invalid", "under", "over", and
		    "divide" (in that order). The printed string can be interpreted with
		
		    * 0 : 'ignore'
		    * 1 : 'warn'
		    * 2 : 'raise'
		    * 3 : 'call'
		    * 4 : 'print'
		    * 5 : 'log'
		
		See Also
		--------
		seterrobj, seterr, geterr, seterrcall, geterrcall
		getbufsize, setbufsize
		
		Notes
		-----
		For complete documentation of the types of floating-point exceptions and
		treatment options, see `seterr`.
		
		Examples
		--------
		>>> np.geterrobj()  # first get the defaults
		[10000, 0, None]
		
		>>> def err_handler(type, flag):
		...     print("Floating point error (%s), with flag %s" % (type, flag))
		...
		>>> old_bufsize = np.setbufsize(20000)
		>>> old_err = np.seterr(divide='raise')
		>>> old_handler = np.seterrcall(err_handler)
		>>> np.geterrobj()
		[20000, 2, <function err_handler at 0x91dcaac>]
		
		>>> old_err = np.seterr(all='ignore')
		>>> np.base_repr(np.geterrobj()[1], 8)
		'0'
		>>> old_err = np.seterr(divide='warn', over='log', under='call',
		                        invalid='print')
		>>> np.base_repr(np.geterrobj()[1], 8)
		'4351'
	**/
	static public function geterrobj(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the value of object's property.  *property* is an optional string
		for the property you want to return
		
		Example usage::
		
		    getp(obj)  # get all the object properties
		    getp(obj, 'linestyle')  # get the linestyle property
		
		*obj* is a :class:`Artist` instance, e.g.,
		:class:`~matplotlib.lines.Line2D` or an instance of a
		:class:`~matplotlib.axes.Axes` or :class:`matplotlib.text.Text`.
		If the *property* is 'somename', this function returns
		
		  obj.get_somename()
		
		:func:`getp` can be used to query all the gettable properties with
		``getp(obj)``. Many properties have aliases for shorter typing, e.g.
		'lw' is an alias for 'linewidth'.  In the output, aliases and full
		property names will be listed as:
		
		  property or alias = value
		
		e.g.:
		
		  linewidth or lw = 2
	**/
	static public function getp(obj:Dynamic, ?property:Dynamic):Dynamic;
	/**
		Blocking call to interact with a figure.
		
		Wait until the user clicks *n* times on the figure, and return the
		coordinates of each click in a list.
		
		There are three possible interactions:
		
		- Add a point.
		- Remove the most recently added point.
		- Stop the interaction and return the points added so far.
		
		The actions are assigned to mouse buttons via the arguments
		*mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined
		by the numbers:
		
		- 1: left mouse button
		- 2: middle mouse button
		- 3: right mouse button
		- None: no mouse button
		
		Parameters
		----------
		n : int, optional, default: 1
		    Number of mouse clicks to accumulate. If negative, accumulate
		    clicks until the input is terminated manually.
		timeout : scalar, optional, default: 30
		    Number of seconds to wait before timing out. If zero or negative
		    will never timeout.
		show_clicks : bool, optional, default: False
		    If True, show a red cross at the location of each click.
		mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)
		    Mouse button used to add points.
		mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)
		    Mouse button used to remove the most recently added point.
		mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)
		    Mouse button used to stop input.
		
		Returns
		-------
		points : list of tuples
		    A list of the clicked (x, y) coordinates.
		
		Notes
		-----
		The keyboard can also be used to select points in case your mouse
		does not have one or more of the buttons.  The delete and backspace
		keys act like right clicking (i.e., remove last point), the enter key
		terminates input and any other key (not already used by the window
		manager) selects a point.
	**/
	static public function ginput(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the gradient of an N-dimensional array.
		
		The gradient is computed using second order accurate central differences
		in the interior points and either first or second order accurate one-sides
		(forward or backwards) differences at the boundaries.
		The returned gradient hence has the same shape as the input array.
		
		Parameters
		----------
		f : array_like
		    An N-dimensional array containing samples of a scalar function.
		varargs : list of scalar or array, optional
		    Spacing between f values. Default unitary spacing for all dimensions.
		    Spacing can be specified using:
		
		    1. single scalar to specify a sample distance for all dimensions.
		    2. N scalars to specify a constant sample distance for each dimension.
		       i.e. `dx`, `dy`, `dz`, ...
		    3. N arrays to specify the coordinates of the values along each
		       dimension of F. The length of the array must match the size of
		       the corresponding dimension
		    4. Any combination of N scalars/arrays with the meaning of 2. and 3.
		
		    If `axis` is given, the number of varargs must equal the number of axes.
		    Default: 1.
		
		edge_order : {1, 2}, optional
		    Gradient is calculated using N-th order accurate differences
		    at the boundaries. Default: 1.
		
		    .. versionadded:: 1.9.1
		
		axis : None or int or tuple of ints, optional
		    Gradient is calculated only along the given axis or axes
		    The default (axis = None) is to calculate the gradient for all the axes
		    of the input array. axis may be negative, in which case it counts from
		    the last to the first axis.
		
		    .. versionadded:: 1.11.0
		
		Returns
		-------
		gradient : ndarray or list of ndarray
		    A set of ndarrays (or a single ndarray if there is only one dimension)
		    corresponding to the derivatives of f with respect to each dimension.
		    Each derivative has the same shape as f.
		
		Examples
		--------
		>>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
		>>> np.gradient(f)
		array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
		>>> np.gradient(f, 2)
		array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
		
		Spacing can be also specified with an array that represents the coordinates
		of the values F along the dimensions.
		For instance a uniform spacing:
		
		>>> x = np.arange(f.size)
		>>> np.gradient(f, x)
		array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
		
		Or a non uniform one:
		
		>>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
		>>> np.gradient(f, x)
		array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
		
		For two dimensional arrays, the return will be two arrays ordered by
		axis. In this example the first array stands for the gradient in
		rows and the second one in columns direction:
		
		>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
		[array([[ 2.,  2., -1.],
		        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],
		        [ 1. ,  1. ,  1. ]])]
		
		In this example the spacing is also specified:
		uniform for axis=0 and non uniform for axis=1
		
		>>> dx = 2.
		>>> y = [1., 1.5, 3.5]
		>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
		[array([[ 1. ,  1. , -0.5],
		        [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],
		        [ 2. ,  1.7,  0.5]])]
		
		It is possible to specify how boundaries are treated using `edge_order`
		
		>>> x = np.array([0, 1, 2, 3, 4])
		>>> f = x**2
		>>> np.gradient(f, edge_order=1)
		array([ 1.,  2.,  4.,  6.,  7.])
		>>> np.gradient(f, edge_order=2)
		array([-0.,  2.,  4.,  6.,  8.])
		
		The `axis` keyword can be used to specify a subset of axes of which the
		gradient is calculated
		
		>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
		array([[ 2.,  2., -1.],
		       [ 2.,  2., -1.]])
		
		Notes
		-----
		Assuming that :math:`f\in C^{3}` (i.e., :math:`f` has at least 3 continuous
		derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
		minimize the "consistency error" :math:`\eta_{i}` between the true gradient
		and its estimate from a linear combination of the neighboring grid-points:
		
		.. math::
		
		    \eta_{i} = f_{i}^{\left(1\right)} -
		                \left[ \alpha f\left(x_{i}\right) +
		                        \beta f\left(x_{i} + h_{d}\right) +
		                        \gamma f\left(x_{i}-h_{s}\right)
		                \right]
		
		By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
		with their Taylor series expansion, this translates into solving
		the following the linear system:
		
		.. math::
		
		    \left\{
		        \begin{array}{r}
		            \alpha+\beta+\gamma=0 \\
		            \beta h_{d}-\gamma h_{s}=1 \\
		            \beta h_{d}^{2}+\gamma h_{s}^{2}=0
		        \end{array}
		    \right.
		
		The resulting approximation of :math:`f_{i}^{(1)}` is the following:
		
		.. math::
		
		    \hat f_{i}^{(1)} =
		        \frac{
		            h_{s}^{2}f\left(x_{i} + h_{d}\right)
		            + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
		            - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
		            { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
		        + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
		                            + h_{s}h_{d}^{2}}{h_{d}
		                            + h_{s}}\right)
		
		It is worth noting that if :math:`h_{s}=h_{d}`
		(i.e., data are evenly spaced)
		we find the standard second order approximation:
		
		.. math::
		
		    \hat f_{i}^{(1)}=
		        \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
		        + \mathcal{O}\left(h^{2}\right)
		
		With a similar procedure the forward/backward approximations used for
		boundaries can be derived.
		
		References
		----------
		.. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
		        (Texts in Applied Mathematics). New York: Springer.
		.. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
		        in Geophysical Fluid Dynamics. New York: Springer.
		.. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
		        Arbitrarily Spaced Grids,
		        Mathematics of Computation 51, no. 184 : 699-706.
		        `PDF <http://www.ams.org/journals/mcom/1988-51-184/
		        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.
	**/
	static public function gradient(f:Dynamic, ?varargs:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "gray".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function gray():Dynamic;
	/**
		greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the truth value of (x1 > x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays.  If ``x1.shape != x2.shape``, they must be
		    broadcastable to a common shape (which may be the shape of one or
		    the other).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		
		See Also
		--------
		greater_equal, less, less_equal, equal, not_equal
		
		Examples
		--------
		>>> np.greater([4,2],[2,2])
		array([ True, False])
		
		If the inputs are ndarrays, then np.greater is equivalent to '>'.
		
		>>> a = np.array([4,2])
		>>> b = np.array([2,2])
		>>> a > b
		array([ True, False])
	**/
	static public function greater(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the truth value of (x1 >= x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays.  If ``x1.shape != x2.shape``, they must be
		    broadcastable to a common shape (which may be the shape of one or
		    the other).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : bool or ndarray of bool
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		greater, less, less_equal, equal, not_equal
		
		Examples
		--------
		>>> np.greater_equal([4, 2, 1], [2, 2, 2])
		array([ True, True, False])
	**/
	static public function greater_equal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Configure the grid lines.
		
		Parameters
		----------
		b : bool or None, optional
		    Whether to show the grid lines. If any *kwargs* are supplied,
		    it is assumed you want the grid on and *b* will be set to True.
		
		    If *b* is *None* and there are no *kwargs*, this toggles the
		    visibility of the lines.
		
		which : {'major', 'minor', 'both'}, optional
		    The grid lines to apply the changes on.
		
		axis : {'both', 'x', 'y'}, optional
		    The axis to apply the changes on.
		
		**kwargs : `.Line2D` properties
		    Define the line properties of the grid, e.g.::
		
		        grid(color='r', linestyle='-', linewidth=2)
		
		    Valid *kwargs* are
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		Notes
		-----
		The axis is drawn as a unit, so the effective zorder for drawing the
		grid is determined by the zorder of each axis, not by the zorder of the
		`.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
		use `.set_axisbelow` or, for more control, call the
		`~matplotlib.axis.Axis.set_zorder` method of each axis.
	**/
	static public function grid(?b:Dynamic, ?which:Dynamic, ?axis:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		gumbel(loc=0.0, scale=1.0, size=None)
		
		Draw samples from a Gumbel distribution.
		
		Draw samples from a Gumbel distribution with specified location and
		scale.  For more information on the Gumbel distribution, see
		Notes and References below.
		
		Parameters
		----------
		loc : float or array_like of floats, optional
		    The location of the mode of the distribution. Default is 0.
		scale : float or array_like of floats, optional
		    The scale parameter of the distribution. Default is 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``loc`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Gumbel distribution.
		
		See Also
		--------
		scipy.stats.gumbel_l
		scipy.stats.gumbel_r
		scipy.stats.genextreme
		weibull
		
		Notes
		-----
		The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
		Value Type I) distribution is one of a class of Generalized Extreme
		Value (GEV) distributions used in modeling extreme value problems.
		The Gumbel is a special case of the Extreme Value Type I distribution
		for maximums from distributions with "exponential-like" tails.
		
		The probability density for the Gumbel distribution is
		
		.. math:: p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
		          \beta}},
		
		where :math:`\mu` is the mode, a location parameter, and
		:math:`\beta` is the scale parameter.
		
		The Gumbel (named for German mathematician Emil Julius Gumbel) was used
		very early in the hydrology literature, for modeling the occurrence of
		flood events. It is also used for modeling maximum wind speed and
		rainfall rates.  It is a "fat-tailed" distribution - the probability of
		an event in the tail of the distribution is larger than if one used a
		Gaussian, hence the surprisingly frequent occurrence of 100-year
		floods. Floods were initially modeled as a Gaussian process, which
		underestimated the frequency of extreme events.
		
		It is one of a class of extreme value distributions, the Generalized
		Extreme Value (GEV) distributions, which also includes the Weibull and
		Frechet.
		
		The function has a mean of :math:`\mu + 0.57721\beta` and a variance
		of :math:`\frac{\pi^2}{6}\beta^2`.
		
		References
		----------
		.. [1] Gumbel, E. J., "Statistics of Extremes,"
		       New York: Columbia University Press, 1958.
		.. [2] Reiss, R.-D. and Thomas, M., "Statistical Analysis of Extreme
		       Values from Insurance, Finance, Hydrology and Other Fields,"
		       Basel: Birkhauser Verlag, 2001.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> mu, beta = 0, 0.1 # location and scale
		>>> s = np.random.gumbel(mu, beta, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 30, density=True)
		>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
		...          * np.exp( -np.exp( -(bins - mu) /beta) ),
		...          linewidth=2, color='r')
		>>> plt.show()
		
		Show how an extreme value distribution can arise from a Gaussian process
		and compare to a Gaussian:
		
		>>> means = []
		>>> maxima = []
		>>> for i in range(0,1000) :
		...    a = np.random.normal(mu, beta, 1000)
		...    means.append(a.mean())
		...    maxima.append(a.max())
		>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
		>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
		>>> mu = np.mean(maxima) - 0.57721*beta
		>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
		...          * np.exp(-np.exp(-(bins - mu)/beta)),
		...          linewidth=2, color='r')
		>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
		...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
		...          linewidth=2, color='g')
		>>> plt.show()
	**/
	static public function gumbel(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the Hamming window.
		
		The Hamming window is a taper formed by using a weighted cosine.
		
		Parameters
		----------
		M : int
		    Number of points in the output window. If zero or less, an
		    empty array is returned.
		
		Returns
		-------
		out : ndarray
		    The window, with the maximum value normalized to one (the value
		    one appears only if the number of samples is odd).
		
		See Also
		--------
		bartlett, blackman, hanning, kaiser
		
		Notes
		-----
		The Hamming window is defined as
		
		.. math::  w(n) = 0.54 - 0.46cos\left(\frac{2\pi{n}}{M-1}\right)
		           \qquad 0 \leq n \leq M-1
		
		The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
		and is described in Blackman and Tukey. It was recommended for
		smoothing the truncated autocovariance function in the time domain.
		Most references to the Hamming window come from the signal processing
		literature, where it is used as one of many windowing functions for
		smoothing values.  It is also known as an apodization (which means
		"removing the foot", i.e. smoothing discontinuities at the beginning
		and end of the sampled signal) or tapering function.
		
		References
		----------
		.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
		       spectra, Dover Publications, New York.
		.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
		       University of Alberta Press, 1975, pp. 109-110.
		.. [3] Wikipedia, "Window function",
		       https://en.wikipedia.org/wiki/Window_function
		.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
		       "Numerical Recipes", Cambridge University Press, 1986, page 425.
		
		Examples
		--------
		>>> np.hamming(12)
		array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,
		        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
		        0.15302337,  0.08      ])
		
		Plot the window and the frequency response:
		
		>>> import matplotlib.pyplot as plt
		>>> from numpy.fft import fft, fftshift
		>>> window = np.hamming(51)
		>>> plt.plot(window)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Hamming window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Sample")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		>>> plt.figure()
		<matplotlib.figure.Figure object at 0x...>
		>>> A = fft(window, 2048) / 25.5
		>>> mag = np.abs(fftshift(A))
		>>> freq = np.linspace(-0.5, 0.5, len(A))
		>>> response = 20 * np.log10(mag)
		>>> response = np.clip(response, -100, 100)
		>>> plt.plot(freq, response)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Frequency response of Hamming window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Magnitude [dB]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Normalized frequency [cycles per sample]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.axis('tight')
		(-0.5, 0.5, -100.0, ...)
		>>> plt.show()
	**/
	static public function hamming(M:Dynamic):Dynamic;
	/**
		Return the Hanning window.
		
		The Hanning window is a taper formed by using a weighted cosine.
		
		Parameters
		----------
		M : int
		    Number of points in the output window. If zero or less, an
		    empty array is returned.
		
		Returns
		-------
		out : ndarray, shape(M,)
		    The window, with the maximum value normalized to one (the value
		    one appears only if `M` is odd).
		
		See Also
		--------
		bartlett, blackman, hamming, kaiser
		
		Notes
		-----
		The Hanning window is defined as
		
		.. math::  w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)
		           \qquad 0 \leq n \leq M-1
		
		The Hanning was named for Julius von Hann, an Austrian meteorologist.
		It is also known as the Cosine Bell. Some authors prefer that it be
		called a Hann window, to help avoid confusion with the very similar
		Hamming window.
		
		Most references to the Hanning window come from the signal processing
		literature, where it is used as one of many windowing functions for
		smoothing values.  It is also known as an apodization (which means
		"removing the foot", i.e. smoothing discontinuities at the beginning
		and end of the sampled signal) or tapering function.
		
		References
		----------
		.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
		       spectra, Dover Publications, New York.
		.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
		       The University of Alberta Press, 1975, pp. 106-108.
		.. [3] Wikipedia, "Window function",
		       https://en.wikipedia.org/wiki/Window_function
		.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
		       "Numerical Recipes", Cambridge University Press, 1986, page 425.
		
		Examples
		--------
		>>> np.hanning(12)
		array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,
		        0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,
		        0.07937323,  0.        ])
		
		Plot the window and its frequency response:
		
		>>> import matplotlib.pyplot as plt
		>>> from numpy.fft import fft, fftshift
		>>> window = np.hanning(51)
		>>> plt.plot(window)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Hann window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Sample")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		>>> plt.figure()
		<matplotlib.figure.Figure object at 0x...>
		>>> A = fft(window, 2048) / 25.5
		>>> mag = np.abs(fftshift(A))
		>>> freq = np.linspace(-0.5, 0.5, len(A))
		>>> response = 20 * np.log10(mag)
		>>> response = np.clip(response, -100, 100)
		>>> plt.plot(freq, response)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Frequency response of the Hann window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Magnitude [dB]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Normalized frequency [cycles per sample]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.axis('tight')
		(-0.5, 0.5, -100.0, ...)
		>>> plt.show()
	**/
	static public function hanning(M:Dynamic):Dynamic;
	/**
		heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the Heaviside step function.
		
		The Heaviside step function is defined as::
		
		                          0   if x1 < 0
		    heaviside(x1, x2) =  x2   if x1 == 0
		                          1   if x1 > 0
		
		where `x2` is often taken to be 0.5, but 0 and 1 are also sometimes used.
		
		Parameters
		----------
		x1 : array_like
		    Input values.
		x2 : array_like
		    The value of the function when x1 is 0.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    The output array, element-wise Heaviside step function of `x1`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		.. versionadded:: 1.13.0
		
		References
		----------
		.. Wikipedia, "Heaviside step function",
		   https://en.wikipedia.org/wiki/Heaviside_step_function
		
		Examples
		--------
		>>> np.heaviside([-1.5, 0, 2.0], 0.5)
		array([ 0. ,  0.5,  1. ])
		>>> np.heaviside([-1.5, 0, 2.0], 1)
		array([ 0.,  1.,  1.])
	**/
	static public function heaviside(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Make a hexagonal binning plot.
		
		Make a hexagonal binning plot of *x* versus *y*, where *x*,
		*y* are 1-D sequences of the same length, *N*. If *C* is *None*
		(the default), this is a histogram of the number of occurrences
		of the observations at (x[i],y[i]).
		
		If *C* is specified, it specifies values at the coordinate
		(x[i], y[i]). These values are accumulated for each hexagonal
		bin and then reduced according to *reduce_C_function*, which
		defaults to `numpy.mean`. (If *C* is specified, it must also
		be a 1-D sequence of the same length as *x* and *y*.)
		
		Parameters
		----------
		x, y : array or masked array
		
		C : array or masked array, optional, default is *None*
		
		gridsize : int or (int, int), optional, default is 100
		    The number of hexagons in the *x*-direction, default is
		    100. The corresponding number of hexagons in the
		    *y*-direction is chosen such that the hexagons are
		    approximately regular. Alternatively, gridsize can be a
		    tuple with two elements specifying the number of hexagons
		    in the *x*-direction and the *y*-direction.
		
		bins : 'log' or int or sequence, optional, default is *None*
		    If *None*, no binning is applied; the color of each hexagon
		    directly corresponds to its count value.
		
		    If 'log', use a logarithmic scale for the color
		    map. Internally, :math:`log_{10}(i+1)` is used to
		    determine the hexagon color.
		
		    If an integer, divide the counts in the specified number
		    of bins, and color the hexagons accordingly.
		
		    If a sequence of values, the values of the lower bound of
		    the bins to be used.
		
		xscale : {'linear', 'log'}, optional, default is 'linear'
		    Use a linear or log10 scale on the horizontal axis.
		
		yscale : {'linear', 'log'}, optional, default is 'linear'
		    Use a linear or log10 scale on the vertical axis.
		
		mincnt : int > 0, optional, default is *None*
		    If not *None*, only display cells with more than *mincnt*
		    number of points in the cell
		
		marginals : bool, optional, default is *False*
		    if marginals is *True*, plot the marginal density as
		    colormapped rectangles along the bottom of the x-axis and
		    left of the y-axis
		
		extent : scalar, optional, default is *None*
		    The limits of the bins. The default assigns the limits
		    based on *gridsize*, *x*, *y*, *xscale* and *yscale*.
		
		    If *xscale* or *yscale* is set to 'log', the limits are
		    expected to be the exponent for a power of 10. E.g. for
		    x-limits of 1 and 50 in 'linear' scale and y-limits
		    of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
		
		    Order of scalars is (left, right, bottom, top).
		
		Other Parameters
		----------------
		cmap : object, optional, default is *None*
		    a :class:`matplotlib.colors.Colormap` instance. If *None*,
		    defaults to rc ``image.cmap``.
		
		norm : object, optional, default is *None*
		    :class:`matplotlib.colors.Normalize` instance is used to
		    scale luminance data to 0,1.
		
		vmin, vmax : scalar, optional, default is *None*
		    *vmin* and *vmax* are used in conjunction with *norm* to
		    normalize luminance data. If *None*, the min and max of the
		    color array *C* are used.  Note if you pass a norm instance
		    your settings for *vmin* and *vmax* will be ignored.
		
		alpha : scalar between 0 and 1, optional, default is *None*
		    the alpha value for the patches
		
		linewidths : scalar, optional, default is *None*
		    If *None*, defaults to 1.0.
		
		edgecolors : {'face', 'none', *None*} or color, optional
		
		    If 'face' (the default), draws the edges in the same color as the
		    fill color.
		
		    If 'none', no edge is drawn; this can sometimes lead to unsightly
		    unpainted pixels between the hexagons.
		
		    If *None*, draws outlines in the default color.
		
		    If a matplotlib color arg, draws outlines in the specified color.
		
		Returns
		-------
		polycollection
		    A `.PolyCollection` instance; use `.PolyCollection.get_array` on
		    this to get the counts in each hexagon.
		
		    If *marginals* is *True*, horizontal
		    bar and vertical bar (both PolyCollections) will be attached
		    to the return collection as attributes *hbar* and *vbar*.
		
		Notes
		-----
		The standard descriptions of all the
		:class:`~matplotlib.collections.Collection` parameters:
		
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function hexbin(x:Dynamic, y:Dynamic, ?C:Dynamic, ?gridsize:Dynamic, ?bins:Dynamic, ?xscale:Dynamic, ?yscale:Dynamic, ?extent:Dynamic, ?cmap:Dynamic, ?norm:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?alpha:Dynamic, ?linewidths:Dynamic, ?edgecolors:Dynamic, ?reduce_C_function:Dynamic, ?mincnt:Dynamic, ?marginals:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
		spectrum.
		
		Parameters
		----------
		a : array_like
		    The input array.
		n : int, optional
		    Length of the transformed axis of the output. For `n` output
		    points, ``n//2 + 1`` input points are necessary.  If the input is
		    longer than this, it is cropped.  If it is shorter than this, it is
		    padded with zeros.  If `n` is not given, it is determined from the
		    length of the input along the axis specified by `axis`.
		axis : int, optional
		    Axis over which to compute the FFT. If not given, the last
		    axis is used.
		norm : {None, "ortho"}, optional
		    Normalization mode (see `numpy.fft`). Default is None.
		
		    .. versionadded:: 1.10.0
		
		Returns
		-------
		out : ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		    The length of the transformed axis is `n`, or, if `n` is not given,
		    ``2*m - 2`` where ``m`` is the length of the transformed axis of
		    the input. To get an odd number of output points, `n` must be
		    specified, for instance as ``2*m - 1`` in the typical case,
		
		Raises
		------
		IndexError
		    If `axis` is larger than the last axis of `a`.
		
		See also
		--------
		rfft : Compute the one-dimensional FFT for real input.
		ihfft : The inverse of `hfft`.
		
		Notes
		-----
		`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
		opposite case: here the signal has Hermitian symmetry in the time
		domain and is real in the frequency domain. So here it's `hfft` for
		which you must supply the length of the result if it is to be odd.
		
		* even: ``ihfft(hfft(a, 2*len(a) - 2) == a``, within roundoff error,
		* odd: ``ihfft(hfft(a, 2*len(a) - 1) == a``, within roundoff error.
		
		Examples
		--------
		>>> signal = np.array([1, 2, 3, 4, 3, 2])
		>>> np.fft.fft(signal)
		array([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])
		>>> np.fft.hfft(signal[:4]) # Input first half of signal
		array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])
		>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate
		array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])
		
		
		>>> signal = np.array([[1, 1.j], [-1.j, 2]])
		>>> np.conj(signal.T) - signal   # check Hermitian symmetry
		array([[ 0.-0.j,  0.+0.j],
		       [ 0.+0.j,  0.-0.j]])
		>>> freq_spectrum = np.fft.hfft(signal)
		>>> freq_spectrum
		array([[ 1.,  1.],
		       [ 2., -2.]])
	**/
	static public function hfft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Plot a histogram.
		
		Compute and draw the histogram of *x*.  The return value is a tuple
		(*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*, [*patches0*,
		*patches1*,...]) if the input contains multiple data.  See the
		documentation of the *weights* parameter to draw a histogram of
		already-binned data.
		
		Multiple data can be provided via *x* as a list of datasets
		of potentially different length ([*x0*, *x1*, ...]), or as
		a 2-D ndarray in which each column is a dataset.  Note that
		the ndarray form is transposed relative to the list form.
		
		Masked arrays are not supported at present.
		
		Parameters
		----------
		x : (n,) array or sequence of (n,) arrays
		    Input values, this takes either a single array or a sequence of
		    arrays which are not required to be of the same length.
		
		bins : int or sequence or str, optional
		    If an integer is given, ``bins + 1`` bin edges are calculated and
		    returned, consistent with `numpy.histogram`.
		
		    If `bins` is a sequence, gives bin edges, including left edge of
		    first bin and right edge of last bin.  In this case, `bins` is
		    returned unmodified.
		
		    All but the last (righthand-most) bin is half-open.  In other
		    words, if `bins` is::
		
		        [1, 2, 3, 4]
		
		    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
		    the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
		    *includes* 4.
		
		    Unequally spaced bins are supported if *bins* is a sequence.
		
		    With Numpy 1.11 or newer, you can alternatively provide a string
		    describing a binning strategy, such as 'auto', 'sturges', 'fd',
		    'doane', 'scott', 'rice' or 'sqrt', see
		    `numpy.histogram`.
		
		    The default is taken from :rc:`hist.bins`.
		
		range : tuple or None, optional
		    The lower and upper range of the bins. Lower and upper outliers
		    are ignored. If not provided, *range* is ``(x.min(), x.max())``.
		    Range has no effect if *bins* is a sequence.
		
		    If *bins* is a sequence or *range* is specified, autoscaling
		    is based on the specified bin range instead of the
		    range of x.
		
		    Default is ``None``
		
		density : bool, optional
		    If ``True``, the first element of the return tuple will
		    be the counts normalized to form a probability density, i.e.,
		    the area (or integral) under the histogram will sum to 1.
		    This is achieved by dividing the count by the number of
		    observations times the bin width and not dividing by the total
		    number of observations. If *stacked* is also ``True``, the sum of
		    the histograms is normalized to 1.
		
		    Default is ``None`` for both *normed* and *density*. If either is
		    set, then that value will be used. If neither are set, then the
		    args will be treated as ``False``.
		
		    If both *density* and *normed* are set an error is raised.
		
		weights : (n, ) array_like or None, optional
		    An array of weights, of the same shape as *x*.  Each value in *x*
		    only contributes its associated weight towards the bin count
		    (instead of 1).  If *normed* or *density* is ``True``,
		    the weights are normalized, so that the integral of the density
		    over the range remains 1.
		
		    Default is ``None``.
		
		    This parameter can be used to draw a histogram of data that has
		    already been binned, e.g. using `np.histogram` (by treating each
		    bin as a single point with a weight equal to its count) ::
		
		        counts, bins = np.histogram(data)
		        plt.hist(bins[:-1], bins, weights=counts)
		
		    (or you may alternatively use `~.bar()`).
		
		cumulative : bool, optional
		    If ``True``, then a histogram is computed where each bin gives the
		    counts in that bin plus all bins for smaller values. The last bin
		    gives the total number of datapoints. If *normed* or *density*
		    is also ``True`` then the histogram is normalized such that the
		    last bin equals 1. If *cumulative* evaluates to less than 0
		    (e.g., -1), the direction of accumulation is reversed.
		    In this case, if *normed* and/or *density* is also ``True``, then
		    the histogram is normalized such that the first bin equals 1.
		
		    Default is ``False``
		
		bottom : array_like, scalar, or None
		    Location of the bottom baseline of each bin.  If a scalar,
		    the base line for each bin is shifted by the same amount.
		    If an array, each bin is shifted independently and the length
		    of bottom must match the number of bins.  If None, defaults to 0.
		
		    Default is ``None``
		
		histtype : {'bar', 'barstacked', 'step',  'stepfilled'}, optional
		    The type of histogram to draw.
		
		    - 'bar' is a traditional bar-type histogram.  If multiple data
		      are given the bars are arranged side by side.
		
		    - 'barstacked' is a bar-type histogram where multiple
		      data are stacked on top of each other.
		
		    - 'step' generates a lineplot that is by default
		      unfilled.
		
		    - 'stepfilled' generates a lineplot that is by default
		      filled.
		
		    Default is 'bar'
		
		align : {'left', 'mid', 'right'}, optional
		    Controls how the histogram is plotted.
		
		        - 'left': bars are centered on the left bin edges.
		
		        - 'mid': bars are centered between the bin edges.
		
		        - 'right': bars are centered on the right bin edges.
		
		    Default is 'mid'
		
		orientation : {'horizontal', 'vertical'}, optional
		    If 'horizontal', `~matplotlib.pyplot.barh` will be used for
		    bar-type histograms and the *bottom* kwarg will be the left edges.
		
		rwidth : scalar or None, optional
		    The relative width of the bars as a fraction of the bin width.  If
		    ``None``, automatically compute the width.
		
		    Ignored if *histtype* is 'step' or 'stepfilled'.
		
		    Default is ``None``
		
		log : bool, optional
		    If ``True``, the histogram axis will be set to a log scale. If
		    *log* is ``True`` and *x* is a 1D array, empty bins will be
		    filtered out and only the non-empty ``(n, bins, patches)``
		    will be returned.
		
		    Default is ``False``
		
		color : color or array_like of colors or None, optional
		    Color spec or sequence of color specs, one per dataset.  Default
		    (``None``) uses the standard line color sequence.
		
		    Default is ``None``
		
		label : str or None, optional
		    String, or sequence of strings to match multiple datasets.  Bar
		    charts yield multiple patches per dataset, but only the first gets
		    the label, so that the legend command will work as expected.
		
		    default is ``None``
		
		stacked : bool, optional
		    If ``True``, multiple data are stacked on top of each other If
		    ``False`` multiple data are arranged side by side if histtype is
		    'bar' or on top of each other if histtype is 'step'
		
		    Default is ``False``
		
		normed : bool, optional
		    Deprecated; use the density keyword argument instead.
		
		Returns
		-------
		n : array or list of arrays
		    The values of the histogram bins. See *density* and *weights* for a
		    description of the possible semantics.  If input *x* is an array,
		    then this is an array of length *nbins*. If input is a sequence of
		    arrays ``[data1, data2,..]``, then this is a list of arrays with
		    the values of the histograms for each of the arrays in the same
		    order.  The dtype of the array *n* (or of its element arrays) will
		    always be float even if no weighting or normalization is used.
		
		bins : array
		    The edges of the bins. Length nbins + 1 (nbins left edges and right
		    edge of last bin).  Always a single array even when multiple data
		    sets are passed in.
		
		patches : list or list of lists
		    Silent list of individual patches used to create the histogram
		    or list of such list if multiple input datasets.
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.patches.Patch` properties
		
		See also
		--------
		hist2d : 2D histograms
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'weights', 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function hist(x:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?density:Dynamic, ?weights:Dynamic, ?cumulative:Dynamic, ?bottom:Dynamic, ?histtype:Dynamic, ?align:Dynamic, ?orientation:Dynamic, ?rwidth:Dynamic, ?log:Dynamic, ?color:Dynamic, ?label:Dynamic, ?stacked:Dynamic, ?normed:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Make a 2D histogram plot.
		
		Parameters
		----------
		x, y : array_like, shape (n, )
		    Input values
		
		bins : None or int or [int, int] or array_like or [array, array]
		
		    The bin specification:
		
		        - If int, the number of bins for the two dimensions
		          (nx=ny=bins).
		
		        - If ``[int, int]``, the number of bins in each dimension
		          (nx, ny = bins).
		
		        - If array_like, the bin edges for the two dimensions
		          (x_edges=y_edges=bins).
		
		        - If ``[array, array]``, the bin edges in each dimension
		          (x_edges, y_edges = bins).
		
		    The default value is 10.
		
		range : array_like shape(2, 2), optional, default: None
		     The leftmost and rightmost edges of the bins along each dimension
		     (if not specified explicitly in the bins parameters): ``[[xmin,
		     xmax], [ymin, ymax]]``. All values outside of this range will be
		     considered outliers and not tallied in the histogram.
		
		density : bool, optional, default: False
		     Normalize histogram.  *normed* is a deprecated synonym for this
		     parameter.
		
		weights : array_like, shape (n, ), optional, default: None
		    An array of values w_i weighing each sample (x_i, y_i).
		
		cmin : scalar, optional, default: None
		     All bins that has count less than cmin will not be displayed and
		     these count values in the return value count histogram will also
		     be set to nan upon return
		
		cmax : scalar, optional, default: None
		     All bins that has count more than cmax will not be displayed (set
		     to none before passing to imshow) and these count values in the
		     return value count histogram will also be set to nan upon return
		
		Returns
		-------
		h : 2D array
		    The bi-dimensional histogram of samples x and y. Values in x are
		    histogrammed along the first dimension and values in y are
		    histogrammed along the second dimension.
		xedges : 1D array
		    The bin edges along the x axis.
		yedges : 1D array
		    The bin edges along the y axis.
		image : `~.matplotlib.collections.QuadMesh`
		
		Other Parameters
		----------------
		cmap : Colormap or str, optional
		    A `.colors.Colormap` instance.  If not set, use rc settings.
		
		norm : Normalize, optional
		    A `.colors.Normalize` instance is used to
		    scale luminance data to ``[0, 1]``. If not set, defaults to
		    `.colors.Normalize()`.
		
		vmin/vmax : None or scalar, optional
		    Arguments passed to the `~.colors.Normalize` instance.
		
		alpha : ``0 <= scalar <= 1`` or ``None``, optional
		    The alpha blending value.
		
		See also
		--------
		hist : 1D histogram plotting
		
		Notes
		-----
		- Currently ``hist2d`` calculates it's own axis limits, and any limits
		  previously set are ignored.
		- Rendering the histogram with a logarithmic color scale is
		  accomplished by passing a `.colors.LogNorm` instance to the *norm*
		  keyword argument. Likewise, power-law normalization (similar
		  in effect to gamma correction) can be accomplished with
		  `.colors.PowerNorm`.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'weights', 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function hist2d(x:Dynamic, y:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?density:Dynamic, ?weights:Dynamic, ?cmin:Dynamic, ?cmax:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Compute the histogram of a set of data.
		
		Parameters
		----------
		a : array_like
		    Input data. The histogram is computed over the flattened array.
		bins : int or sequence of scalars or str, optional
		    If `bins` is an int, it defines the number of equal-width
		    bins in the given range (10, by default). If `bins` is a
		    sequence, it defines a monotonically increasing array of bin edges,
		    including the rightmost edge, allowing for non-uniform bin widths.
		
		    .. versionadded:: 1.11.0
		
		    If `bins` is a string, it defines the method used to calculate the
		    optimal bin width, as defined by `histogram_bin_edges`.
		
		range : (float, float), optional
		    The lower and upper range of the bins.  If not provided, range
		    is simply ``(a.min(), a.max())``.  Values outside the range are
		    ignored. The first element of the range must be less than or
		    equal to the second. `range` affects the automatic bin
		    computation as well. While bin width is computed to be optimal
		    based on the actual data within `range`, the bin count will fill
		    the entire range including portions containing no data.
		normed : bool, optional
		
		    .. deprecated:: 1.6.0
		
		    This is equivalent to the `density` argument, but produces incorrect
		    results for unequal bin widths. It should not be used.
		
		    .. versionchanged:: 1.15.0
		        DeprecationWarnings are actually emitted.
		
		weights : array_like, optional
		    An array of weights, of the same shape as `a`.  Each value in
		    `a` only contributes its associated weight towards the bin count
		    (instead of 1). If `density` is True, the weights are
		    normalized, so that the integral of the density over the range
		    remains 1.
		density : bool, optional
		    If ``False``, the result will contain the number of samples in
		    each bin. If ``True``, the result is the value of the
		    probability *density* function at the bin, normalized such that
		    the *integral* over the range is 1. Note that the sum of the
		    histogram values will not be equal to 1 unless bins of unity
		    width are chosen; it is not a probability *mass* function.
		
		    Overrides the ``normed`` keyword if given.
		
		Returns
		-------
		hist : array
		    The values of the histogram. See `density` and `weights` for a
		    description of the possible semantics.
		bin_edges : array of dtype float
		    Return the bin edges ``(length(hist)+1)``.
		
		
		See Also
		--------
		histogramdd, bincount, searchsorted, digitize, histogram_bin_edges
		
		Notes
		-----
		All but the last (righthand-most) bin is half-open.  In other words,
		if `bins` is::
		
		  [1, 2, 3, 4]
		
		then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
		the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
		*includes* 4.
		
		
		Examples
		--------
		>>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
		(array([0, 2, 1]), array([0, 1, 2, 3]))
		>>> np.histogram(np.arange(4), bins=np.arange(5), density=True)
		(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))
		>>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
		(array([1, 4, 1]), array([0, 1, 2, 3]))
		
		>>> a = np.arange(5)
		>>> hist, bin_edges = np.histogram(a, density=True)
		>>> hist
		array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])
		>>> hist.sum()
		2.4999999999999996
		>>> np.sum(hist * np.diff(bin_edges))
		1.0
		
		.. versionadded:: 1.11.0
		
		Automated Bin Selection Methods example, using 2 peak random data
		with 2000 points:
		
		>>> import matplotlib.pyplot as plt
		>>> rng = np.random.RandomState(10)  # deterministic random data
		>>> a = np.hstack((rng.normal(size=1000),
		...                rng.normal(loc=5, scale=2, size=1000)))
		>>> plt.hist(a, bins='auto')  # arguments are passed to np.histogram
		>>> plt.title("Histogram with 'auto' bins")
		>>> plt.show()
	**/
	static public function histogram(a:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?normed:Dynamic, ?weights:Dynamic, ?density:Dynamic):Array<Dynamic>;
	/**
		Compute the bi-dimensional histogram of two data samples.
		
		Parameters
		----------
		x : array_like, shape (N,)
		    An array containing the x coordinates of the points to be
		    histogrammed.
		y : array_like, shape (N,)
		    An array containing the y coordinates of the points to be
		    histogrammed.
		bins : int or array_like or [int, int] or [array, array], optional
		    The bin specification:
		
		      * If int, the number of bins for the two dimensions (nx=ny=bins).
		      * If array_like, the bin edges for the two dimensions
		        (x_edges=y_edges=bins).
		      * If [int, int], the number of bins in each dimension
		        (nx, ny = bins).
		      * If [array, array], the bin edges in each dimension
		        (x_edges, y_edges = bins).
		      * A combination [int, array] or [array, int], where int
		        is the number of bins and array is the bin edges.
		
		range : array_like, shape(2,2), optional
		    The leftmost and rightmost edges of the bins along each dimension
		    (if not specified explicitly in the `bins` parameters):
		    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
		    will be considered outliers and not tallied in the histogram.
		density : bool, optional
		    If False, the default, returns the number of samples in each bin.
		    If True, returns the probability *density* function at the bin,
		    ``bin_count / sample_count / bin_area``.
		normed : bool, optional
		    An alias for the density argument that behaves identically. To avoid
		    confusion with the broken normed argument to `histogram`, `density`
		    should be preferred.
		weights : array_like, shape(N,), optional
		    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
		    Weights are normalized to 1 if `normed` is True. If `normed` is
		    False, the values of the returned histogram are equal to the sum of
		    the weights belonging to the samples falling into each bin.
		
		Returns
		-------
		H : ndarray, shape(nx, ny)
		    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
		    are histogrammed along the first dimension and values in `y` are
		    histogrammed along the second dimension.
		xedges : ndarray, shape(nx+1,)
		    The bin edges along the first dimension.
		yedges : ndarray, shape(ny+1,)
		    The bin edges along the second dimension.
		
		See Also
		--------
		histogram : 1D histogram
		histogramdd : Multidimensional histogram
		
		Notes
		-----
		When `normed` is True, then the returned histogram is the sample
		density, defined such that the sum over bins of the product
		``bin_value * bin_area`` is 1.
		
		Please note that the histogram does not follow the Cartesian convention
		where `x` values are on the abscissa and `y` values on the ordinate
		axis.  Rather, `x` is histogrammed along the first dimension of the
		array (vertical), and `y` along the second dimension of the array
		(horizontal).  This ensures compatibility with `histogramdd`.
		
		Examples
		--------
		>>> from matplotlib.image import NonUniformImage
		>>> import matplotlib.pyplot as plt
		
		Construct a 2-D histogram with variable bin width. First define the bin
		edges:
		
		>>> xedges = [0, 1, 3, 5]
		>>> yedges = [0, 2, 3, 4, 6]
		
		Next we create a histogram H with random bin content:
		
		>>> x = np.random.normal(2, 1, 100)
		>>> y = np.random.normal(1, 1, 100)
		>>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
		>>> H = H.T  # Let each row list bins with common y range.
		
		:func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:
		
		>>> fig = plt.figure(figsize=(7, 3))
		>>> ax = fig.add_subplot(131, title='imshow: square bins')
		>>> plt.imshow(H, interpolation='nearest', origin='low',
		...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
		
		:func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:
		
		>>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
		...         aspect='equal')
		>>> X, Y = np.meshgrid(xedges, yedges)
		>>> ax.pcolormesh(X, Y, H)
		
		:class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to
		display actual bin edges with interpolation:
		
		>>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
		...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
		>>> im = NonUniformImage(ax, interpolation='bilinear')
		>>> xcenters = (xedges[:-1] + xedges[1:]) / 2
		>>> ycenters = (yedges[:-1] + yedges[1:]) / 2
		>>> im.set_data(xcenters, ycenters, H)
		>>> ax.images.append(im)
		>>> plt.show()
	**/
	static public function histogram2d(x:Dynamic, y:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?normed:Dynamic, ?weights:Dynamic, ?density:Dynamic):Dynamic;
	/**
		Function to calculate only the edges of the bins used by the `histogram` function.
		
		Parameters
		----------
		a : array_like
		    Input data. The histogram is computed over the flattened array.
		bins : int or sequence of scalars or str, optional
		    If `bins` is an int, it defines the number of equal-width
		    bins in the given range (10, by default). If `bins` is a
		    sequence, it defines the bin edges, including the rightmost
		    edge, allowing for non-uniform bin widths.
		
		    If `bins` is a string from the list below, `histogram_bin_edges` will use
		    the method chosen to calculate the optimal bin width and
		    consequently the number of bins (see `Notes` for more detail on
		    the estimators) from the data that falls within the requested
		    range. While the bin width will be optimal for the actual data
		    in the range, the number of bins will be computed to fill the
		    entire range, including the empty portions. For visualisation,
		    using the 'auto' option is suggested. Weighted data is not
		    supported for automated bin size selection.
		
		    'auto'
		        Maximum of the 'sturges' and 'fd' estimators. Provides good
		        all around performance.
		
		    'fd' (Freedman Diaconis Estimator)
		        Robust (resilient to outliers) estimator that takes into
		        account data variability and data size.
		
		    'doane'
		        An improved version of Sturges' estimator that works better
		        with non-normal datasets.
		
		    'scott'
		        Less robust estimator that that takes into account data
		        variability and data size.
		
		    'stone'
		        Estimator based on leave-one-out cross-validation estimate of
		        the integrated squared error. Can be regarded as a generalization
		        of Scott's rule.
		
		    'rice'
		        Estimator does not take variability into account, only data
		        size. Commonly overestimates number of bins required.
		
		    'sturges'
		        R's default method, only accounts for data size. Only
		        optimal for gaussian data and underestimates number of bins
		        for large non-gaussian datasets.
		
		    'sqrt'
		        Square root (of data size) estimator, used by Excel and
		        other programs for its speed and simplicity.
		
		range : (float, float), optional
		    The lower and upper range of the bins.  If not provided, range
		    is simply ``(a.min(), a.max())``.  Values outside the range are
		    ignored. The first element of the range must be less than or
		    equal to the second. `range` affects the automatic bin
		    computation as well. While bin width is computed to be optimal
		    based on the actual data within `range`, the bin count will fill
		    the entire range including portions containing no data.
		
		weights : array_like, optional
		    An array of weights, of the same shape as `a`.  Each value in
		    `a` only contributes its associated weight towards the bin count
		    (instead of 1). This is currently not used by any of the bin estimators,
		    but may be in the future.
		
		Returns
		-------
		bin_edges : array of dtype float
		    The edges to pass into `histogram`
		
		See Also
		--------
		histogram
		
		Notes
		-----
		The methods to estimate the optimal number of bins are well founded
		in literature, and are inspired by the choices R provides for
		histogram visualisation. Note that having the number of bins
		proportional to :math:`n^{1/3}` is asymptotically optimal, which is
		why it appears in most estimators. These are simply plug-in methods
		that give good starting points for number of bins. In the equations
		below, :math:`h` is the binwidth and :math:`n_h` is the number of
		bins. All estimators that compute bin counts are recast to bin width
		using the `ptp` of the data. The final bin count is obtained from
		``np.round(np.ceil(range / h))``.
		
		'Auto' (maximum of the 'Sturges' and 'FD' estimators)
		    A compromise to get a good value. For small datasets the Sturges
		    value will usually be chosen, while larger datasets will usually
		    default to FD.  Avoids the overly conservative behaviour of FD
		    and Sturges for small and large datasets respectively.
		    Switchover point is usually :math:`a.size \approx 1000`.
		
		'FD' (Freedman Diaconis Estimator)
		    .. math:: h = 2 \frac{IQR}{n^{1/3}}
		
		    The binwidth is proportional to the interquartile range (IQR)
		    and inversely proportional to cube root of a.size. Can be too
		    conservative for small datasets, but is quite good for large
		    datasets. The IQR is very robust to outliers.
		
		'Scott'
		    .. math:: h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}
		
		    The binwidth is proportional to the standard deviation of the
		    data and inversely proportional to cube root of ``x.size``. Can
		    be too conservative for small datasets, but is quite good for
		    large datasets. The standard deviation is not very robust to
		    outliers. Values are very similar to the Freedman-Diaconis
		    estimator in the absence of outliers.
		
		'Rice'
		    .. math:: n_h = 2n^{1/3}
		
		    The number of bins is only proportional to cube root of
		    ``a.size``. It tends to overestimate the number of bins and it
		    does not take into account data variability.
		
		'Sturges'
		    .. math:: n_h = \log _{2}n+1
		
		    The number of bins is the base 2 log of ``a.size``.  This
		    estimator assumes normality of data and is too conservative for
		    larger, non-normal datasets. This is the default method in R's
		    ``hist`` method.
		
		'Doane'
		    .. math:: n_h = 1 + \log_{2}(n) +
		                    \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})
		
		        g_1 = mean[(\frac{x - \mu}{\sigma})^3]
		
		        \sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}
		
		    An improved version of Sturges' formula that produces better
		    estimates for non-normal datasets. This estimator attempts to
		    account for the skew of the data.
		
		'Sqrt'
		    .. math:: n_h = \sqrt n
		    The simplest and fastest estimator. Only takes into account the
		    data size.
		
		Examples
		--------
		>>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
		>>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))
		array([0.  , 0.25, 0.5 , 0.75, 1.  ])
		>>> np.histogram_bin_edges(arr, bins=2)
		array([0. , 2.5, 5. ])
		
		For consistency with histogram, an array of pre-computed bins is
		passed through unmodified:
		
		>>> np.histogram_bin_edges(arr, [1, 2])
		array([1, 2])
		
		This function allows one set of bins to be computed, and reused across
		multiple histograms:
		
		>>> shared_bins = np.histogram_bin_edges(arr, bins='auto')
		>>> shared_bins
		array([0., 1., 2., 3., 4., 5.])
		
		>>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
		>>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)
		>>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)
		
		>>> hist_0; hist_1
		array([1, 1, 0, 1, 0])
		array([2, 0, 1, 1, 2])
		
		Which gives more easily comparable results than using separate bins for
		each histogram:
		
		>>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')
		>>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')
		>>> hist_0; hist1
		array([1, 1, 1])
		array([2, 1, 1, 2])
		>>> bins_0; bins_1
		array([0., 1., 2., 3.])
		array([0.  , 1.25, 2.5 , 3.75, 5.  ])
	**/
	static public function histogram_bin_edges(a:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?weights:Dynamic):Dynamic;
	/**
		Compute the multidimensional histogram of some data.
		
		Parameters
		----------
		sample : (N, D) array, or (D, N) array_like
		    The data to be histogrammed.
		
		    Note the unusual interpretation of sample when an array_like:
		
		    * When an array, each row is a coordinate in a D-dimensional space -
		      such as ``histogramgramdd(np.array([p1, p2, p3]))``.
		    * When an array_like, each element is the list of values for single
		      coordinate - such as ``histogramgramdd((X, Y, Z))``.
		
		    The first form should be preferred.
		
		bins : sequence or int, optional
		    The bin specification:
		
		    * A sequence of arrays describing the monotonically increasing bin
		      edges along each dimension.
		    * The number of bins for each dimension (nx, ny, ... =bins)
		    * The number of bins for all dimensions (nx=ny=...=bins).
		
		range : sequence, optional
		    A sequence of length D, each an optional (lower, upper) tuple giving
		    the outer bin edges to be used if the edges are not given explicitly in
		    `bins`.
		    An entry of None in the sequence results in the minimum and maximum
		    values being used for the corresponding dimension.
		    The default, None, is equivalent to passing a tuple of D None values.
		density : bool, optional
		    If False, the default, returns the number of samples in each bin.
		    If True, returns the probability *density* function at the bin,
		    ``bin_count / sample_count / bin_volume``.
		normed : bool, optional
		    An alias for the density argument that behaves identically. To avoid
		    confusion with the broken normed argument to `histogram`, `density`
		    should be preferred.
		weights : (N,) array_like, optional
		    An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.
		    Weights are normalized to 1 if normed is True. If normed is False,
		    the values of the returned histogram are equal to the sum of the
		    weights belonging to the samples falling into each bin.
		
		Returns
		-------
		H : ndarray
		    The multidimensional histogram of sample x. See normed and weights
		    for the different possible semantics.
		edges : list
		    A list of D arrays describing the bin edges for each dimension.
		
		See Also
		--------
		histogram: 1-D histogram
		histogram2d: 2-D histogram
		
		Examples
		--------
		>>> r = np.random.randn(100,3)
		>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))
		>>> H.shape, edges[0].size, edges[1].size, edges[2].size
		((5, 8, 4), 6, 9, 5)
	**/
	static public function histogramdd(sample:Dynamic, ?bins:Dynamic, ?range:Dynamic, ?normed:Dynamic, ?weights:Dynamic, ?density:Dynamic):Dynamic;
	/**
		Plot horizontal lines at each *y* from *xmin* to *xmax*.
		
		Parameters
		----------
		y : scalar or sequence of scalar
		    y-indexes where to plot the lines.
		
		xmin, xmax : scalar or 1D array_like
		    Respective beginning and end of each line. If scalars are
		    provided, all lines will have same length.
		
		colors : array_like of colors, optional, default: 'k'
		
		linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
		
		label : string, optional, default: ''
		
		Returns
		-------
		lines : `~matplotlib.collections.LineCollection`
		
		Other Parameters
		----------------
		**kwargs :  `~matplotlib.collections.LineCollection` properties.
		
		See also
		--------
		vlines : vertical lines
		axhline: horizontal line across the axes
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'colors', 'xmax', 'xmin', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function hlines(y:Dynamic, xmin:Dynamic, xmax:Dynamic, ?colors:Dynamic, ?linestyles:Dynamic, ?label:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "hot".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function hot():Dynamic;
	/**
		Split an array into multiple sub-arrays horizontally (column-wise).
		
		Please refer to the `split` documentation.  `hsplit` is equivalent
		to `split` with ``axis=1``, the array is always split along the second
		axis regardless of the array dimension.
		
		See Also
		--------
		split : Split an array into multiple sub-arrays of equal size.
		
		Examples
		--------
		>>> x = np.arange(16.0).reshape(4, 4)
		>>> x
		array([[  0.,   1.,   2.,   3.],
		       [  4.,   5.,   6.,   7.],
		       [  8.,   9.,  10.,  11.],
		       [ 12.,  13.,  14.,  15.]])
		>>> np.hsplit(x, 2)
		[array([[  0.,   1.],
		       [  4.,   5.],
		       [  8.,   9.],
		       [ 12.,  13.]]),
		 array([[  2.,   3.],
		       [  6.,   7.],
		       [ 10.,  11.],
		       [ 14.,  15.]])]
		>>> np.hsplit(x, np.array([3, 6]))
		[array([[  0.,   1.,   2.],
		       [  4.,   5.,   6.],
		       [  8.,   9.,  10.],
		       [ 12.,  13.,  14.]]),
		 array([[  3.],
		       [  7.],
		       [ 11.],
		       [ 15.]]),
		 array([], dtype=float64)]
		
		With a higher dimensional array the split is still along the second axis.
		
		>>> x = np.arange(8.0).reshape(2, 2, 2)
		>>> x
		array([[[ 0.,  1.],
		        [ 2.,  3.]],
		       [[ 4.,  5.],
		        [ 6.,  7.]]])
		>>> np.hsplit(x, 2)
		[array([[[ 0.,  1.]],
		       [[ 4.,  5.]]]),
		 array([[[ 2.,  3.]],
		       [[ 6.,  7.]]])]
	**/
	static public function hsplit(ary:Dynamic, indices_or_sections:Dynamic):Dynamic;
	/**
		Stack arrays in sequence horizontally (column wise).
		
		This is equivalent to concatenation along the second axis, except for 1-D
		arrays where it concatenates along the first axis. Rebuilds arrays divided
		by `hsplit`.
		
		This function makes most sense for arrays with up to 3 dimensions. For
		instance, for pixel-data with a height (first axis), width (second axis),
		and r/g/b channels (third axis). The functions `concatenate`, `stack` and
		`block` provide more general stacking and concatenation operations.
		
		Parameters
		----------
		tup : sequence of ndarrays
		    The arrays must have the same shape along all but the second axis,
		    except 1-D arrays which can be any length.
		
		Returns
		-------
		stacked : ndarray
		    The array formed by stacking the given arrays.
		
		See Also
		--------
		stack : Join a sequence of arrays along a new axis.
		vstack : Stack arrays in sequence vertically (row wise).
		dstack : Stack arrays in sequence depth wise (along third axis).
		concatenate : Join a sequence of arrays along an existing axis.
		hsplit : Split array along second axis.
		block : Assemble arrays from blocks.
		
		Examples
		--------
		>>> a = np.array((1,2,3))
		>>> b = np.array((2,3,4))
		>>> np.hstack((a,b))
		array([1, 2, 3, 2, 3, 4])
		>>> a = np.array([[1],[2],[3]])
		>>> b = np.array([[2],[3],[4]])
		>>> np.hstack((a,b))
		array([[1, 2],
		       [2, 3],
		       [3, 4]])
	**/
	static public function hstack(tup:Dynamic):Dynamic;
	/**
		Set the colormap to "hsv".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function hsv():Dynamic;
	/**
		hypergeometric(ngood, nbad, nsample, size=None)
		
		Draw samples from a Hypergeometric distribution.
		
		Samples are drawn from a hypergeometric distribution with specified
		parameters, ngood (ways to make a good selection), nbad (ways to make
		a bad selection), and nsample = number of items sampled, which is less
		than or equal to the sum ngood + nbad.
		
		Parameters
		----------
		ngood : int or array_like of ints
		    Number of ways to make a good selection.  Must be nonnegative.
		nbad : int or array_like of ints
		    Number of ways to make a bad selection.  Must be nonnegative.
		nsample : int or array_like of ints
		    Number of items sampled.  Must be at least 1 and at most
		    ``ngood + nbad``.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``ngood``, ``nbad``, and ``nsample``
		    are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``
		    samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized hypergeometric distribution.
		
		See Also
		--------
		scipy.stats.hypergeom : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Hypergeometric distribution is
		
		.. math:: P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},
		
		where :math:`0 \le x \le n` and :math:`n-b \le x \le g`
		
		for P(x) the probability of x successes, g = ngood, b = nbad, and
		n = number of samples.
		
		Consider an urn with black and white marbles in it, ngood of them
		black and nbad are white. If you draw nsample balls without
		replacement, then the hypergeometric distribution describes the
		distribution of black balls in the drawn sample.
		
		Note that this distribution is very similar to the binomial
		distribution, except that in this case, samples are drawn without
		replacement, whereas in the Binomial case samples are drawn with
		replacement (or the sample space is infinite). As the sample space
		becomes large, this distribution approaches the binomial.
		
		References
		----------
		.. [1] Lentner, Marvin, "Elementary Applied Statistics", Bogden
		       and Quigley, 1972.
		.. [2] Weisstein, Eric W. "Hypergeometric Distribution." From
		       MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/HypergeometricDistribution.html
		.. [3] Wikipedia, "Hypergeometric distribution",
		       https://en.wikipedia.org/wiki/Hypergeometric_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> ngood, nbad, nsamp = 100, 2, 10
		# number of good, number of bad, and number of samples
		>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
		>>> from matplotlib.pyplot import hist
		>>> hist(s)
		#   note that it is very unlikely to grab both bad items
		
		Suppose you have an urn with 15 white and 15 black marbles.
		If you pull 15 marbles at random, how likely is it that
		12 or more of them are one color?
		
		>>> s = np.random.hypergeometric(15, 15, 15, 100000)
		>>> sum(s>=12)/100000. + sum(s<=3)/100000.
		#   answer = 0.003 ... pretty unlikely!
	**/
	static public function hypergeometric(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Given the "legs" of a right triangle, return its hypotenuse.
		
		Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or
		`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),
		it is broadcast for use with each element of the other argument.
		(See Examples)
		
		Parameters
		----------
		x1, x2 : array_like
		    Leg of the triangle(s).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		z : ndarray
		    The hypotenuse of the triangle(s).
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Examples
		--------
		>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
		array([[ 5.,  5.,  5.],
		       [ 5.,  5.,  5.],
		       [ 5.,  5.,  5.]])
		
		Example showing broadcast of scalar_like argument:
		
		>>> np.hypot(3*np.ones((3, 3)), [4])
		array([[ 5.,  5.,  5.],
		       [ 5.,  5.,  5.],
		       [ 5.,  5.,  5.]])
	**/
	static public function hypot(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Modified Bessel function of the first kind, order 0.
		
		Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
		"up-cast" int dtype arguments unless accompanied by at least one float or
		complex dtype argument (see Raises below).
		
		Parameters
		----------
		x : array_like, dtype float or complex
		    Argument of the Bessel function.
		
		Returns
		-------
		out : ndarray, shape = x.shape, dtype = x.dtype
		    The modified Bessel function evaluated at each of the elements of `x`.
		
		Raises
		------
		TypeError: array cannot be safely cast to required type
		    If argument consists exclusively of int dtypes.
		
		See Also
		--------
		scipy.special.iv, scipy.special.ive
		
		Notes
		-----
		We use the algorithm published by Clenshaw [1]_ and referenced by
		Abramowitz and Stegun [2]_, for which the function domain is
		partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
		polynomial expansions are employed in each interval. Relative error on
		the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
		peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
		
		References
		----------
		.. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
		       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
		       Her Majesty's Stationery Office, 1962.
		.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
		       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
		       http://www.math.sfu.ca/~cbm/aands/page_379.htm
		.. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html
		
		Examples
		--------
		>>> np.i0([0.])
		array(1.0)
		>>> np.i0([0., 1. + 2j])
		array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])
	**/
	static public function i0(x:Dynamic):Dynamic;
	/**
		Return the identity array.
		
		The identity array is a square array with ones on
		the main diagonal.
		
		Parameters
		----------
		n : int
		    Number of rows (and columns) in `n` x `n` output.
		dtype : data-type, optional
		    Data-type of the output.  Defaults to ``float``.
		
		Returns
		-------
		out : ndarray
		    `n` x `n` array with its main diagonal set to one,
		    and all other elements 0.
		
		Examples
		--------
		>>> np.identity(3)
		array([[ 1.,  0.,  0.],
		       [ 0.,  1.,  0.],
		       [ 0.,  0.,  1.]])
	**/
	static public function identity(n:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		Compute the one-dimensional inverse discrete Fourier Transform.
		
		This function computes the inverse of the one-dimensional *n*-point
		discrete Fourier transform computed by `fft`.  In other words,
		``ifft(fft(a)) == a`` to within numerical accuracy.
		For a general description of the algorithm and definitions,
		see `numpy.fft`.
		
		The input should be ordered in the same way as is returned by `fft`,
		i.e.,
		
		* ``a[0]`` should contain the zero frequency term,
		* ``a[1:n//2]`` should contain the positive-frequency terms,
		* ``a[n//2 + 1:]`` should contain the negative-frequency terms, in
		  increasing order starting from the most negative frequency.
		
		For an even number of input points, ``A[n//2]`` represents the sum of
		the values at the positive and negative Nyquist frequencies, as the two
		are aliased together. See `numpy.fft` for details.
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex.
		n : int, optional
		    Length of the transformed axis of the output.
		    If `n` is smaller than the length of the input, the input is cropped.
		    If it is larger, the input is padded with zeros.  If `n` is not given,
		    the length of the input along the axis specified by `axis` is used.
		    See notes about padding issues.
		axis : int, optional
		    Axis over which to compute the inverse DFT.  If not given, the last
		    axis is used.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		
		Raises
		------
		IndexError
		    If `axes` is larger than the last axis of `a`.
		
		See Also
		--------
		numpy.fft : An introduction, with definitions and general explanations.
		fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
		ifft2 : The two-dimensional inverse FFT.
		ifftn : The n-dimensional inverse FFT.
		
		Notes
		-----
		If the input parameter `n` is larger than the size of the input, the input
		is padded by appending zeros at the end.  Even though this is the common
		approach, it might lead to surprising results.  If a different padding is
		desired, it must be performed before calling `ifft`.
		
		Examples
		--------
		>>> np.fft.ifft([0, 4, 0, 0])
		array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])
		
		Create and plot a band-limited signal with random phases:
		
		>>> import matplotlib.pyplot as plt
		>>> t = np.arange(400)
		>>> n = np.zeros((400,), dtype=complex)
		>>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
		>>> s = np.fft.ifft(n)
		>>> plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
		...
		>>> plt.legend(('real', 'imaginary'))
		...
		>>> plt.show()
	**/
	static public function ifft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the 2-dimensional inverse discrete Fourier Transform.
		
		This function computes the inverse of the 2-dimensional discrete Fourier
		Transform over any number of axes in an M-dimensional array by means of
		the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
		to within numerical accuracy.  By default, the inverse transform is
		computed over the last two axes of the input array.
		
		The input, analogously to `ifft`, should be ordered in the same way as is
		returned by `fft2`, i.e. it should have the term for zero frequency
		in the low-order corner of the two axes, the positive frequency terms in
		the first half of these axes, the term for the Nyquist frequency in the
		middle of the axes and the negative frequency terms in the second half of
		both axes, in order of decreasingly negative frequency.
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex.
		s : sequence of ints, optional
		    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
		    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
		    Along each axis, if the given shape is smaller than that of the input,
		    the input is cropped.  If it is larger, the input is padded with zeros.
		    if `s` is not given, the shape of the input along the axes specified
		    by `axes` is used.  See notes for issue on `ifft` zero padding.
		axes : sequence of ints, optional
		    Axes over which to compute the FFT.  If not given, the last two
		    axes are used.  A repeated index in `axes` means the transform over
		    that axis is performed multiple times.  A one-element sequence means
		    that a one-dimensional FFT is performed.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or the last two axes if `axes` is not given.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length, or `axes` not given and
		    ``len(s) != 2``.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		numpy.fft : Overall view of discrete Fourier transforms, with definitions
		     and conventions used.
		fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
		ifftn : The inverse of the *n*-dimensional FFT.
		fft : The one-dimensional FFT.
		ifft : The one-dimensional inverse FFT.
		
		Notes
		-----
		`ifft2` is just `ifftn` with a different default for `axes`.
		
		See `ifftn` for details and a plotting example, and `numpy.fft` for
		definition and conventions used.
		
		Zero-padding, analogously with `ifft`, is performed by appending zeros to
		the input along the specified dimension.  Although this is the common
		approach, it might lead to surprising results.  If another form of zero
		padding is desired, it must be performed before `ifft2` is called.
		
		Examples
		--------
		>>> a = 4 * np.eye(4)
		>>> np.fft.ifft2(a)
		array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
		       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
		       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
		       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
	**/
	static public function ifft2(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the N-dimensional inverse discrete Fourier Transform.
		
		This function computes the inverse of the N-dimensional discrete
		Fourier Transform over any number of axes in an M-dimensional array by
		means of the Fast Fourier Transform (FFT).  In other words,
		``ifftn(fftn(a)) == a`` to within numerical accuracy.
		For a description of the definitions and conventions used, see `numpy.fft`.
		
		The input, analogously to `ifft`, should be ordered in the same way as is
		returned by `fftn`, i.e. it should have the term for zero frequency
		in all axes in the low-order corner, the positive frequency terms in the
		first half of all axes, the term for the Nyquist frequency in the middle
		of all axes and the negative frequency terms in the second half of all
		axes, in order of decreasingly negative frequency.
		
		Parameters
		----------
		a : array_like
		    Input array, can be complex.
		s : sequence of ints, optional
		    Shape (length of each transformed axis) of the output
		    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
		    This corresponds to ``n`` for ``ifft(x, n)``.
		    Along any axis, if the given shape is smaller than that of the input,
		    the input is cropped.  If it is larger, the input is padded with zeros.
		    if `s` is not given, the shape of the input along the axes specified
		    by `axes` is used.  See notes for issue on `ifft` zero padding.
		axes : sequence of ints, optional
		    Axes over which to compute the IFFT.  If not given, the last ``len(s)``
		    axes are used, or all axes if `s` is also not specified.
		    Repeated indices in `axes` means that the inverse transform over that
		    axis is performed multiple times.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or by a combination of `s` or `a`,
		    as explained in the parameters section above.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		numpy.fft : Overall view of discrete Fourier transforms, with definitions
		     and conventions used.
		fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
		ifft : The one-dimensional inverse FFT.
		ifft2 : The two-dimensional inverse FFT.
		ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
		    of array.
		
		Notes
		-----
		See `numpy.fft` for definitions and conventions used.
		
		Zero-padding, analogously with `ifft`, is performed by appending zeros to
		the input along the specified dimension.  Although this is the common
		approach, it might lead to surprising results.  If another form of zero
		padding is desired, it must be performed before `ifftn` is called.
		
		Examples
		--------
		>>> a = np.eye(4)
		>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
		array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
		       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
		       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
		       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])
		
		
		Create and plot an image with band-limited frequency content:
		
		>>> import matplotlib.pyplot as plt
		>>> n = np.zeros((200,200), dtype=complex)
		>>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
		>>> im = np.fft.ifftn(n).real
		>>> plt.imshow(im)
		<matplotlib.image.AxesImage object at 0x...>
		>>> plt.show()
	**/
	static public function ifftn(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		The inverse of `fftshift`. Although identical for even-length `x`, the
		functions differ by one sample for odd-length `x`.
		
		Parameters
		----------
		x : array_like
		    Input array.
		axes : int or shape tuple, optional
		    Axes over which to calculate.  Defaults to None, which shifts all axes.
		
		Returns
		-------
		y : ndarray
		    The shifted array.
		
		See Also
		--------
		fftshift : Shift zero-frequency component to the center of the spectrum.
		
		Examples
		--------
		>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
		>>> freqs
		array([[ 0.,  1.,  2.],
		       [ 3.,  4., -4.],
		       [-3., -2., -1.]])
		>>> np.fft.ifftshift(np.fft.fftshift(freqs))
		array([[ 0.,  1.,  2.],
		       [ 3.,  4., -4.],
		       [-3., -2., -1.]])
	**/
	static public function ifftshift(x:Dynamic, ?axes:Dynamic):Dynamic;
	/**
		Compute the inverse FFT of a signal that has Hermitian symmetry.
		
		Parameters
		----------
		a : array_like
		    Input array.
		n : int, optional
		    Length of the inverse FFT, the number of points along
		    transformation axis in the input to use.  If `n` is smaller than
		    the length of the input, the input is cropped.  If it is larger,
		    the input is padded with zeros. If `n` is not given, the length of
		    the input along the axis specified by `axis` is used.
		axis : int, optional
		    Axis over which to compute the inverse FFT. If not given, the last
		    axis is used.
		norm : {None, "ortho"}, optional
		    Normalization mode (see `numpy.fft`). Default is None.
		
		    .. versionadded:: 1.10.0
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		    The length of the transformed axis is ``n//2 + 1``.
		
		See also
		--------
		hfft, irfft
		
		Notes
		-----
		`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
		opposite case: here the signal has Hermitian symmetry in the time
		domain and is real in the frequency domain. So here it's `hfft` for
		which you must supply the length of the result if it is to be odd:
		
		* even: ``ihfft(hfft(a, 2*len(a) - 2) == a``, within roundoff error,
		* odd: ``ihfft(hfft(a, 2*len(a) - 1) == a``, within roundoff error.
		
		Examples
		--------
		>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])
		>>> np.fft.ifft(spectrum)
		array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])
		>>> np.fft.ihfft(spectrum)
		array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])
	**/
	static public function ihfft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Return the imaginary part of the complex argument.
		
		Parameters
		----------
		val : array_like
		    Input array.
		
		Returns
		-------
		out : ndarray or scalar
		    The imaginary component of the complex argument. If `val` is real,
		    the type of `val` is used for the output.  If `val` has complex
		    elements, the returned type is float.
		
		See Also
		--------
		real, angle, real_if_close
		
		Examples
		--------
		>>> a = np.array([1+2j, 3+4j, 5+6j])
		>>> a.imag
		array([ 2.,  4.,  6.])
		>>> a.imag = np.array([8, 10, 12])
		>>> a
		array([ 1. +8.j,  3.+10.j,  5.+12.j])
		>>> np.imag(1 + 1j)
		1.0
	**/
	static public function imag(val:Dynamic):Dynamic;
	/**
		Read an image from a file into an array.
		
		Parameters
		----------
		fname : str or file-like
		    The image file to read. This can be a filename, a URL or a Python
		    file-like object opened in read-binary mode.
		format : str, optional
		    The image file format assumed for reading the data. If not
		    given, the format is deduced from the filename.  If nothing can
		    be deduced, PNG is tried.
		
		Returns
		-------
		imagedata : :class:`numpy.array`
		    The image data. The returned array has shape
		
		    - (M, N) for grayscale images.
		    - (M, N, 3) for RGB images.
		    - (M, N, 4) for RGBA images.
		
		Notes
		-----
		Matplotlib can only read PNGs natively. Further image formats are
		supported via the optional dependency on Pillow. Note, URL strings
		are not compatible with Pillow. Check the `Pillow documentation`_
		for more information.
		
		.. _Pillow documentation: http://pillow.readthedocs.io/en/latest/
	**/
	static public function imread(fname:Dynamic, ?format:Dynamic):Dynamic;
	/**
		Save an array as an image file.
		
		Parameters
		----------
		fname : str or PathLike file-like
		    A path or a Python file-like object to store the image in.
		    If *format* is not set, then the output format is inferred from the
		    extension of *fname*, if any, and from :rc:`savefig.format` otherwise.
		    If *format* is set, it determines the output format.
		arr : array-like
		    The image data. The shape can be one of
		    MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA).
		vmin, vmax : scalar, optional
		    *vmin* and *vmax* set the color scaling for the image by fixing the
		    values that map to the colormap color limits. If either *vmin*
		    or *vmax* is None, that limit is determined from the *arr*
		    min/max value.
		cmap : str or `~matplotlib.colors.Colormap`, optional
		    A Colormap instance or registered colormap name. The colormap
		    maps scalar data to colors. It is ignored for RGB(A) data.
		    Defaults to :rc:`image.cmap` ('viridis').
		format : str, optional
		    The file format, e.g. 'png', 'pdf', 'svg', ...  The behavior when this
		    is unset is documented under *fname*.
		origin : {'upper', 'lower'}, optional
		    Indicates whether the ``(0, 0)`` index of the array is in the upper
		    left or lower left corner of the axes.  Defaults to :rc:`image.origin`
		    ('upper').
		dpi : int
		    The DPI to store in the metadata of the file.  This does not affect the
		    resolution of the output image.
	**/
	static public function imsave(fname:Dynamic, arr:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Display an image, i.e. data on a 2D regular raster.
		
		Parameters
		----------
		X : array-like or PIL image
		    The image data. Supported array shapes are:
		
		    - (M, N): an image with scalar data. The data is visualized
		      using a colormap.
		    - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
		    - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
		      i.e. including transparency.
		
		    The first two dimensions (M, N) define the rows and columns of
		    the image.
		
		    Out-of-range RGB(A) values are clipped.
		
		cmap : str or `~matplotlib.colors.Colormap`, optional
		    The Colormap instance or registered colormap name used to map
		    scalar data to colors. This parameter is ignored for RGB(A) data.
		    Defaults to :rc:`image.cmap`.
		
		norm : `~matplotlib.colors.Normalize`, optional
		    The `Normalize` instance used to scale scalar data to the [0, 1]
		    range before mapping to colors using *cmap*. By default, a linear
		    scaling mapping the lowest value to 0 and the highest to 1 is used.
		    This parameter is ignored for RGB(A) data.
		
		aspect : {'equal', 'auto'} or float, optional
		    Controls the aspect ratio of the axes. The aspect is of particular
		    relevance for images since it may distort the image, i.e. pixel
		    will not be square.
		
		    This parameter is a shortcut for explicitly calling
		    `.Axes.set_aspect`. See there for further details.
		
		    - 'equal': Ensures an aspect ratio of 1. Pixels will be square
		      (unless pixel sizes are explicitly made non-square in data
		      coordinates using *extent*).
		    - 'auto': The axes is kept fixed and the aspect is adjusted so
		      that the data fit in the axes. In general, this will result in
		      non-square pixels.
		
		    If not given, use :rc:`image.aspect` (default: 'equal').
		
		interpolation : str, optional
		    The interpolation method used. If *None*
		    :rc:`image.interpolation` is used, which defaults to 'nearest'.
		
		    Supported values are 'none', 'nearest', 'bilinear', 'bicubic',
		    'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 'kaiser',
		    'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc',
		    'lanczos'.
		
		    If *interpolation* is 'none', then no interpolation is performed
		    on the Agg, ps, pdf and svg backends. Other backends will fall back
		    to 'nearest'. Note that most SVG renders perform interpolation at
		    rendering and that the default interpolation method they implement
		    may differ.
		
		    See
		    :doc:`/gallery/images_contours_and_fields/interpolation_methods`
		    for an overview of the supported interpolation methods.
		
		    Some interpolation methods require an additional radius parameter,
		    which can be set by *filterrad*. Additionally, the antigrain image
		    resize filter is controlled by the parameter *filternorm*.
		
		alpha : scalar, optional
		    The alpha blending value, between 0 (transparent) and 1 (opaque).
		    This parameter is ignored for RGBA input data.
		
		vmin, vmax : scalar, optional
		    When using scalar data and no explicit *norm*, *vmin* and *vmax*
		    define the data range that the colormap covers. By default,
		    the colormap covers the complete value range of the supplied
		    data. *vmin*, *vmax* are ignored if the *norm* parameter is used.
		
		origin : {'upper', 'lower'}, optional
		    Place the [0,0] index of the array in the upper left or lower left
		    corner of the axes. The convention 'upper' is typically used for
		    matrices and images.
		    If not given, :rc:`image.origin` is used, defaulting to 'upper'.
		
		    Note that the vertical axes points upward for 'lower'
		    but downward for 'upper'.
		
		extent : scalars (left, right, bottom, top), optional
		    The bounding box in data coordinates that the image will fill.
		    The image is stretched individually along x and y to fill the box.
		
		    The default extent is determined by the following conditions.
		    Pixels have unit size in data coordinates. Their centers are on
		    integer coordinates, and their center coordinates range from 0 to
		    columns-1 horizontally and from 0 to rows-1 vertically.
		
		    Note that the direction of the vertical axis and thus the default
		    values for top and bottom depend on *origin*:
		
		    - For ``origin == 'upper'`` the default is
		      ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
		    - For ``origin == 'lower'`` the default is
		      ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
		
		    See the example :doc:`/tutorials/intermediate/imshow_extent` for a
		    more detailed description.
		
		filternorm : bool, optional, default: True
		    A parameter for the antigrain image resize filter (see the
		    antigrain documentation).  If *filternorm* is set, the filter
		    normalizes integer values and corrects the rounding errors. It
		    doesn't do anything with the source floating point values, it
		    corrects only integers according to the rule of 1.0 which means
		    that any sum of pixel weights must be equal to 1.0.  So, the
		    filter function must produce a graph of the proper shape.
		
		filterrad : float > 0, optional, default: 4.0
		    The filter radius for filters that have a radius parameter, i.e.
		    when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
		
		resample : bool, optional
		    When *True*, use a full resampling method.  When *False*, only
		    resample when the output image is larger than the input image.
		
		url : str, optional
		    Set the url of the created `.AxesImage`. See `.Artist.set_url`.
		
		Returns
		-------
		image : `~matplotlib.image.AxesImage`
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.artist.Artist` properties
		    These parameters are passed on to the constructor of the
		    `.AxesImage` artist.
		
		See also
		--------
		matshow : Plot a matrix or an array as an image.
		
		Notes
		-----
		Unless *extent* is used, pixel centers will be located at integer
		coordinates. In other words: the origin will coincide with the center
		of pixel (0, 0).
		
		There are two common representations for RGB images with an alpha
		channel:
		
		-   Straight (unassociated) alpha: R, G, and B channels represent the
		    color of the pixel, disregarding its opacity.
		-   Premultiplied (associated) alpha: R, G, and B channels represent
		    the color of the pixel, adjusted for its opacity by multiplication.
		
		`~matplotlib.pyplot.imshow` expects RGB images adopting the straight
		(unassociated) alpha representation.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function imshow(X:Dynamic, ?cmap:Dynamic, ?norm:Dynamic, ?aspect:Dynamic, ?interpolation:Dynamic, ?alpha:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?origin:Dynamic, ?extent:Dynamic, ?shape:Dynamic, ?filternorm:Dynamic, ?filterrad:Dynamic, ?imlim:Dynamic, ?resample:Dynamic, ?url:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Test whether each element of a 1-D array is also present in a second array.
		
		Returns a boolean array the same length as `ar1` that is True
		where an element of `ar1` is in `ar2` and False otherwise.
		
		We recommend using :func:`isin` instead of `in1d` for new code.
		
		Parameters
		----------
		ar1 : (M,) array_like
		    Input array.
		ar2 : array_like
		    The values against which to test each value of `ar1`.
		assume_unique : bool, optional
		    If True, the input arrays are both assumed to be unique, which
		    can speed up the calculation.  Default is False.
		invert : bool, optional
		    If True, the values in the returned array are inverted (that is,
		    False where an element of `ar1` is in `ar2` and True otherwise).
		    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
		    to (but is faster than) ``np.invert(in1d(a, b))``.
		
		    .. versionadded:: 1.8.0
		
		Returns
		-------
		in1d : (M,) ndarray, bool
		    The values `ar1[in1d]` are in `ar2`.
		
		See Also
		--------
		isin                  : Version of this function that preserves the
		                        shape of ar1.
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Notes
		-----
		`in1d` can be considered as an element-wise function version of the
		python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly
		equivalent to ``np.array([item in b for item in a])``.
		However, this idea fails if `ar2` is a set, or similar (non-sequence)
		container:  As ``ar2`` is converted to an array, in those cases
		``asarray(ar2)`` is an object array rather than the expected array of
		contained values.
		
		.. versionadded:: 1.4.0
		
		Examples
		--------
		>>> test = np.array([0, 1, 2, 5, 0])
		>>> states = [0, 2]
		>>> mask = np.in1d(test, states)
		>>> mask
		array([ True, False,  True, False,  True])
		>>> test[mask]
		array([0, 2, 0])
		>>> mask = np.in1d(test, states, invert=True)
		>>> mask
		array([False,  True, False,  True, False])
		>>> test[mask]
		array([1, 5])
	**/
	static public function in1d(ar1:Dynamic, ar2:Dynamic, ?assume_unique:Dynamic, ?invert:Dynamic):Dynamic;
	static public var index_exp : Dynamic;
	/**
		Return an array representing the indices of a grid.
		
		Compute an array where the subarrays contain index values 0,1,...
		varying only along the corresponding axis.
		
		Parameters
		----------
		dimensions : sequence of ints
		    The shape of the grid.
		dtype : dtype, optional
		    Data type of the result.
		
		Returns
		-------
		grid : ndarray
		    The array of grid indices,
		    ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
		
		See Also
		--------
		mgrid, meshgrid
		
		Notes
		-----
		The output shape is obtained by prepending the number of dimensions
		in front of the tuple of dimensions, i.e. if `dimensions` is a tuple
		``(r0, ..., rN-1)`` of length ``N``, the output shape is
		``(N,r0,...,rN-1)``.
		
		The subarrays ``grid[k]`` contains the N-D array of indices along the
		``k-th`` axis. Explicitly::
		
		    grid[k,i0,i1,...,iN-1] = ik
		
		Examples
		--------
		>>> grid = np.indices((2, 3))
		>>> grid.shape
		(2, 2, 3)
		>>> grid[0]        # row indices
		array([[0, 0, 0],
		       [1, 1, 1]])
		>>> grid[1]        # column indices
		array([[0, 1, 2],
		       [0, 1, 2]])
		
		The indices can be used as an index into an array.
		
		>>> x = np.arange(20).reshape(5, 4)
		>>> row, col = np.indices((2, 3))
		>>> x[row, col]
		array([[0, 1, 2],
		       [4, 5, 6]])
		
		Note that it would be more straightforward in the above example to
		extract the required elements directly with ``x[:2, :3]``.
	**/
	static public function indices(dimensions:Dynamic, ?dtype:Dynamic):Dynamic;
	static public var inf : Dynamic;
	/**
		Set the colormap to "inferno".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function inferno():Dynamic;
	static public var infty : Dynamic;
	/**
		inner(a, b)
		
		Inner product of two arrays.
		
		Ordinary inner product of vectors for 1-D arrays (without complex
		conjugation), in higher dimensions a sum product over the last axes.
		
		Parameters
		----------
		a, b : array_like
		    If `a` and `b` are nonscalar, their last dimensions must match.
		
		Returns
		-------
		out : ndarray
		    `out.shape = a.shape[:-1] + b.shape[:-1]`
		
		Raises
		------
		ValueError
		    If the last dimension of `a` and `b` has different size.
		
		See Also
		--------
		tensordot : Sum products over arbitrary axes.
		dot : Generalised matrix product, using second last dimension of `b`.
		einsum : Einstein summation convention.
		
		Notes
		-----
		For vectors (1-D arrays) it computes the ordinary inner-product::
		
		    np.inner(a, b) = sum(a[:]*b[:])
		
		More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::
		
		    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
		
		or explicitly::
		
		    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
		         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])
		
		In addition `a` or `b` may be scalars, in which case::
		
		   np.inner(a,b) = a*b
		
		Examples
		--------
		Ordinary inner product for vectors:
		
		>>> a = np.array([1,2,3])
		>>> b = np.array([0,1,0])
		>>> np.inner(a, b)
		2
		
		A multidimensional example:
		
		>>> a = np.arange(24).reshape((2,3,4))
		>>> b = np.arange(4)
		>>> np.inner(a, b)
		array([[ 14,  38,  62],
		       [ 86, 110, 134]])
		
		An example where `b` is a scalar:
		
		>>> np.inner(np.eye(2), 7)
		array([[ 7.,  0.],
		       [ 0.,  7.]])
	**/
	static public function inner(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Insert values along the given axis before the given indices.
		
		Parameters
		----------
		arr : array_like
		    Input array.
		obj : int, slice or sequence of ints
		    Object that defines the index or indices before which `values` is
		    inserted.
		
		    .. versionadded:: 1.8.0
		
		    Support for multiple insertions when `obj` is a single scalar or a
		    sequence with one element (similar to calling insert multiple
		    times).
		values : array_like
		    Values to insert into `arr`. If the type of `values` is different
		    from that of `arr`, `values` is converted to the type of `arr`.
		    `values` should be shaped so that ``arr[...,obj,...] = values``
		    is legal.
		axis : int, optional
		    Axis along which to insert `values`.  If `axis` is None then `arr`
		    is flattened first.
		
		Returns
		-------
		out : ndarray
		    A copy of `arr` with `values` inserted.  Note that `insert`
		    does not occur in-place: a new array is returned. If
		    `axis` is None, `out` is a flattened array.
		
		See Also
		--------
		append : Append elements at the end of an array.
		concatenate : Join a sequence of arrays along an existing axis.
		delete : Delete elements from an array.
		
		Notes
		-----
		Note that for higher dimensional inserts `obj=0` behaves very different
		from `obj=[0]` just like `arr[:,0,:] = values` is different from
		`arr[:,[0],:] = values`.
		
		Examples
		--------
		>>> a = np.array([[1, 1], [2, 2], [3, 3]])
		>>> a
		array([[1, 1],
		       [2, 2],
		       [3, 3]])
		>>> np.insert(a, 1, 5)
		array([1, 5, 1, 2, 2, 3, 3])
		>>> np.insert(a, 1, 5, axis=1)
		array([[1, 5, 1],
		       [2, 5, 2],
		       [3, 5, 3]])
		
		Difference between sequence and scalars:
		
		>>> np.insert(a, [1], [[1],[2],[3]], axis=1)
		array([[1, 1, 1],
		       [2, 2, 2],
		       [3, 3, 3]])
		>>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
		...                np.insert(a, [1], [[1],[2],[3]], axis=1))
		True
		
		>>> b = a.flatten()
		>>> b
		array([1, 1, 2, 2, 3, 3])
		>>> np.insert(b, [2, 2], [5, 6])
		array([1, 1, 5, 6, 2, 2, 3, 3])
		
		>>> np.insert(b, slice(2, 4), [5, 6])
		array([1, 1, 5, 2, 6, 2, 3, 3])
		
		>>> np.insert(b, [2, 2], [7.13, False]) # type casting
		array([1, 1, 7, 0, 2, 2, 3, 3])
		
		>>> x = np.arange(8).reshape(2, 4)
		>>> idx = (1, 3)
		>>> np.insert(x, idx, 999, axis=1)
		array([[  0, 999,   1,   2, 999,   3],
		       [  4, 999,   5,   6, 999,   7]])
	**/
	static public function insert(arr:Dynamic, obj:Dynamic, values:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Install a repl display hook so that any stale figure are automatically
		redrawn when control is returned to the repl.
		
		This works both with IPython and with vanilla python shells.
	**/
	static public function install_repl_displayhook():Dynamic;
	static public function int_asbuffer(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set interactive mode to boolean b.
		
		If b is True, then draw after every plotting command, e.g., after xlabel
	**/
	static public function interactive(b:Dynamic):Dynamic;
	/**
		One-dimensional linear interpolation.
		
		Returns the one-dimensional piecewise linear interpolant to a function
		with given discrete data points (`xp`, `fp`), evaluated at `x`.
		
		Parameters
		----------
		x : array_like
		    The x-coordinates at which to evaluate the interpolated values.
		
		xp : 1-D sequence of floats
		    The x-coordinates of the data points, must be increasing if argument
		    `period` is not specified. Otherwise, `xp` is internally sorted after
		    normalizing the periodic boundaries with ``xp = xp % period``.
		
		fp : 1-D sequence of float or complex
		    The y-coordinates of the data points, same length as `xp`.
		
		left : optional float or complex corresponding to fp
		    Value to return for `x < xp[0]`, default is `fp[0]`.
		
		right : optional float or complex corresponding to fp
		    Value to return for `x > xp[-1]`, default is `fp[-1]`.
		
		period : None or float, optional
		    A period for the x-coordinates. This parameter allows the proper
		    interpolation of angular x-coordinates. Parameters `left` and `right`
		    are ignored if `period` is specified.
		
		    .. versionadded:: 1.10.0
		
		Returns
		-------
		y : float or complex (corresponding to fp) or ndarray
		    The interpolated values, same shape as `x`.
		
		Raises
		------
		ValueError
		    If `xp` and `fp` have different length
		    If `xp` or `fp` are not 1-D sequences
		    If `period == 0`
		
		Notes
		-----
		Does not check that the x-coordinate sequence `xp` is increasing.
		If `xp` is not increasing, the results are nonsense.
		A simple check for increasing is::
		
		    np.all(np.diff(xp) > 0)
		
		Examples
		--------
		>>> xp = [1, 2, 3]
		>>> fp = [3, 2, 0]
		>>> np.interp(2.5, xp, fp)
		1.0
		>>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
		array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])
		>>> UNDEF = -99.0
		>>> np.interp(3.14, xp, fp, right=UNDEF)
		-99.0
		
		Plot an interpolant to the sine function:
		
		>>> x = np.linspace(0, 2*np.pi, 10)
		>>> y = np.sin(x)
		>>> xvals = np.linspace(0, 2*np.pi, 50)
		>>> yinterp = np.interp(xvals, x, y)
		>>> import matplotlib.pyplot as plt
		>>> plt.plot(x, y, 'o')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.plot(xvals, yinterp, '-x')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.show()
		
		Interpolation with periodic x-coordinates:
		
		>>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
		>>> xp = [190, -190, 350, -350]
		>>> fp = [5, 10, 3, 4]
		>>> np.interp(x, xp, fp, period=360)
		array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])
		
		Complex interpolation:
		
		>>> x = [1.5, 4.0]
		>>> xp = [2,3,5]
		>>> fp = [1.0j, 0, 2+3j]
		>>> np.interp(x, xp, fp)
		array([ 0.+1.j ,  1.+1.5j])
	**/
	static public function interp(x:Dynamic, xp:Dynamic, fp:Dynamic, ?left:Dynamic, ?right:Dynamic, ?period:Dynamic):Dynamic;
	/**
		Find the intersection of two arrays.
		
		Return the sorted, unique values that are in both of the input arrays.
		
		Parameters
		----------
		ar1, ar2 : array_like
		    Input arrays. Will be flattened if not already 1D.
		assume_unique : bool
		    If True, the input arrays are both assumed to be unique, which
		    can speed up the calculation.  Default is False.
		return_indices : bool
		    If True, the indices which correspond to the intersection of the two
		    arrays are returned. The first instance of a value is used if there are
		    multiple. Default is False.
		
		    .. versionadded:: 1.15.0
		
		Returns
		-------
		intersect1d : ndarray
		    Sorted 1D array of common and unique elements.
		comm1 : ndarray
		    The indices of the first occurrences of the common values in `ar1`.
		    Only provided if `return_indices` is True.
		comm2 : ndarray
		    The indices of the first occurrences of the common values in `ar2`.
		    Only provided if `return_indices` is True.
		
		
		See Also
		--------
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Examples
		--------
		>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
		array([1, 3])
		
		To intersect more than two arrays, use functools.reduce:
		
		>>> from functools import reduce
		>>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
		array([3])
		
		To return the indices of the values common to the input arrays
		along with the intersected values:
		>>> x = np.array([1, 1, 2, 3, 4])
		>>> y = np.array([2, 1, 4, 6])
		>>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
		>>> x_ind, y_ind
		(array([0, 2, 4]), array([1, 0, 2]))
		>>> xy, x[x_ind], y[y_ind]
		(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))
	**/
	static public function intersect1d(ar1:Dynamic, ar2:Dynamic, ?assume_unique:Dynamic, ?return_indices:Dynamic):Dynamic;
	/**
		Compute the (multiplicative) inverse of a matrix.
		
		Given a square matrix `a`, return the matrix `ainv` satisfying
		``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Matrix to be inverted.
		
		Returns
		-------
		ainv : (..., M, M) ndarray or matrix
		    (Multiplicative) inverse of the matrix `a`.
		
		Raises
		------
		LinAlgError
		    If `a` is not square or inversion fails.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		Examples
		--------
		>>> from numpy.linalg import inv
		>>> a = np.array([[1., 2.], [3., 4.]])
		>>> ainv = inv(a)
		>>> np.allclose(np.dot(a, ainv), np.eye(2))
		True
		>>> np.allclose(np.dot(ainv, a), np.eye(2))
		True
		
		If a is a matrix object, then the return value is a matrix as well:
		
		>>> ainv = inv(np.matrix(a))
		>>> ainv
		matrix([[-2. ,  1. ],
		        [ 1.5, -0.5]])
		
		Inverses of several matrices can be computed at once:
		
		>>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
		>>> inv(a)
		array([[[-2. ,  1. ],
		        [ 1.5, -0.5]],
		       [[-5. ,  2. ],
		        [ 3. , -1. ]]])
	**/
	static public function inv(a:Dynamic):Dynamic;
	/**
		invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute bit-wise inversion, or bit-wise NOT, element-wise.
		
		Computes the bit-wise NOT of the underlying binary representation of
		the integers in the input arrays. This ufunc implements the C/Python
		operator ``~``.
		
		For signed integer inputs, the two's complement is returned.  In a
		two's-complement system negative numbers are represented by the two's
		complement of the absolute value. This is the most common method of
		representing signed integers on computers [1]_. A N-bit
		two's-complement system can represent every integer in the range
		:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
		
		Parameters
		----------
		x : array_like
		    Only integer and boolean types are handled.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Result.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		bitwise_and, bitwise_or, bitwise_xor
		logical_not
		binary_repr :
		    Return the binary representation of the input number as a string.
		
		Notes
		-----
		`bitwise_not` is an alias for `invert`:
		
		>>> np.bitwise_not is np.invert
		True
		
		References
		----------
		.. [1] Wikipedia, "Two's complement",
		    https://en.wikipedia.org/wiki/Two's_complement
		
		Examples
		--------
		We've seen that 13 is represented by ``00001101``.
		The invert or bit-wise NOT of 13 is then:
		
		>>> np.invert(np.array([13], dtype=uint8))
		array([242], dtype=uint8)
		>>> np.binary_repr(x, width=8)
		'00001101'
		>>> np.binary_repr(242, width=8)
		'11110010'
		
		The result depends on the bit-width:
		
		>>> np.invert(np.array([13], dtype=uint16))
		array([65522], dtype=uint16)
		>>> np.binary_repr(x, width=16)
		'0000000000001101'
		>>> np.binary_repr(65522, width=16)
		'1111111111110010'
		
		When using signed integer types the result is the two's complement of
		the result for the unsigned type:
		
		>>> np.invert(np.array([13], dtype=int8))
		array([-14], dtype=int8)
		>>> np.binary_repr(-14, width=8)
		'11110010'
		
		Booleans are accepted as well:
		
		>>> np.invert(array([True, False]))
		array([False,  True])
	**/
	static public function invert(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Turn the interactive mode off.
	**/
	static public function ioff():Dynamic;
	/**
		Turn the interactive mode on.
	**/
	static public function ion():Dynamic;
	/**
		Compute the interest portion of a payment.
		
		Parameters
		----------
		rate : scalar or array_like of shape(M, )
		    Rate of interest as decimal (not per cent) per period
		per : scalar or array_like of shape(M, )
		    Interest paid against the loan changes during the life or the loan.
		    The `per` is the payment period to calculate the interest amount.
		nper : scalar or array_like of shape(M, )
		    Number of compounding periods
		pv : scalar or array_like of shape(M, )
		    Present value
		fv : scalar or array_like of shape(M, ), optional
		    Future value
		when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
		    When payments are due ('begin' (1) or 'end' (0)).
		    Defaults to {'end', 0}.
		
		Returns
		-------
		out : ndarray
		    Interest portion of payment.  If all input is scalar, returns a scalar
		    float.  If any input is array_like, returns interest payment for each
		    input element. If multiple inputs are array_like, they all must have
		    the same shape.
		
		See Also
		--------
		ppmt, pmt, pv
		
		Notes
		-----
		The total payment is made up of payment against principal plus interest.
		
		``pmt = ppmt + ipmt``
		
		Examples
		--------
		What is the amortization schedule for a 1 year loan of $2500 at
		8.24% interest per year compounded monthly?
		
		>>> principal = 2500.00
		
		The 'per' variable represents the periods of the loan.  Remember that
		financial equations start the period count at 1!
		
		>>> per = np.arange(1*12) + 1
		>>> ipmt = np.ipmt(0.0824/12, per, 1*12, principal)
		>>> ppmt = np.ppmt(0.0824/12, per, 1*12, principal)
		
		Each element of the sum of the 'ipmt' and 'ppmt' arrays should equal
		'pmt'.
		
		>>> pmt = np.pmt(0.0824/12, 1*12, principal)
		>>> np.allclose(ipmt + ppmt, pmt)
		True
		
		>>> fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'
		>>> for payment in per:
		...     index = payment - 1
		...     principal = principal + ppmt[index]
		...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))
		 1  -200.58   -17.17  2299.42
		 2  -201.96   -15.79  2097.46
		 3  -203.35   -14.40  1894.11
		 4  -204.74   -13.01  1689.37
		 5  -206.15   -11.60  1483.22
		 6  -207.56   -10.18  1275.66
		 7  -208.99    -8.76  1066.67
		 8  -210.42    -7.32   856.25
		 9  -211.87    -5.88   644.38
		10  -213.32    -4.42   431.05
		11  -214.79    -2.96   216.26
		12  -216.26    -1.49    -0.00
		
		>>> interestpd = np.sum(ipmt)
		>>> np.round(interestpd, 2)
		-112.98
	**/
	static public function ipmt(rate:Dynamic, per:Dynamic, nper:Dynamic, pv:Dynamic, ?fv:Dynamic, ?when:Dynamic):Dynamic;
	/**
		Compute the inverse of the n-point DFT for real input.
		
		This function computes the inverse of the one-dimensional *n*-point
		discrete Fourier Transform of real input computed by `rfft`.
		In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
		accuracy. (See Notes below for why ``len(a)`` is necessary here.)
		
		The input is expected to be in the form returned by `rfft`, i.e. the
		real zero-frequency term followed by the complex positive frequency terms
		in order of increasing frequency.  Since the discrete Fourier Transform of
		real input is Hermitian-symmetric, the negative frequency terms are taken
		to be the complex conjugates of the corresponding positive frequency terms.
		
		Parameters
		----------
		a : array_like
		    The input array.
		n : int, optional
		    Length of the transformed axis of the output.
		    For `n` output points, ``n//2+1`` input points are necessary.  If the
		    input is longer than this, it is cropped.  If it is shorter than this,
		    it is padded with zeros.  If `n` is not given, it is determined from
		    the length of the input along the axis specified by `axis`.
		axis : int, optional
		    Axis over which to compute the inverse FFT. If not given, the last
		    axis is used.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		    The length of the transformed axis is `n`, or, if `n` is not given,
		    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
		    input. To get an odd number of output points, `n` must be specified.
		
		Raises
		------
		IndexError
		    If `axis` is larger than the last axis of `a`.
		
		See Also
		--------
		numpy.fft : For definition of the DFT and conventions used.
		rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.
		fft : The one-dimensional FFT.
		irfft2 : The inverse of the two-dimensional FFT of real input.
		irfftn : The inverse of the *n*-dimensional FFT of real input.
		
		Notes
		-----
		Returns the real valued `n`-point inverse discrete Fourier transform
		of `a`, where `a` contains the non-negative frequency terms of a
		Hermitian-symmetric sequence. `n` is the length of the result, not the
		input.
		
		If you specify an `n` such that `a` must be zero-padded or truncated, the
		extra/removed values will be added/removed at high frequencies. One can
		thus resample a series to `m` points via Fourier interpolation by:
		``a_resamp = irfft(rfft(a), m)``.
		
		Examples
		--------
		>>> np.fft.ifft([1, -1j, -1, 1j])
		array([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])
		>>> np.fft.irfft([1, -1j, -1])
		array([ 0.,  1.,  0.,  0.])
		
		Notice how the last term in the input to the ordinary `ifft` is the
		complex conjugate of the second term, and the output has zero imaginary
		part everywhere.  When calling `irfft`, the negative frequencies are not
		specified, and the output array is purely real.
	**/
	static public function irfft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the 2-dimensional inverse FFT of a real array.
		
		Parameters
		----------
		a : array_like
		    The input array
		s : sequence of ints, optional
		    Shape of the inverse FFT.
		axes : sequence of ints, optional
		    The axes over which to compute the inverse fft.
		    Default is the last two axes.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : ndarray
		    The result of the inverse real 2-D FFT.
		
		See Also
		--------
		irfftn : Compute the inverse of the N-dimensional FFT of real input.
		
		Notes
		-----
		This is really `irfftn` with different defaults.
		For more details see `irfftn`.
	**/
	static public function irfft2(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the inverse of the N-dimensional FFT of real input.
		
		This function computes the inverse of the N-dimensional discrete
		Fourier Transform for real input over any number of axes in an
		M-dimensional array by means of the Fast Fourier Transform (FFT).  In
		other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
		accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
		and for the same reason.)
		
		The input should be ordered in the same way as is returned by `rfftn`,
		i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
		along all the other axes.
		
		Parameters
		----------
		a : array_like
		    Input array.
		s : sequence of ints, optional
		    Shape (length of each transformed axis) of the output
		    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
		    number of input points used along this axis, except for the last axis,
		    where ``s[-1]//2+1`` points of the input are used.
		    Along any axis, if the shape indicated by `s` is smaller than that of
		    the input, the input is cropped.  If it is larger, the input is padded
		    with zeros. If `s` is not given, the shape of the input along the
		    axes specified by `axes` is used.
		axes : sequence of ints, optional
		    Axes over which to compute the inverse FFT. If not given, the last
		    `len(s)` axes are used, or all axes if `s` is also not specified.
		    Repeated indices in `axes` means that the inverse transform over that
		    axis is performed multiple times.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or by a combination of `s` or `a`,
		    as explained in the parameters section above.
		    The length of each transformed axis is as given by the corresponding
		    element of `s`, or the length of the input in every axis except for the
		    last one if `s` is not given.  In the final transformed axis the length
		    of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
		    length of the final transformed axis of the input.  To get an odd
		    number of output points in the final axis, `s` must be specified.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		rfftn : The forward n-dimensional FFT of real input,
		        of which `ifftn` is the inverse.
		fft : The one-dimensional FFT, with definitions and conventions used.
		irfft : The inverse of the one-dimensional FFT of real input.
		irfft2 : The inverse of the two-dimensional FFT of real input.
		
		Notes
		-----
		See `fft` for definitions and conventions used.
		
		See `rfft` for definitions and conventions used for real input.
		
		Examples
		--------
		>>> a = np.zeros((3, 2, 2))
		>>> a[0, 0, 0] = 3 * 2 * 2
		>>> np.fft.irfftn(a)
		array([[[ 1.,  1.],
		        [ 1.,  1.]],
		       [[ 1.,  1.],
		        [ 1.,  1.]],
		       [[ 1.,  1.],
		        [ 1.,  1.]]])
	**/
	static public function irfftn(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Return the Internal Rate of Return (IRR).
		
		This is the "average" periodically compounded rate of return
		that gives a net present value of 0.0; for a more complete explanation,
		see Notes below.
		
		:class:`decimal.Decimal` type is not supported.
		
		Parameters
		----------
		values : array_like, shape(N,)
		    Input cash flows per time period.  By convention, net "deposits"
		    are negative and net "withdrawals" are positive.  Thus, for
		    example, at least the first element of `values`, which represents
		    the initial investment, will typically be negative.
		
		Returns
		-------
		out : float
		    Internal Rate of Return for periodic input values.
		
		Notes
		-----
		The IRR is perhaps best understood through an example (illustrated
		using np.irr in the Examples section below).  Suppose one invests 100
		units and then makes the following withdrawals at regular (fixed)
		intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one's 100
		unit investment yields 173 units; however, due to the combination of
		compounding and the periodic withdrawals, the "average" rate of return
		is neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution
		(for :math:`r`) of the equation:
		
		.. math:: -100 + \frac{39}{1+r} + \frac{59}{(1+r)^2}
		 + \frac{55}{(1+r)^3} + \frac{20}{(1+r)^4} = 0
		
		In general, for `values` :math:`= [v_0, v_1, ... v_M]`,
		irr is the solution of the equation: [G]_
		
		.. math:: \sum_{t=0}^M{\frac{v_t}{(1+irr)^{t}}} = 0
		
		References
		----------
		.. [G] L. J. Gitman, "Principles of Managerial Finance, Brief," 3rd ed.,
		   Addison-Wesley, 2003, pg. 348.
		
		Examples
		--------
		>>> round(irr([-100, 39, 59, 55, 20]), 5)
		0.28095
		>>> round(irr([-100, 0, 0, 74]), 5)
		-0.0955
		>>> round(irr([-100, 100, 0, -7]), 5)
		-0.0833
		>>> round(irr([-100, 100, 0, 7]), 5)
		0.06206
		>>> round(irr([-5, 10.5, 1, -8, 1]), 5)
		0.0886
		
		(Compare with the Example given for numpy.lib.financial.npv)
	**/
	static public function irr(values:Dynamic):Float;
	/**
		is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)
		
		Calculates which of the given dates are valid days, and which are not.
		
		.. versionadded:: 1.7.0
		
		Parameters
		----------
		dates : array_like of datetime64[D]
		    The array of dates to process.
		weekmask : str or array_like of bool, optional
		    A seven-element array indicating which of Monday through Sunday are
		    valid days. May be specified as a length-seven list or array, like
		    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
		    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
		    weekdays, optionally separated by white space. Valid abbreviations
		    are: Mon Tue Wed Thu Fri Sat Sun
		holidays : array_like of datetime64[D], optional
		    An array of dates to consider as invalid dates.  They may be
		    specified in any order, and NaT (not-a-time) dates are ignored.
		    This list is saved in a normalized form that is suited for
		    fast calculations of valid days.
		busdaycal : busdaycalendar, optional
		    A `busdaycalendar` object which specifies the valid days. If this
		    parameter is provided, neither weekmask nor holidays may be
		    provided.
		out : array of bool, optional
		    If provided, this array is filled with the result.
		
		Returns
		-------
		out : array of bool
		    An array with the same shape as ``dates``, containing True for
		    each valid day, and False for each invalid day.
		
		See Also
		--------
		busdaycalendar: An object that specifies a custom set of valid days.
		busday_offset : Applies an offset counted in valid days.
		busday_count : Counts how many valid days are in a half-open date range.
		
		Examples
		--------
		>>> # The weekdays are Friday, Saturday, and Monday
		... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
		...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
		array([False, False,  True], dtype='bool')
	**/
	static public function is_busday(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Returns a boolean array where two arrays are element-wise equal within a
		tolerance.
		
		The tolerance values are positive, typically very small numbers.  The
		relative difference (`rtol` * abs(`b`)) and the absolute difference
		`atol` are added together to compare against the absolute difference
		between `a` and `b`.
		
		.. warning:: The default `atol` is not appropriate for comparing numbers
		             that are much smaller than one (see Notes).
		
		Parameters
		----------
		a, b : array_like
		    Input arrays to compare.
		rtol : float
		    The relative tolerance parameter (see Notes).
		atol : float
		    The absolute tolerance parameter (see Notes).
		equal_nan : bool
		    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
		    considered equal to NaN's in `b` in the output array.
		
		Returns
		-------
		y : array_like
		    Returns a boolean array of where `a` and `b` are equal within the
		    given tolerance. If both `a` and `b` are scalars, returns a single
		    boolean value.
		
		See Also
		--------
		allclose
		
		Notes
		-----
		.. versionadded:: 1.7.0
		
		For finite values, isclose uses the following equation to test whether
		two floating point values are equivalent.
		
		 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
		
		Unlike the built-in `math.isclose`, the above equation is not symmetric
		in `a` and `b` -- it assumes `b` is the reference value -- so that
		`isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
		the default value of atol is not zero, and is used to determine what
		small values should be considered close to zero. The default value is
		appropriate for expected values of order unity: if the expected values
		are significantly smaller than one, it can result in false positives.
		`atol` should be carefully selected for the use case at hand. A zero value
		for `atol` will result in `False` if either `a` or `b` is zero.
		
		Examples
		--------
		>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
		array([True, False])
		>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
		array([True, True])
		>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
		array([False, True])
		>>> np.isclose([1.0, np.nan], [1.0, np.nan])
		array([True, False])
		>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
		array([True, True])
		>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
		array([ True, False], dtype=bool)
		>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
		array([False, False], dtype=bool)
		>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
		array([ True,  True], dtype=bool)
		>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
		array([False,  True], dtype=bool)
	**/
	static public function isclose(a:Dynamic, b:Dynamic, ?rtol:Dynamic, ?atol:Dynamic, ?equal_nan:Dynamic):Dynamic;
	/**
		Returns a bool array, where True if input element is complex.
		
		What is tested is whether the input has a non-zero imaginary part, not if
		the input type is complex.
		
		Parameters
		----------
		x : array_like
		    Input array.
		
		Returns
		-------
		out : ndarray of bools
		    Output array.
		
		See Also
		--------
		isreal
		iscomplexobj : Return True if x is a complex type or an array of complex
		               numbers.
		
		Examples
		--------
		>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
		array([ True, False, False, False, False,  True])
	**/
	static public function iscomplex(x:Dynamic):Dynamic;
	/**
		Check for a complex type or an array of complex numbers.
		
		The type of the input is checked, not the value. Even if the input
		has an imaginary part equal to zero, `iscomplexobj` evaluates to True.
		
		Parameters
		----------
		x : any
		    The input can be of any type and shape.
		
		Returns
		-------
		iscomplexobj : bool
		    The return value, True if `x` is of a complex type or has at least
		    one complex element.
		
		See Also
		--------
		isrealobj, iscomplex
		
		Examples
		--------
		>>> np.iscomplexobj(1)
		False
		>>> np.iscomplexobj(1+0j)
		True
		>>> np.iscomplexobj([3, 1+0j, True])
		True
	**/
	static public function iscomplexobj(x:Dynamic):Bool;
	/**
		isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Test element-wise for finiteness (not infinity or not Not a Number).
		
		The result is returned as a boolean array.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray, bool
		    True where ``x`` is not positive infinity, negative infinity,
		    or NaN; false otherwise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		isinf, isneginf, isposinf, isnan
		
		Notes
		-----
		Not a Number, positive infinity and negative infinity are considered
		to be non-finite.
		
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754). This means that Not a Number is not equivalent to infinity.
		Also that positive infinity is not equivalent to negative infinity. But
		infinity is equivalent to positive infinity.  Errors result if the
		second argument is also supplied when `x` is a scalar input, or if
		first and second arguments have different shapes.
		
		Examples
		--------
		>>> np.isfinite(1)
		True
		>>> np.isfinite(0)
		True
		>>> np.isfinite(np.nan)
		False
		>>> np.isfinite(np.inf)
		False
		>>> np.isfinite(np.NINF)
		False
		>>> np.isfinite([np.log(-1.),1.,np.log(0)])
		array([False,  True, False])
		
		>>> x = np.array([-np.inf, 0., np.inf])
		>>> y = np.array([2, 2, 2])
		>>> np.isfinite(x, y)
		array([0, 1, 0])
		>>> y
		array([0, 1, 0])
	**/
	static public function isfinite(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Returns True if the array is Fortran contiguous but *not* C contiguous.
		
		This function is obsolete and, because of changes due to relaxed stride
		checking, its return value for the same array may differ for versions
		of NumPy >= 1.10.0 and previous versions. If you only want to check if an
		array is Fortran contiguous use ``a.flags.f_contiguous`` instead.
		
		Parameters
		----------
		a : ndarray
		    Input array.
		
		
		Examples
		--------
		
		np.array allows to specify whether the array is written in C-contiguous
		order (last index varies the fastest), or FORTRAN-contiguous order in
		memory (first index varies the fastest).
		
		>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
		>>> a
		array([[1, 2, 3],
		       [4, 5, 6]])
		>>> np.isfortran(a)
		False
		
		>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')
		>>> b
		array([[1, 2, 3],
		       [4, 5, 6]])
		>>> np.isfortran(b)
		True
		
		
		The transpose of a C-ordered array is a FORTRAN-ordered array.
		
		>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
		>>> a
		array([[1, 2, 3],
		       [4, 5, 6]])
		>>> np.isfortran(a)
		False
		>>> b = a.T
		>>> b
		array([[1, 4],
		       [2, 5],
		       [3, 6]])
		>>> np.isfortran(b)
		True
		
		C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.
		
		>>> np.isfortran(np.array([1, 2], order='FORTRAN'))
		False
	**/
	static public function isfortran(a:Dynamic):Dynamic;
	/**
		Calculates `element in test_elements`, broadcasting over `element` only.
		Returns a boolean array of the same shape as `element` that is True
		where an element of `element` is in `test_elements` and False otherwise.
		
		Parameters
		----------
		element : array_like
		    Input array.
		test_elements : array_like
		    The values against which to test each value of `element`.
		    This argument is flattened if it is an array or array_like.
		    See notes for behavior with non-array-like parameters.
		assume_unique : bool, optional
		    If True, the input arrays are both assumed to be unique, which
		    can speed up the calculation.  Default is False.
		invert : bool, optional
		    If True, the values in the returned array are inverted, as if
		    calculating `element not in test_elements`. Default is False.
		    ``np.isin(a, b, invert=True)`` is equivalent to (but faster
		    than) ``np.invert(np.isin(a, b))``.
		
		Returns
		-------
		isin : ndarray, bool
		    Has the same shape as `element`. The values `element[isin]`
		    are in `test_elements`.
		
		See Also
		--------
		in1d                  : Flattened version of this function.
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Notes
		-----
		
		`isin` is an element-wise function version of the python keyword `in`.
		``isin(a, b)`` is roughly equivalent to
		``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.
		
		`element` and `test_elements` are converted to arrays if they are not
		already. If `test_elements` is a set (or other non-sequence collection)
		it will be converted to an object array with one element, rather than an
		array of the values contained in `test_elements`. This is a consequence
		of the `array` constructor's way of handling non-sequence collections.
		Converting the set to a list usually gives the desired behavior.
		
		.. versionadded:: 1.13.0
		
		Examples
		--------
		>>> element = 2*np.arange(4).reshape((2, 2))
		>>> element
		array([[0, 2],
		       [4, 6]])
		>>> test_elements = [1, 2, 4, 8]
		>>> mask = np.isin(element, test_elements)
		>>> mask
		array([[ False,  True],
		       [ True,  False]])
		>>> element[mask]
		array([2, 4])
		
		The indices of the matched values can be obtained with `nonzero`:
		
		>>> np.nonzero(mask)
		(array([0, 1]), array([1, 0]))
		
		The test can also be inverted:
		
		>>> mask = np.isin(element, test_elements, invert=True)
		>>> mask
		array([[ True, False],
		       [ False, True]])
		>>> element[mask]
		array([0, 6])
		
		Because of how `array` handles sets, the following does not
		work as expected:
		
		>>> test_set = {1, 2, 4, 8}
		>>> np.isin(element, test_set)
		array([[ False, False],
		       [ False, False]])
		
		Casting the set to a list gives the expected result:
		
		>>> np.isin(element, list(test_set))
		array([[ False,  True],
		       [ True,  False]])
	**/
	static public function isin(element:Dynamic, test_elements:Dynamic, ?assume_unique:Dynamic, ?invert:Dynamic):Dynamic;
	/**
		isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Test element-wise for positive or negative infinity.
		
		Returns a boolean array of the same shape as `x`, True where ``x ==
		+/-inf``, otherwise False.
		
		Parameters
		----------
		x : array_like
		    Input values
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : bool (scalar) or boolean ndarray
		    True where ``x`` is positive or negative infinity, false otherwise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		isneginf, isposinf, isnan, isfinite
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754).
		
		Errors result if the second argument is supplied when the first
		argument is a scalar, or if the first and second arguments have
		different shapes.
		
		Examples
		--------
		>>> np.isinf(np.inf)
		True
		>>> np.isinf(np.nan)
		False
		>>> np.isinf(np.NINF)
		True
		>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])
		array([ True,  True, False, False])
		
		>>> x = np.array([-np.inf, 0., np.inf])
		>>> y = np.array([2, 2, 2])
		>>> np.isinf(x, y)
		array([1, 0, 1])
		>>> y
		array([1, 0, 1])
	**/
	static public function isinf(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the status of interactive mode.
	**/
	static public function isinteractive():Dynamic;
	/**
		isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Test element-wise for NaN and return result as a boolean array.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or bool
		    True where ``x`` is NaN, false otherwise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		isinf, isneginf, isposinf, isfinite, isnat
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754). This means that Not a Number is not equivalent to infinity.
		
		Examples
		--------
		>>> np.isnan(np.nan)
		True
		>>> np.isnan(np.inf)
		False
		>>> np.isnan([np.log(-1.),1.,np.log(0)])
		array([ True, False, False])
	**/
	static public function isnan(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Test element-wise for NaT (not a time) and return result as a boolean array.
		
		.. versionadded:: 1.13.0
		
		Parameters
		----------
		x : array_like
		    Input array with datetime or timedelta data type.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or bool
		    True where ``x`` is NaT, false otherwise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		isnan, isinf, isneginf, isposinf, isfinite
		
		Examples
		--------
		>>> np.isnat(np.datetime64("NaT"))
		True
		>>> np.isnat(np.datetime64("2016-01-01"))
		False
		>>> np.isnat(np.array(["NaT", "2016-01-01"], dtype="datetime64[ns]"))
		array([ True, False])
	**/
	static public function isnat(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Test element-wise for negative infinity, return result as bool array.
		
		Parameters
		----------
		x : array_like
		    The input array.
		out : array_like, optional
		    A boolean array with the same shape and type as `x` to store the
		    result.
		
		Returns
		-------
		out : ndarray
		    A boolean array with the same dimensions as the input.
		    If second argument is not supplied then a numpy boolean array is
		    returned with values True where the corresponding element of the
		    input is negative infinity and values False where the element of
		    the input is not negative infinity.
		
		    If a second argument is supplied the result is stored there. If the
		    type of that array is a numeric type the result is represented as
		    zeros and ones, if the type is boolean then as False and True. The
		    return value `out` is then a reference to that array.
		
		See Also
		--------
		isinf, isposinf, isnan, isfinite
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754).
		
		Errors result if the second argument is also supplied when x is a scalar
		input, if first and second arguments have different shapes, or if the
		first argument has complex values.
		
		Examples
		--------
		>>> np.isneginf(np.NINF)
		array(True, dtype=bool)
		>>> np.isneginf(np.inf)
		array(False, dtype=bool)
		>>> np.isneginf(np.PINF)
		array(False, dtype=bool)
		>>> np.isneginf([-np.inf, 0., np.inf])
		array([ True, False, False])
		
		>>> x = np.array([-np.inf, 0., np.inf])
		>>> y = np.array([2, 2, 2])
		>>> np.isneginf(x, y)
		array([1, 0, 0])
		>>> y
		array([1, 0, 0])
	**/
	static public function isneginf(x:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Test element-wise for positive infinity, return result as bool array.
		
		Parameters
		----------
		x : array_like
		    The input array.
		y : array_like, optional
		    A boolean array with the same shape as `x` to store the result.
		
		Returns
		-------
		out : ndarray
		    A boolean array with the same dimensions as the input.
		    If second argument is not supplied then a boolean array is returned
		    with values True where the corresponding element of the input is
		    positive infinity and values False where the element of the input is
		    not positive infinity.
		
		    If a second argument is supplied the result is stored there. If the
		    type of that array is a numeric type the result is represented as zeros
		    and ones, if the type is boolean then as False and True.
		    The return value `out` is then a reference to that array.
		
		See Also
		--------
		isinf, isneginf, isfinite, isnan
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754).
		
		Errors result if the second argument is also supplied when x is a scalar
		input, if first and second arguments have different shapes, or if the
		first argument has complex values
		
		Examples
		--------
		>>> np.isposinf(np.PINF)
		array(True, dtype=bool)
		>>> np.isposinf(np.inf)
		array(True, dtype=bool)
		>>> np.isposinf(np.NINF)
		array(False, dtype=bool)
		>>> np.isposinf([-np.inf, 0., np.inf])
		array([False, False,  True])
		
		>>> x = np.array([-np.inf, 0., np.inf])
		>>> y = np.array([2, 2, 2])
		>>> np.isposinf(x, y)
		array([0, 0, 1])
		>>> y
		array([0, 0, 1])
	**/
	static public function isposinf(x:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Returns a bool array, where True if input element is real.
		
		If element has complex type with zero complex part, the return value
		for that element is True.
		
		Parameters
		----------
		x : array_like
		    Input array.
		
		Returns
		-------
		out : ndarray, bool
		    Boolean array of same shape as `x`.
		
		See Also
		--------
		iscomplex
		isrealobj : Return True if x is not a complex type.
		
		Examples
		--------
		>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
		array([False,  True,  True,  True,  True, False])
	**/
	static public function isreal(x:Dynamic):Dynamic;
	/**
		Return True if x is a not complex type or an array of complex numbers.
		
		The type of the input is checked, not the value. So even if the input
		has an imaginary part equal to zero, `isrealobj` evaluates to False
		if the data type is complex.
		
		Parameters
		----------
		x : any
		    The input can be of any type and shape.
		
		Returns
		-------
		y : bool
		    The return value, False if `x` is of a complex type.
		
		See Also
		--------
		iscomplexobj, isreal
		
		Examples
		--------
		>>> np.isrealobj(1)
		True
		>>> np.isrealobj(1+0j)
		False
		>>> np.isrealobj([3, 1+0j, True])
		False
	**/
	static public function isrealobj(x:Dynamic):Bool;
	/**
		Returns True if the type of `num` is a scalar type.
		
		Parameters
		----------
		num : any
		    Input argument, can be of any type and shape.
		
		Returns
		-------
		val : bool
		    True if `num` is a scalar type, False if it is not.
		
		See Also
		--------
		ndim : Get the number of dimensions of an array
		
		Notes
		-----
		In almost all cases ``np.ndim(x) == 0`` should be used instead of this
		function, as that will also return true for 0d arrays. This is how
		numpy overloads functions in the style of the ``dx`` arguments to `gradient`
		and the ``bins`` argument to `histogram`. Some key differences:
		
		+--------------------------------------+---------------+-------------------+
		| x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
		+======================================+===============+===================+
		| PEP 3141 numeric objects (including  | ``True``      | ``True``          |
		| builtins)                            |               |                   |
		+--------------------------------------+---------------+-------------------+
		| builtin string and buffer objects    | ``True``      | ``True``          |
		+--------------------------------------+---------------+-------------------+
		| other builtin objects, like          | ``False``     | ``True``          |
		| `pathlib.Path`, `Exception`,         |               |                   |
		| the result of `re.compile`           |               |                   |
		+--------------------------------------+---------------+-------------------+
		| third-party objects like             | ``False``     | ``True``          |
		| `matplotlib.figure.Figure`           |               |                   |
		+--------------------------------------+---------------+-------------------+
		| zero-dimensional numpy arrays        | ``False``     | ``True``          |
		+--------------------------------------+---------------+-------------------+
		| other numpy arrays                   | ``False``     | ``False``         |
		+--------------------------------------+---------------+-------------------+
		| `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
		| objects                              |               |                   |
		+--------------------------------------+---------------+-------------------+
		
		Examples
		--------
		>>> np.isscalar(3.1)
		True
		>>> np.isscalar(np.array(3.1))
		False
		>>> np.isscalar([3.1])
		False
		>>> np.isscalar(False)
		True
		>>> np.isscalar('numpy')
		True
		
		NumPy supports PEP 3141 numbers:
		
		>>> from fractions import Fraction
		>>> isscalar(Fraction(5, 17))
		True
		>>> from numbers import Number
		>>> isscalar(Number())
		True
	**/
	static public function isscalar(num:Dynamic):Bool;
	/**
		Determines whether the given object represents a scalar data-type.
		
		Parameters
		----------
		rep : any
		    If `rep` is an instance of a scalar dtype, True is returned. If not,
		    False is returned.
		
		Returns
		-------
		out : bool
		    Boolean result of check whether `rep` is a scalar dtype.
		
		See Also
		--------
		issubsctype, issubdtype, obj2sctype, sctype2char
		
		Examples
		--------
		>>> np.issctype(np.int32)
		True
		>>> np.issctype(list)
		False
		>>> np.issctype(1.1)
		False
		
		Strings are also a scalar type:
		
		>>> np.issctype(np.dtype('str'))
		True
	**/
	static public function issctype(rep:Dynamic):Bool;
	/**
		Determine if a class is a subclass of a second class.
		
		`issubclass_` is equivalent to the Python built-in ``issubclass``,
		except that it returns False instead of raising a TypeError if one
		of the arguments is not a class.
		
		Parameters
		----------
		arg1 : class
		    Input class. True is returned if `arg1` is a subclass of `arg2`.
		arg2 : class or tuple of classes.
		    Input class. If a tuple of classes, True is returned if `arg1` is a
		    subclass of any of the tuple elements.
		
		Returns
		-------
		out : bool
		    Whether `arg1` is a subclass of `arg2` or not.
		
		See Also
		--------
		issubsctype, issubdtype, issctype
		
		Examples
		--------
		>>> np.issubclass_(np.int32, int)
		True
		>>> np.issubclass_(np.int32, float)
		False
	**/
	static public function issubclass_(arg1:Dynamic, arg2:Dynamic):Bool;
	/**
		Returns True if first argument is a typecode lower/equal in type hierarchy.
		
		Parameters
		----------
		arg1, arg2 : dtype_like
		    dtype or string representing a typecode.
		
		Returns
		-------
		out : bool
		
		See Also
		--------
		issubsctype, issubclass_
		numpy.core.numerictypes : Overview of numpy type hierarchy.
		
		Examples
		--------
		>>> np.issubdtype('S1', np.string_)
		True
		>>> np.issubdtype(np.float64, np.float32)
		False
	**/
	static public function issubdtype(arg1:Dynamic, arg2:Dynamic):Bool;
	/**
		Determine if the first argument is a subclass of the second argument.
		
		Parameters
		----------
		arg1, arg2 : dtype or dtype specifier
		    Data-types.
		
		Returns
		-------
		out : bool
		    The result.
		
		See Also
		--------
		issctype, issubdtype,obj2sctype
		
		Examples
		--------
		>>> np.issubsctype('S8', str)
		True
		>>> np.issubsctype(np.array([1]), int)
		True
		>>> np.issubsctype(np.array([1]), float)
		False
	**/
	static public function issubsctype(arg1:Dynamic, arg2:Dynamic):Bool;
	/**
		Check whether or not an object can be iterated over.
		
		Parameters
		----------
		y : object
		  Input object.
		
		Returns
		-------
		b : bool
		  Return ``True`` if the object has an iterator method or is a
		  sequence and ``False`` otherwise.
		
		
		Examples
		--------
		>>> np.iterable([1, 2, 3])
		True
		>>> np.iterable(2)
		False
	**/
	static public function iterable(y:Dynamic):Bool;
	/**
		Construct an open mesh from multiple sequences.
		
		This function takes N 1-D sequences and returns N outputs with N
		dimensions each, such that the shape is 1 in all but one dimension
		and the dimension with the non-unit shape value cycles through all
		N dimensions.
		
		Using `ix_` one can quickly construct index arrays that will index
		the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array
		``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.
		
		Parameters
		----------
		args : 1-D sequences
		    Each sequence should be of integer or boolean type.
		    Boolean sequences will be interpreted as boolean masks for the
		    corresponding dimension (equivalent to passing in
		    ``np.nonzero(boolean_sequence)``).
		
		Returns
		-------
		out : tuple of ndarrays
		    N arrays with N dimensions each, with N the number of input
		    sequences. Together these arrays form an open mesh.
		
		See Also
		--------
		ogrid, mgrid, meshgrid
		
		Examples
		--------
		>>> a = np.arange(10).reshape(2, 5)
		>>> a
		array([[0, 1, 2, 3, 4],
		       [5, 6, 7, 8, 9]])
		>>> ixgrid = np.ix_([0, 1], [2, 4])
		>>> ixgrid
		(array([[0],
		       [1]]), array([[2, 4]]))
		>>> ixgrid[0].shape, ixgrid[1].shape
		((2, 1), (1, 2))
		>>> a[ixgrid]
		array([[2, 4],
		       [7, 9]])
		
		>>> ixgrid = np.ix_([True, True], [2, 4])
		>>> a[ixgrid]
		array([[2, 4],
		       [7, 9]])
		>>> ixgrid = np.ix_([True, True], [False, False, True, False, True])
		>>> a[ixgrid]
		array([[2, 4],
		       [7, 9]])
	**/
	static public function ix_(?args:python.VarArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "jet".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function jet():Dynamic;
	/**
		Return the Kaiser window.
		
		The Kaiser window is a taper formed by using a Bessel function.
		
		Parameters
		----------
		M : int
		    Number of points in the output window. If zero or less, an
		    empty array is returned.
		beta : float
		    Shape parameter for window.
		
		Returns
		-------
		out : array
		    The window, with the maximum value normalized to one (the value
		    one appears only if the number of samples is odd).
		
		See Also
		--------
		bartlett, blackman, hamming, hanning
		
		Notes
		-----
		The Kaiser window is defined as
		
		.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
		           \right)/I_0(\beta)
		
		with
		
		.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},
		
		where :math:`I_0` is the modified zeroth-order Bessel function.
		
		The Kaiser was named for Jim Kaiser, who discovered a simple
		approximation to the DPSS window based on Bessel functions.  The Kaiser
		window is a very good approximation to the Digital Prolate Spheroidal
		Sequence, or Slepian window, which is the transform which maximizes the
		energy in the main lobe of the window relative to total energy.
		
		The Kaiser can approximate many other windows by varying the beta
		parameter.
		
		====  =======================
		beta  Window shape
		====  =======================
		0     Rectangular
		5     Similar to a Hamming
		6     Similar to a Hanning
		8.6   Similar to a Blackman
		====  =======================
		
		A beta value of 14 is probably a good starting point. Note that as beta
		gets large, the window narrows, and so the number of samples needs to be
		large enough to sample the increasingly narrow spike, otherwise NaNs will
		get returned.
		
		Most references to the Kaiser window come from the signal processing
		literature, where it is used as one of many windowing functions for
		smoothing values.  It is also known as an apodization (which means
		"removing the foot", i.e. smoothing discontinuities at the beginning
		and end of the sampled signal) or tapering function.
		
		References
		----------
		.. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
		       digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
		       John Wiley and Sons, New York, (1966).
		.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
		       University of Alberta Press, 1975, pp. 177-178.
		.. [3] Wikipedia, "Window function",
		       https://en.wikipedia.org/wiki/Window_function
		
		Examples
		--------
		>>> import matplotlib.pyplot as plt
		>>> np.kaiser(12, 14)
		array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,
		         2.29737120e-01,   5.99885316e-01,   9.45674898e-01,
		         9.45674898e-01,   5.99885316e-01,   2.29737120e-01,
		         4.65200189e-02,   3.46009194e-03,   7.72686684e-06])
		
		
		Plot the window and the frequency response:
		
		>>> from numpy.fft import fft, fftshift
		>>> window = np.kaiser(51, 14)
		>>> plt.plot(window)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Kaiser window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Sample")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		>>> plt.figure()
		<matplotlib.figure.Figure object at 0x...>
		>>> A = fft(window, 2048) / 25.5
		>>> mag = np.abs(fftshift(A))
		>>> freq = np.linspace(-0.5, 0.5, len(A))
		>>> response = 20 * np.log10(mag)
		>>> response = np.clip(response, -100, 100)
		>>> plt.plot(freq, response)
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Frequency response of Kaiser window")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Magnitude [dB]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("Normalized frequency [cycles per sample]")
		<matplotlib.text.Text object at 0x...>
		>>> plt.axis('tight')
		(-0.5, 0.5, -100.0, ...)
		>>> plt.show()
	**/
	static public function kaiser(M:Dynamic, beta:Dynamic):Array<Dynamic>;
	/**
		Kronecker product of two arrays.
		
		Computes the Kronecker product, a composite array made of blocks of the
		second array scaled by the first.
		
		Parameters
		----------
		a, b : array_like
		
		Returns
		-------
		out : ndarray
		
		See Also
		--------
		outer : The outer product
		
		Notes
		-----
		The function assumes that the number of dimensions of `a` and `b`
		are the same, if necessary prepending the smallest with ones.
		If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,
		the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.
		The elements are products of elements from `a` and `b`, organized
		explicitly by::
		
		    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]
		
		where::
		
		    kt = it * st + jt,  t = 0,...,N
		
		In the common 2-D case (N=1), the block structure can be visualized::
		
		    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
		     [  ...                              ...   ],
		     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]
		
		
		Examples
		--------
		>>> np.kron([1,10,100], [5,6,7])
		array([  5,   6,   7,  50,  60,  70, 500, 600, 700])
		>>> np.kron([5,6,7], [1,10,100])
		array([  5,  50, 500,   6,  60, 600,   7,  70, 700])
		
		>>> np.kron(np.eye(2), np.ones((2,2)))
		array([[ 1.,  1.,  0.,  0.],
		       [ 1.,  1.,  0.,  0.],
		       [ 0.,  0.,  1.,  1.],
		       [ 0.,  0.,  1.,  1.]])
		
		>>> a = np.arange(100).reshape((2,5,2,5))
		>>> b = np.arange(24).reshape((2,3,4))
		>>> c = np.kron(a,b)
		>>> c.shape
		(2, 10, 6, 20)
		>>> I = (1,3,0,2)
		>>> J = (0,2,1)
		>>> J1 = (0,) + J             # extend to ndim=4
		>>> S1 = (1,) + b.shape
		>>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
		>>> c[K] == a[I]*b[J]
		True
	**/
	static public function kron(a:Dynamic, b:Dynamic):Dynamic;
	/**
		laplace(loc=0.0, scale=1.0, size=None)
		
		Draw samples from the Laplace or double exponential distribution with
		specified location (or mean) and scale (decay).
		
		The Laplace distribution is similar to the Gaussian/normal distribution,
		but is sharper at the peak and has fatter tails. It represents the
		difference between two independent, identically distributed exponential
		random variables.
		
		Parameters
		----------
		loc : float or array_like of floats, optional
		    The position, :math:`\mu`, of the distribution peak. Default is 0.
		scale : float or array_like of floats, optional
		    :math:`\lambda`, the exponential decay. Default is 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``loc`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Laplace distribution.
		
		Notes
		-----
		It has the probability density function
		
		.. math:: f(x; \mu, \lambda) = \frac{1}{2\lambda}
		                               \exp\left(-\frac{|x - \mu|}{\lambda}\right).
		
		The first law of Laplace, from 1774, states that the frequency
		of an error can be expressed as an exponential function of the
		absolute magnitude of the error, which leads to the Laplace
		distribution. For many problems in economics and health
		sciences, this distribution seems to model the data better
		than the standard Gaussian distribution.
		
		References
		----------
		.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). "Handbook of
		       Mathematical Functions with Formulas, Graphs, and Mathematical
		       Tables, 9th printing," New York: Dover, 1972.
		.. [2] Kotz, Samuel, et. al. "The Laplace Distribution and
		       Generalizations, " Birkhauser, 2001.
		.. [3] Weisstein, Eric W. "Laplace Distribution."
		       From MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/LaplaceDistribution.html
		.. [4] Wikipedia, "Laplace distribution",
		       https://en.wikipedia.org/wiki/Laplace_distribution
		
		Examples
		--------
		Draw samples from the distribution
		
		>>> loc, scale = 0., 1.
		>>> s = np.random.laplace(loc, scale, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 30, density=True)
		>>> x = np.arange(-8., 8., .01)
		>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
		>>> plt.plot(x, pdf)
		
		Plot Gaussian for comparison:
		
		>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
		...      np.exp(-(x - loc)**2 / (2 * scale**2)))
		>>> plt.plot(x,g)
	**/
	static public function laplace(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns the lowest common multiple of ``|x1|`` and ``|x2|``
		
		Parameters
		----------
		x1, x2 : array_like, int
		    Arrays of values
		
		Returns
		-------
		y : ndarray or scalar
		    The lowest common multiple of the absolute value of the inputs
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		gcd : The greatest common divisor
		
		Examples
		--------
		>>> np.lcm(12, 20)
		60
		>>> np.lcm.reduce([3, 12, 20])
		60
		>>> np.lcm.reduce([40, 12, 20])
		120
		>>> np.lcm(np.arange(6), 20)
		array([ 0, 20, 20, 60, 20, 20])
	**/
	static public function lcm(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns x1 * 2**x2, element-wise.
		
		The mantissas `x1` and twos exponents `x2` are used to construct
		floating point numbers ``x1 * 2**x2``.
		
		Parameters
		----------
		x1 : array_like
		    Array of multipliers.
		x2 : array_like, int
		    Array of twos exponents.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The result of ``x1 * 2**x2``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		frexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.
		
		Notes
		-----
		Complex dtypes are not supported, they will raise a TypeError.
		
		`ldexp` is useful as the inverse of `frexp`, if used by itself it is
		more clear to simply use the expression ``x1 * 2**x2``.
		
		Examples
		--------
		>>> np.ldexp(5, np.arange(4))
		array([  5.,  10.,  20.,  40.], dtype=float32)
		
		>>> x = np.arange(6)
		>>> np.ldexp(*np.frexp(x))
		array([ 0.,  1.,  2.,  3.,  4.,  5.])
	**/
	static public function ldexp(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Shift the bits of an integer to the left.
		
		Bits are shifted to the left by appending `x2` 0s at the right of `x1`.
		Since the internal representation of numbers is in binary format, this
		operation is equivalent to multiplying `x1` by ``2**x2``.
		
		Parameters
		----------
		x1 : array_like of integer type
		    Input values.
		x2 : array_like of integer type
		    Number of zeros to append to `x1`. Has to be non-negative.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : array of integer type
		    Return `x1` with bits shifted `x2` times to the left.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		right_shift : Shift the bits of an integer to the right.
		binary_repr : Return the binary representation of the input number
		    as a string.
		
		Examples
		--------
		>>> np.binary_repr(5)
		'101'
		>>> np.left_shift(5, 2)
		20
		>>> np.binary_repr(20)
		'10100'
		
		>>> np.left_shift(5, [1,2,3])
		array([10, 20, 40])
	**/
	static public function left_shift(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Place a legend on the axes.
		
		Call signatures::
		
		    legend()
		    legend(labels)
		    legend(handles, labels)
		
		The call signatures correspond to three different ways how to use
		this method.
		
		**1. Automatic detection of elements to be shown in the legend**
		
		The elements to be added to the legend are automatically determined,
		when you do not pass in any extra arguments.
		
		In this case, the labels are taken from the artist. You can specify
		them either at artist creation or by calling the
		:meth:`~.Artist.set_label` method on the artist::
		
		    line, = ax.plot([1, 2, 3], label='Inline label')
		    ax.legend()
		
		or::
		
		    line.set_label('Label via method')
		    line, = ax.plot([1, 2, 3])
		    ax.legend()
		
		Specific lines can be excluded from the automatic legend element
		selection by defining a label starting with an underscore.
		This is default for all artists, so calling `Axes.legend` without
		any arguments and without setting the labels manually will result in
		no legend being drawn.
		
		
		**2. Labeling existing plot elements**
		
		To make a legend for lines which already exist on the axes
		(via plot for instance), simply call this function with an iterable
		of strings, one for each legend item. For example::
		
		    ax.plot([1, 2, 3])
		    ax.legend(['A simple line'])
		
		Note: This way of using is discouraged, because the relation between
		plot elements and labels is only implicit by their order and can
		easily be mixed up.
		
		
		**3. Explicitly defining the elements in the legend**
		
		For full control of which artists have a legend entry, it is possible
		to pass an iterable of legend artists followed by an iterable of
		legend labels respectively::
		
		    legend((line1, line2, line3), ('label1', 'label2', 'label3'))
		
		Parameters
		----------
		
		handles : sequence of `.Artist`, optional
		    A list of Artists (lines, patches) to be added to the legend.
		    Use this together with *labels*, if you need full control on what
		    is shown in the legend and the automatic mechanism described above
		    is not sufficient.
		
		    The length of handles and labels should be the same in this
		    case. If they are not, they are truncated to the smaller length.
		
		labels : sequence of strings, optional
		    A list of labels to show next to the artists.
		    Use this together with *handles*, if you need full control on what
		    is shown in the legend and the automatic mechanism described above
		    is not sufficient.
		
		Other Parameters
		----------------
		
		
		loc : str or pair of floats, default: :rc:`legend.loc` ('best' for axes, 'upper right' for figures)
		    The location of the legend.
		
		    The strings
		    ``'upper left', 'upper right', 'lower left', 'lower right'``
		    place the legend at the corresponding corner of the axes/figure.
		
		    The strings
		    ``'upper center', 'lower center', 'center left', 'center right'``
		    place the legend at the center of the corresponding edge of the
		    axes/figure.
		
		    The string ``'center'`` places the legend at the center of the axes/figure.
		
		    The string ``'best'`` places the legend at the location, among the nine
		    locations defined so far, with the minimum overlap with other drawn
		    artists.  This option can be quite slow for plots with large amounts of
		    data; your plotting speed may benefit from providing a specific location.
		
		    The location can also be a 2-tuple giving the coordinates of the lower-left
		    corner of the legend in axes coordinates (in which case *bbox_to_anchor*
		    will be ignored).
		
		    For back-compatibility, ``'center right'`` (but no other location) can also
		    be spelled ``'right'``, and each "string" locations can also be given as a
		    numeric value:
		
		        ===============   =============
		        Location String   Location Code
		        ===============   =============
		        'best'            0
		        'upper right'     1
		        'upper left'      2
		        'lower left'      3
		        'lower right'     4
		        'right'           5
		        'center left'     6
		        'center right'    7
		        'lower center'    8
		        'upper center'    9
		        'center'          10
		        ===============   =============
		
		bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats
		    Box that is used to position the legend in conjunction with *loc*.
		    Defaults to `axes.bbox` (if called as a method to `.Axes.legend`) or
		    `figure.bbox` (if `.Figure.legend`).  This argument allows arbitrary
		    placement of the legend.
		
		    Bbox coordinates are interpreted in the coordinate system given by
		    `bbox_transform`, with the default transform
		    Axes or Figure coordinates, depending on which ``legend`` is called.
		
		    If a 4-tuple or `.BboxBase` is given, then it specifies the bbox
		    ``(x, y, width, height)`` that the legend is placed in.
		    To put the legend in the best location in the bottom right
		    quadrant of the axes (or figure)::
		
		        loc='best', bbox_to_anchor=(0.5, 0., 0.5, 0.5)
		
		    A 2-tuple ``(x, y)`` places the corner of the legend specified by *loc* at
		    x, y.  For example, to put the legend's upper right-hand corner in the
		    center of the axes (or figure) the following keywords can be used::
		
		        loc='upper right', bbox_to_anchor=(0.5, 0.5)
		
		ncol : integer
		    The number of columns that the legend has. Default is 1.
		
		prop : None or :class:`matplotlib.font_manager.FontProperties` or dict
		    The font properties of the legend. If None (default), the current
		    :data:`matplotlib.rcParams` will be used.
		
		fontsize : int or float or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}
		    Controls the font size of the legend. If the value is numeric the
		    size will be the absolute font size in points. String values are
		    relative to the current default font size. This argument is only
		    used if `prop` is not specified.
		
		numpoints : None or int
		    The number of marker points in the legend when creating a legend
		    entry for a `.Line2D` (line).
		    Default is ``None``, which will take the value from
		    :rc:`legend.numpoints`.
		
		scatterpoints : None or int
		    The number of marker points in the legend when creating
		    a legend entry for a `.PathCollection` (scatter plot).
		    Default is ``None``, which will take the value from
		    :rc:`legend.scatterpoints`.
		
		scatteryoffsets : iterable of floats
		    The vertical offset (relative to the font size) for the markers
		    created for a scatter plot legend entry. 0.0 is at the base the
		    legend text, and 1.0 is at the top. To draw all markers at the
		    same height, set to ``[0.5]``. Default is ``[0.375, 0.5, 0.3125]``.
		
		markerscale : None or int or float
		    The relative size of legend markers compared with the originally
		    drawn ones.
		    Default is ``None``, which will take the value from
		    :rc:`legend.markerscale`.
		
		markerfirst : bool
		    If *True*, legend marker is placed to the left of the legend label.
		    If *False*, legend marker is placed to the right of the legend
		    label.
		    Default is *True*.
		
		frameon : None or bool
		    Control whether the legend should be drawn on a patch
		    (frame).
		    Default is ``None``, which will take the value from
		    :rc:`legend.frameon`.
		
		fancybox : None or bool
		    Control whether round edges should be enabled around the
		    :class:`~matplotlib.patches.FancyBboxPatch` which makes up the
		    legend's background.
		    Default is ``None``, which will take the value from
		    :rc:`legend.fancybox`.
		
		shadow : None or bool
		    Control whether to draw a shadow behind the legend.
		    Default is ``None``, which will take the value from
		    :rc:`legend.shadow`.
		
		framealpha : None or float
		    Control the alpha transparency of the legend's background.
		    Default is ``None``, which will take the value from
		    :rc:`legend.framealpha`.  If shadow is activated and
		    *framealpha* is ``None``, the default value is ignored.
		
		facecolor : None or "inherit" or a color spec
		    Control the legend's background color.
		    Default is ``None``, which will take the value from
		    :rc:`legend.facecolor`.  If ``"inherit"``, it will take
		    :rc:`axes.facecolor`.
		
		edgecolor : None or "inherit" or a color spec
		    Control the legend's background patch edge color.
		    Default is ``None``, which will take the value from
		    :rc:`legend.edgecolor` If ``"inherit"``, it will take
		    :rc:`axes.edgecolor`.
		
		mode : {"expand", None}
		    If `mode` is set to ``"expand"`` the legend will be horizontally
		    expanded to fill the axes area (or `bbox_to_anchor` if defines
		    the legend's size).
		
		bbox_transform : None or :class:`matplotlib.transforms.Transform`
		    The transform for the bounding box (`bbox_to_anchor`). For a value
		    of ``None`` (default) the Axes'
		    :data:`~matplotlib.axes.Axes.transAxes` transform will be used.
		
		title : str or None
		    The legend's title. Default is no title (``None``).
		
		title_fontsize: str or None
		    The fontsize of the legend's title.  Default is the default fontsize.
		
		borderpad : float or None
		    The fractional whitespace inside the legend border.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.borderpad`.
		
		labelspacing : float or None
		    The vertical space between the legend entries.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.labelspacing`.
		
		handlelength : float or None
		    The length of the legend handles.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.handlelength`.
		
		handletextpad : float or None
		    The pad between the legend handle and text.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.handletextpad`.
		
		borderaxespad : float or None
		    The pad between the axes and legend border.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.borderaxespad`.
		
		columnspacing : float or None
		    The spacing between columns.
		    Measured in font-size units.
		    Default is ``None``, which will take the value from
		    :rc:`legend.columnspacing`.
		
		handler_map : dict or None
		    The custom dictionary mapping instances or types to a legend
		    handler. This `handler_map` updates the default handler map
		    found at :func:`matplotlib.legend.Legend.get_legend_handler_map`.
		
		
		
		Returns
		-------
		
		:class:`matplotlib.legend.Legend` instance
		
		Notes
		-----
		
		Not all kinds of artist are supported by the legend command. See
		:doc:`/tutorials/intermediate/legend_guide` for details.
		
		Examples
		--------
		
		.. plot:: gallery/text_labels_and_annotations/legend.py
	**/
	static public function legend(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the truth value of (x1 < x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays.  If ``x1.shape != x2.shape``, they must be
		    broadcastable to a common shape (which may be the shape of one or
		    the other).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		greater, less_equal, greater_equal, equal, not_equal
		
		Examples
		--------
		>>> np.less([1, 2], [2, 2])
		array([ True, False])
	**/
	static public function less(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the truth value of (x1 =< x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays.  If ``x1.shape != x2.shape``, they must be
		    broadcastable to a common shape (which may be the shape of one or
		    the other).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		greater, less, greater_equal, equal, not_equal
		
		Examples
		--------
		>>> np.less_equal([4, 2, 1], [2, 2, 2])
		array([False,  True,  True])
	**/
	static public function less_equal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		lexsort(keys, axis=-1)
		
		Perform an indirect stable sort using a sequence of keys.
		
		Given multiple sorting keys, which can be interpreted as columns in a
		spreadsheet, lexsort returns an array of integer indices that describes
		the sort order by multiple columns. The last key in the sequence is used
		for the primary sort order, the second-to-last key for the secondary sort
		order, and so on. The keys argument must be a sequence of objects that
		can be converted to arrays of the same shape. If a 2D array is provided
		for the keys argument, it's rows are interpreted as the sorting keys and
		sorting is according to the last row, second last row etc.
		
		Parameters
		----------
		keys : (k, N) array or tuple containing k (N,)-shaped sequences
		    The `k` different "columns" to be sorted.  The last column (or row if
		    `keys` is a 2D array) is the primary sort key.
		axis : int, optional
		    Axis to be indirectly sorted.  By default, sort over the last axis.
		
		Returns
		-------
		indices : (N,) ndarray of ints
		    Array of indices that sort the keys along the specified axis.
		
		See Also
		--------
		argsort : Indirect sort.
		ndarray.sort : In-place sort.
		sort : Return a sorted copy of an array.
		
		Examples
		--------
		Sort names: first by surname, then by name.
		
		>>> surnames =    ('Hertz',    'Galilei', 'Hertz')
		>>> first_names = ('Heinrich', 'Galileo', 'Gustav')
		>>> ind = np.lexsort((first_names, surnames))
		>>> ind
		array([1, 2, 0])
		
		>>> [surnames[i] + ", " + first_names[i] for i in ind]
		['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']
		
		Sort two columns of numbers:
		
		>>> a = [1,5,1,4,3,4,4] # First column
		>>> b = [9,4,0,4,0,2,1] # Second column
		>>> ind = np.lexsort((b,a)) # Sort by a, then by b
		>>> print(ind)
		[2 0 4 6 5 3 1]
		
		>>> [(a[i],b[i]) for i in ind]
		[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]
		
		Note that sorting is first according to the elements of ``a``.
		Secondary sorting is according to the elements of ``b``.
		
		A normal ``argsort`` would have yielded:
		
		>>> [(a[i],b[i]) for i in np.argsort(a)]
		[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]
		
		Structured arrays are sorted lexically by ``argsort``:
		
		>>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
		...              dtype=np.dtype([('x', int), ('y', int)]))
		
		>>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))
		array([2, 0, 4, 6, 5, 3, 1])
	**/
	static public function lexsort(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return evenly spaced numbers over a specified interval.
		
		Returns `num` evenly spaced samples, calculated over the
		interval [`start`, `stop`].
		
		The endpoint of the interval can optionally be excluded.
		
		.. versionchanged:: 1.16.0
		    Non-scalar `start` and `stop` are now supported.
		
		Parameters
		----------
		start : array_like
		    The starting value of the sequence.
		stop : array_like
		    The end value of the sequence, unless `endpoint` is set to False.
		    In that case, the sequence consists of all but the last of ``num + 1``
		    evenly spaced samples, so that `stop` is excluded.  Note that the step
		    size changes when `endpoint` is False.
		num : int, optional
		    Number of samples to generate. Default is 50. Must be non-negative.
		endpoint : bool, optional
		    If True, `stop` is the last sample. Otherwise, it is not included.
		    Default is True.
		retstep : bool, optional
		    If True, return (`samples`, `step`), where `step` is the spacing
		    between samples.
		dtype : dtype, optional
		    The type of the output array.  If `dtype` is not given, infer the data
		    type from the other input arguments.
		
		    .. versionadded:: 1.9.0
		
		axis : int, optional
		    The axis in the result to store the samples.  Relevant only if start
		    or stop are array-like.  By default (0), the samples will be along a
		    new axis inserted at the beginning. Use -1 to get an axis at the end.
		
		    .. versionadded:: 1.16.0
		
		Returns
		-------
		samples : ndarray
		    There are `num` equally spaced samples in the closed interval
		    ``[start, stop]`` or the half-open interval ``[start, stop)``
		    (depending on whether `endpoint` is True or False).
		step : float, optional
		    Only returned if `retstep` is True
		
		    Size of spacing between samples.
		
		
		See Also
		--------
		arange : Similar to `linspace`, but uses a step size (instead of the
		         number of samples).
		geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
		            scale (a geometric progression).
		logspace : Similar to `geomspace`, but with the end points specified as
		           logarithms.
		
		Examples
		--------
		>>> np.linspace(2.0, 3.0, num=5)
		array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])
		>>> np.linspace(2.0, 3.0, num=5, endpoint=False)
		array([ 2. ,  2.2,  2.4,  2.6,  2.8])
		>>> np.linspace(2.0, 3.0, num=5, retstep=True)
		(array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
		
		Graphical illustration:
		
		>>> import matplotlib.pyplot as plt
		>>> N = 8
		>>> y = np.zeros(N)
		>>> x1 = np.linspace(0, 10, N, endpoint=True)
		>>> x2 = np.linspace(0, 10, N, endpoint=False)
		>>> plt.plot(x1, y, 'o')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.plot(x2, y + 0.5, 'o')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.ylim([-0.5, 1])
		(-0.5, 1)
		>>> plt.show()
	**/
	static public function linspace(start:Dynamic, stop:Dynamic, ?num:Dynamic, ?endpoint:Dynamic, ?retstep:Dynamic, ?dtype:Dynamic, ?axis:Dynamic):Dynamic;
	static public var little_endian : Dynamic;
	/**
		Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.
		
		Parameters
		----------
		file : file-like object, string, or pathlib.Path
		    The file to read. File-like objects must support the
		    ``seek()`` and ``read()`` methods. Pickled files require that the
		    file-like object support the ``readline()`` method as well.
		mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional
		    If not None, then memory-map the file, using the given mode (see
		    `numpy.memmap` for a detailed description of the modes).  A
		    memory-mapped array is kept on disk. However, it can be accessed
		    and sliced like any ndarray.  Memory mapping is especially useful
		    for accessing small fragments of large files without reading the
		    entire file into memory.
		allow_pickle : bool, optional
		    Allow loading pickled object arrays stored in npy files. Reasons for
		    disallowing pickles include security, as loading pickled data can
		    execute arbitrary code. If pickles are disallowed, loading object
		    arrays will fail. Default: False
		
		    .. versionchanged:: 1.16.3
		        Made default False in response to CVE-2019-6446.
		
		fix_imports : bool, optional
		    Only useful when loading Python 2 generated pickled files on Python 3,
		    which includes npy/npz files containing object arrays. If `fix_imports`
		    is True, pickle will try to map the old Python 2 names to the new names
		    used in Python 3.
		encoding : str, optional
		    What encoding to use when reading Python 2 strings. Only useful when
		    loading Python 2 generated pickled files in Python 3, which includes
		    npy/npz files containing object arrays. Values other than 'latin1',
		    'ASCII', and 'bytes' are not allowed, as they can corrupt numerical
		    data. Default: 'ASCII'
		
		Returns
		-------
		result : array, tuple, dict, etc.
		    Data stored in the file. For ``.npz`` files, the returned instance
		    of NpzFile class must be closed to avoid leaking file descriptors.
		
		Raises
		------
		IOError
		    If the input file does not exist or cannot be read.
		ValueError
		    The file contains an object array, but allow_pickle=False given.
		
		See Also
		--------
		save, savez, savez_compressed, loadtxt
		memmap : Create a memory-map to an array stored in a file on disk.
		lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.
		
		Notes
		-----
		- If the file contains pickle data, then whatever object is stored
		  in the pickle is returned.
		- If the file is a ``.npy`` file, then a single array is returned.
		- If the file is a ``.npz`` file, then a dictionary-like object is
		  returned, containing ``{filename: array}`` key-value pairs, one for
		  each file in the archive.
		- If the file is a ``.npz`` file, the returned value supports the
		  context manager protocol in a similar fashion to the open function::
		
		    with load('foo.npz') as data:
		        a = data['a']
		
		  The underlying file descriptor is closed when exiting the 'with'
		  block.
		
		Examples
		--------
		Store data to disk, and load it again:
		
		>>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
		>>> np.load('/tmp/123.npy')
		array([[1, 2, 3],
		       [4, 5, 6]])
		
		Store compressed data to disk, and load it again:
		
		>>> a=np.array([[1, 2, 3], [4, 5, 6]])
		>>> b=np.array([1, 2])
		>>> np.savez('/tmp/123.npz', a=a, b=b)
		>>> data = np.load('/tmp/123.npz')
		>>> data['a']
		array([[1, 2, 3],
		       [4, 5, 6]])
		>>> data['b']
		array([1, 2])
		>>> data.close()
		
		Mem-map the stored array, and then access the second row
		directly from disk:
		
		>>> X = np.load('/tmp/123.npy', mmap_mode='r')
		>>> X[1, :]
		memmap([4, 5, 6])
	**/
	static public function load(file:Dynamic, ?mmap_mode:Dynamic, ?allow_pickle:Dynamic, ?fix_imports:Dynamic, ?encoding:Dynamic):Dynamic;
	static public function loads(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Load data from a text file.
		
		Each row in the text file must have the same number of values.
		
		Parameters
		----------
		fname : file, str, or pathlib.Path
		    File, filename, or generator to read.  If the filename extension is
		    ``.gz`` or ``.bz2``, the file is first decompressed. Note that
		    generators should return byte strings for Python 3k.
		dtype : data-type, optional
		    Data-type of the resulting array; default: float.  If this is a
		    structured data-type, the resulting array will be 1-dimensional, and
		    each row will be interpreted as an element of the array.  In this
		    case, the number of columns used must match the number of fields in
		    the data-type.
		comments : str or sequence of str, optional
		    The characters or list of characters used to indicate the start of a
		    comment. None implies no comments. For backwards compatibility, byte
		    strings will be decoded as 'latin1'. The default is '#'.
		delimiter : str, optional
		    The string used to separate values. For backwards compatibility, byte
		    strings will be decoded as 'latin1'. The default is whitespace.
		converters : dict, optional
		    A dictionary mapping column number to a function that will parse the
		    column string into the desired value.  E.g., if column 0 is a date
		    string: ``converters = {0: datestr2num}``.  Converters can also be
		    used to provide a default value for missing data (but see also
		    `genfromtxt`): ``converters = {3: lambda s: float(s.strip() or 0)}``.
		    Default: None.
		skiprows : int, optional
		    Skip the first `skiprows` lines; default: 0.
		usecols : int or sequence, optional
		    Which columns to read, with 0 being the first. For example,
		    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
		    The default, None, results in all columns being read.
		
		    .. versionchanged:: 1.11.0
		        When a single column has to be read it is possible to use
		        an integer instead of a tuple. E.g ``usecols = 3`` reads the
		        fourth column the same way as ``usecols = (3,)`` would.
		unpack : bool, optional
		    If True, the returned array is transposed, so that arguments may be
		    unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured
		    data-type, arrays are returned for each field.  Default is False.
		ndmin : int, optional
		    The returned array will have at least `ndmin` dimensions.
		    Otherwise mono-dimensional axes will be squeezed.
		    Legal values: 0 (default), 1 or 2.
		
		    .. versionadded:: 1.6.0
		encoding : str, optional
		    Encoding used to decode the inputfile. Does not apply to input streams.
		    The special value 'bytes' enables backward compatibility workarounds
		    that ensures you receive byte arrays as results if possible and passes
		    'latin1' encoded strings to converters. Override this value to receive
		    unicode arrays and pass strings as input to converters.  If set to None
		    the system default is used. The default value is 'bytes'.
		
		    .. versionadded:: 1.14.0
		max_rows : int, optional
		    Read `max_rows` lines of content after `skiprows` lines. The default
		    is to read all the lines.
		
		    .. versionadded:: 1.16.0
		
		Returns
		-------
		out : ndarray
		    Data read from the text file.
		
		See Also
		--------
		load, fromstring, fromregex
		genfromtxt : Load data with missing values handled as specified.
		scipy.io.loadmat : reads MATLAB data files
		
		Notes
		-----
		This function aims to be a fast reader for simply formatted files.  The
		`genfromtxt` function provides more sophisticated handling of, e.g.,
		lines with missing values.
		
		.. versionadded:: 1.10.0
		
		The strings produced by the Python float.hex method can be used as
		input for floats.
		
		Examples
		--------
		>>> from io import StringIO   # StringIO behaves like a file object
		>>> c = StringIO(u"0 1\n2 3")
		>>> np.loadtxt(c)
		array([[ 0.,  1.],
		       [ 2.,  3.]])
		
		>>> d = StringIO(u"M 21 72\nF 35 58")
		>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
		...                      'formats': ('S1', 'i4', 'f4')})
		array([('M', 21, 72.0), ('F', 35, 58.0)],
		      dtype=[('gender', '|S1'), ('age', '<i4'), ('weight', '<f4')])
		
		>>> c = StringIO(u"1,0,2\n3,0,4")
		>>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
		>>> x
		array([ 1.,  3.])
		>>> y
		array([ 2.,  4.])
	**/
	static public function loadtxt(fname:Dynamic, ?dtype:Dynamic, ?comments:Dynamic, ?delimiter:Dynamic, ?converters:Dynamic, ?skiprows:Dynamic, ?usecols:Dynamic, ?unpack:Dynamic, ?ndmin:Dynamic, ?encoding:Dynamic, ?max_rows:Dynamic):Dynamic;
	/**
		Control behavior of major tick locators.
		
		Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
		is called automatically after the parameters are changed.
		
		Parameters
		----------
		axis : {'both', 'x', 'y'}, optional
		    The axis on which to operate.
		
		tight : bool or None, optional
		    Parameter passed to `~.Axes.autoscale_view`.
		    Default is None, for no change.
		
		Other Parameters
		----------------
		**kwargs
		    Remaining keyword arguments are passed to directly to the
		    ``set_params()`` method of the locator. Supported keywords depend
		    on the type of the locator. See for example
		    `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
		    used by default for linear axes.
		
		Examples
		--------
		When plotting small subplots, one might want to reduce the maximum
		number of ticks and use tight bounds, for example::
		
		    ax.locator_params(tight=True, nbins=4)
	**/
	static public function locator_params(?axis:Dynamic, ?tight:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Natural logarithm, element-wise.
		
		The natural logarithm `log` is the inverse of the exponential function,
		so that `log(exp(x)) = x`. The natural logarithm is logarithm in base
		`e`.
		
		Parameters
		----------
		x : array_like
		    Input value.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The natural logarithm of `x`, element-wise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		log10, log2, log1p, emath.log
		
		Notes
		-----
		Logarithm is a multivalued function: for each `x` there is an infinite
		number of `z` such that `exp(z) = x`. The convention is to return the
		`z` whose imaginary part lies in `[-pi, pi]`.
		
		For real-valued input data types, `log` always returns real output. For
		each value that cannot be expressed as a real number or infinity, it
		yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `log` is a complex analytical function that
		has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
		handles the floating-point negative zero as an infinitesimal negative
		number, conforming to the C99 standard.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Logarithm". https://en.wikipedia.org/wiki/Logarithm
		
		Examples
		--------
		>>> np.log([1, np.e, np.e**2, 0])
		array([  0.,   1.,   2., -Inf])
	**/
	static public function log(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the base 10 logarithm of the input array, element-wise.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The logarithm to the base 10 of `x`, element-wise. NaNs are
		    returned where x is negative.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		emath.log10
		
		Notes
		-----
		Logarithm is a multivalued function: for each `x` there is an infinite
		number of `z` such that `10**z = x`. The convention is to return the
		`z` whose imaginary part lies in `[-pi, pi]`.
		
		For real-valued input data types, `log10` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `log10` is a complex analytical function that
		has a branch cut `[-inf, 0]` and is continuous from above on it.
		`log10` handles the floating-point negative zero as an infinitesimal
		negative number, conforming to the C99 standard.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Logarithm". https://en.wikipedia.org/wiki/Logarithm
		
		Examples
		--------
		>>> np.log10([1e-15, -3.])
		array([-15.,  NaN])
	**/
	static public function log10(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the natural logarithm of one plus the input array, element-wise.
		
		Calculates ``log(1 + x)``.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    Natural logarithm of `1 + x`, element-wise.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		expm1 : ``exp(x) - 1``, the inverse of `log1p`.
		
		Notes
		-----
		For real-valued input, `log1p` is accurate also for `x` so small
		that `1 + x == 1` in floating-point accuracy.
		
		Logarithm is a multivalued function: for each `x` there is an infinite
		number of `z` such that `exp(z) = 1 + x`. The convention is to return
		the `z` whose imaginary part lies in `[-pi, pi]`.
		
		For real-valued input data types, `log1p` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `log1p` is a complex analytical function that
		has a branch cut `[-inf, -1]` and is continuous from above on it.
		`log1p` handles the floating-point negative zero as an infinitesimal
		negative number, conforming to the C99 standard.
		
		References
		----------
		.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
		       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
		.. [2] Wikipedia, "Logarithm". https://en.wikipedia.org/wiki/Logarithm
		
		Examples
		--------
		>>> np.log1p(1e-99)
		1e-99
		>>> np.log(1 + 1e-99)
		0.0
	**/
	static public function log1p(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Base-2 logarithm of `x`.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    Base-2 logarithm of `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		log, log10, log1p, emath.log2
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		Logarithm is a multivalued function: for each `x` there is an infinite
		number of `z` such that `2**z = x`. The convention is to return the `z`
		whose imaginary part lies in `[-pi, pi]`.
		
		For real-valued input data types, `log2` always returns real output.
		For each value that cannot be expressed as a real number or infinity,
		it yields ``nan`` and sets the `invalid` floating point error flag.
		
		For complex-valued input, `log2` is a complex analytical function that
		has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`
		handles the floating-point negative zero as an infinitesimal negative
		number, conforming to the C99 standard.
		
		Examples
		--------
		>>> x = np.array([0, 1, 2, 2**4])
		>>> np.log2(x)
		array([-Inf,   0.,   1.,   4.])
		
		>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
		>>> np.log2(xi)
		array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])
	**/
	static public function log2(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Logarithm of the sum of exponentiations of the inputs.
		
		Calculates ``log(exp(x1) + exp(x2))``. This function is useful in
		statistics where the calculated probabilities of events may be so small
		as to exceed the range of normal floating point numbers.  In such cases
		the logarithm of the calculated probability is stored. This function
		allows adding probabilities stored in such a fashion.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		result : ndarray
		    Logarithm of ``exp(x1) + exp(x2)``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		Examples
		--------
		>>> prob1 = np.log(1e-50)
		>>> prob2 = np.log(2.5e-50)
		>>> prob12 = np.logaddexp(prob1, prob2)
		>>> prob12
		-113.87649168120691
		>>> np.exp(prob12)
		3.5000000000000057e-50
	**/
	static public function logaddexp(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Logarithm of the sum of exponentiations of the inputs in base-2.
		
		Calculates ``log2(2**x1 + 2**x2)``. This function is useful in machine
		learning when the calculated probabilities of events may be so small as
		to exceed the range of normal floating point numbers.  In such cases
		the base-2 logarithm of the calculated probability can be used instead.
		This function allows adding probabilities stored in such a fashion.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		result : ndarray
		    Base-2 logarithm of ``2**x1 + 2**x2``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logaddexp: Logarithm of the sum of exponentiations of the inputs.
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		Examples
		--------
		>>> prob1 = np.log2(1e-50)
		>>> prob2 = np.log2(2.5e-50)
		>>> prob12 = np.logaddexp2(prob1, prob2)
		>>> prob1, prob2, prob12
		(-166.09640474436813, -164.77447664948076, -164.28904982231052)
		>>> 2**prob12
		3.4999999999999914e-50
	**/
	static public function logaddexp2(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the truth value of x1 AND x2 element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays. `x1` and `x2` must be of the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or bool
		    Boolean result with the same shape as `x1` and `x2` of the logical
		    AND operation on corresponding elements of `x1` and `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_or, logical_not, logical_xor
		bitwise_and
		
		Examples
		--------
		>>> np.logical_and(True, False)
		False
		>>> np.logical_and([True, False], [False, False])
		array([False, False])
		
		>>> x = np.arange(5)
		>>> np.logical_and(x>1, x<4)
		array([False, False,  True,  True, False])
	**/
	static public function logical_and(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the truth value of NOT x element-wise.
		
		Parameters
		----------
		x : array_like
		    Logical NOT is applied to the elements of `x`.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : bool or ndarray of bool
		    Boolean result with the same shape as `x` of the NOT operation
		    on elements of `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		logical_and, logical_or, logical_xor
		
		Examples
		--------
		>>> np.logical_not(3)
		False
		>>> np.logical_not([True, False, 0, 1])
		array([False,  True,  True, False])
		
		>>> x = np.arange(5)
		>>> np.logical_not(x<3)
		array([False, False, False,  True,  True])
	**/
	static public function logical_not(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the truth value of x1 OR x2 element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Logical OR is applied to the elements of `x1` and `x2`.
		    They have to be of the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or bool
		    Boolean result with the same shape as `x1` and `x2` of the logical
		    OR operation on elements of `x1` and `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_and, logical_not, logical_xor
		bitwise_or
		
		Examples
		--------
		>>> np.logical_or(True, False)
		True
		>>> np.logical_or([True, False], [False, False])
		array([ True, False])
		
		>>> x = np.arange(5)
		>>> np.logical_or(x < 1, x > 3)
		array([ True, False, False, False,  True])
	**/
	static public function logical_or(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute the truth value of x1 XOR x2, element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Logical XOR is applied to the elements of `x1` and `x2`.  They must
		    be broadcastable to the same shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : bool or ndarray of bool
		    Boolean result of the logical XOR operation applied to the elements
		    of `x1` and `x2`; the shape is determined by whether or not
		    broadcasting of one or both arrays was required.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		logical_and, logical_or, logical_not, bitwise_xor
		
		Examples
		--------
		>>> np.logical_xor(True, False)
		True
		>>> np.logical_xor([True, True, False, False], [True, False, True, False])
		array([False,  True,  True, False])
		
		>>> x = np.arange(5)
		>>> np.logical_xor(x < 1, x > 3)
		array([ True, False, False, False,  True])
		
		Simple example showing support of broadcasting
		
		>>> np.logical_xor(0, np.eye(2))
		array([[ True, False],
		       [False,  True]])
	**/
	static public function logical_xor(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logistic(loc=0.0, scale=1.0, size=None)
		
		Draw samples from a logistic distribution.
		
		Samples are drawn from a logistic distribution with specified
		parameters, loc (location or mean, also median), and scale (>0).
		
		Parameters
		----------
		loc : float or array_like of floats, optional
		    Parameter of the distribution. Default is 0.
		scale : float or array_like of floats, optional
		    Parameter of the distribution. Should be greater than zero.
		    Default is 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``loc`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized logistic distribution.
		
		See Also
		--------
		scipy.stats.logistic : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Logistic distribution is
		
		.. math:: P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},
		
		where :math:`\mu` = location and :math:`s` = scale.
		
		The Logistic distribution is used in Extreme Value problems where it
		can act as a mixture of Gumbel distributions, in Epidemiology, and by
		the World Chess Federation (FIDE) where it is used in the Elo ranking
		system, assuming the performance of each player is a logistically
		distributed random variable.
		
		References
		----------
		.. [1] Reiss, R.-D. and Thomas M. (2001), "Statistical Analysis of
		       Extreme Values, from Insurance, Finance, Hydrology and Other
		       Fields," Birkhauser Verlag, Basel, pp 132-133.
		.. [2] Weisstein, Eric W. "Logistic Distribution." From
		       MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/LogisticDistribution.html
		.. [3] Wikipedia, "Logistic-distribution",
		       https://en.wikipedia.org/wiki/Logistic_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> loc, scale = 10, 1
		>>> s = np.random.logistic(loc, scale, 10000)
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, bins=50)
		
		#   plot against distribution
		
		>>> def logist(x, loc, scale):
		...     return exp((loc-x)/scale)/(scale*(1+exp((loc-x)/scale))**2)
		>>> plt.plot(bins, logist(bins, loc, scale)*count.max()/\
		... logist(bins, loc, scale).max())
		>>> plt.show()
	**/
	static public function logistic(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Make a plot with log scaling on both the x and y axis.
		
		Call signatures::
		
		    loglog([x], y, [fmt], data=None, **kwargs)
		    loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
		
		This is just a thin wrapper around `.plot` which additionally changes
		both the x-axis and the y-axis to log scaling. All of the concepts and
		parameters of plot can be used here as well.
		
		The additional parameters *basex/y*, *subsx/y* and *nonposx/y* control
		the x/y-axis properties. They are just forwarded to `.Axes.set_xscale`
		and `.Axes.set_yscale`.
		
		Parameters
		----------
		basex, basey : scalar, optional, default 10
		    Base of the x/y logarithm.
		
		subsx, subsy : sequence, optional
		    The location of the minor x/y ticks. If *None*, reasonable
		    locations are automatically chosen depending on the number of
		    decades in the plot.
		    See `.Axes.set_xscale` / `.Axes.set_yscale` for details.
		
		nonposx, nonposy : {'mask', 'clip'}, optional, default 'mask'
		    Non-positive values in x or y can be masked as invalid, or clipped
		    to a very small positive number.
		
		Returns
		-------
		lines
		    A list of `~.Line2D` objects representing the plotted data.
		
		Other Parameters
		----------------
		**kwargs
		    All parameters supported by `.plot`.
	**/
	static public function loglog(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		lognormal(mean=0.0, sigma=1.0, size=None)
		
		Draw samples from a log-normal distribution.
		
		Draw samples from a log-normal distribution with specified mean,
		standard deviation, and array shape.  Note that the mean and standard
		deviation are not the values for the distribution itself, but of the
		underlying normal distribution it is derived from.
		
		Parameters
		----------
		mean : float or array_like of floats, optional
		    Mean value of the underlying normal distribution. Default is 0.
		sigma : float or array_like of floats, optional
		    Standard deviation of the underlying normal distribution. Should
		    be greater than zero. Default is 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``mean`` and ``sigma`` are both scalars.
		    Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized log-normal distribution.
		
		See Also
		--------
		scipy.stats.lognorm : probability density function, distribution,
		    cumulative density function, etc.
		
		Notes
		-----
		A variable `x` has a log-normal distribution if `log(x)` is normally
		distributed.  The probability density function for the log-normal
		distribution is:
		
		.. math:: p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
		                 e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}
		
		where :math:`\mu` is the mean and :math:`\sigma` is the standard
		deviation of the normally distributed logarithm of the variable.
		A log-normal distribution results if a random variable is the *product*
		of a large number of independent, identically-distributed variables in
		the same way that a normal distribution results if the variable is the
		*sum* of a large number of independent, identically-distributed
		variables.
		
		References
		----------
		.. [1] Limpert, E., Stahel, W. A., and Abbt, M., "Log-normal
		       Distributions across the Sciences: Keys and Clues,"
		       BioScience, Vol. 51, No. 5, May, 2001.
		       https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf
		.. [2] Reiss, R.D. and Thomas, M., "Statistical Analysis of Extreme
		       Values," Basel: Birkhauser Verlag, 2001, pp. 31-32.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> mu, sigma = 3., 1. # mean and standard deviation
		>>> s = np.random.lognormal(mu, sigma, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')
		
		>>> x = np.linspace(min(bins), max(bins), 10000)
		>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
		...        / (x * sigma * np.sqrt(2 * np.pi)))
		
		>>> plt.plot(x, pdf, linewidth=2, color='r')
		>>> plt.axis('tight')
		>>> plt.show()
		
		Demonstrate that taking the products of random samples from a uniform
		distribution can be fit well by a log-normal probability density
		function.
		
		>>> # Generate a thousand samples: each is the product of 100 random
		>>> # values, drawn from a normal distribution.
		>>> b = []
		>>> for i in range(1000):
		...    a = 10. + np.random.random(100)
		...    b.append(np.product(a))
		
		>>> b = np.array(b) / np.min(b) # scale values to be positive
		>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
		>>> sigma = np.std(np.log(b))
		>>> mu = np.mean(np.log(b))
		
		>>> x = np.linspace(min(bins), max(bins), 10000)
		>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
		...        / (x * sigma * np.sqrt(2 * np.pi)))
		
		>>> plt.plot(x, pdf, color='r', linewidth=2)
		>>> plt.show()
	**/
	static public function lognormal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		logseries(p, size=None)
		
		Draw samples from a logarithmic series distribution.
		
		Samples are drawn from a log series distribution with specified
		shape parameter, 0 < ``p`` < 1.
		
		Parameters
		----------
		p : float or array_like of floats
		    Shape parameter for the distribution.  Must be in the range (0, 1).
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``p`` is a scalar.  Otherwise,
		    ``np.array(p).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized logarithmic series distribution.
		
		See Also
		--------
		scipy.stats.logser : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Log Series distribution is
		
		.. math:: P(k) = \frac{-p^k}{k \ln(1-p)},
		
		where p = probability.
		
		The log series distribution is frequently used to represent species
		richness and occurrence, first proposed by Fisher, Corbet, and
		Williams in 1943 [2].  It may also be used to model the numbers of
		occupants seen in cars [3].
		
		References
		----------
		.. [1] Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
		       species diversity through the log series distribution of
		       occurrences: BIODIVERSITY RESEARCH Diversity & Distributions,
		       Volume 5, Number 5, September 1999 , pp. 187-195(9).
		.. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
		       relation between the number of species and the number of
		       individuals in a random sample of an animal population.
		       Journal of Animal Ecology, 12:42-58.
		.. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
		       Data Sets, CRC Press, 1994.
		.. [4] Wikipedia, "Logarithmic distribution",
		       https://en.wikipedia.org/wiki/Logarithmic_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> a = .6
		>>> s = np.random.logseries(a, 10000)
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s)
		
		#   plot against distribution
		
		>>> def logseries(k, p):
		...     return -p**k/(k*log(1-p))
		>>> plt.plot(bins, logseries(bins, a)*count.max()/
		             logseries(bins, a).max(), 'r')
		>>> plt.show()
	**/
	static public function logseries(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return numbers spaced evenly on a log scale.
		
		In linear space, the sequence starts at ``base ** start``
		(`base` to the power of `start`) and ends with ``base ** stop``
		(see `endpoint` below).
		
		.. versionchanged:: 1.16.0
		    Non-scalar `start` and `stop` are now supported.
		
		Parameters
		----------
		start : array_like
		    ``base ** start`` is the starting value of the sequence.
		stop : array_like
		    ``base ** stop`` is the final value of the sequence, unless `endpoint`
		    is False.  In that case, ``num + 1`` values are spaced over the
		    interval in log-space, of which all but the last (a sequence of
		    length `num`) are returned.
		num : integer, optional
		    Number of samples to generate.  Default is 50.
		endpoint : boolean, optional
		    If true, `stop` is the last sample. Otherwise, it is not included.
		    Default is True.
		base : float, optional
		    The base of the log space. The step size between the elements in
		    ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.
		    Default is 10.0.
		dtype : dtype
		    The type of the output array.  If `dtype` is not given, infer the data
		    type from the other input arguments.
		axis : int, optional
		    The axis in the result to store the samples.  Relevant only if start
		    or stop are array-like.  By default (0), the samples will be along a
		    new axis inserted at the beginning. Use -1 to get an axis at the end.
		
		    .. versionadded:: 1.16.0
		
		
		Returns
		-------
		samples : ndarray
		    `num` samples, equally spaced on a log scale.
		
		See Also
		--------
		arange : Similar to linspace, with the step size specified instead of the
		         number of samples. Note that, when used with a float endpoint, the
		         endpoint may or may not be included.
		linspace : Similar to logspace, but with the samples uniformly distributed
		           in linear space, instead of log space.
		geomspace : Similar to logspace, but with endpoints specified directly.
		
		Notes
		-----
		Logspace is equivalent to the code
		
		>>> y = np.linspace(start, stop, num=num, endpoint=endpoint)
		... # doctest: +SKIP
		>>> power(base, y).astype(dtype)
		... # doctest: +SKIP
		
		Examples
		--------
		>>> np.logspace(2.0, 3.0, num=4)
		array([  100.        ,   215.443469  ,   464.15888336,  1000.        ])
		>>> np.logspace(2.0, 3.0, num=4, endpoint=False)
		array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519])
		>>> np.logspace(2.0, 3.0, num=4, base=2.0)
		array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ])
		
		Graphical illustration:
		
		>>> import matplotlib.pyplot as plt
		>>> N = 10
		>>> x1 = np.logspace(0.1, 1, N, endpoint=True)
		>>> x2 = np.logspace(0.1, 1, N, endpoint=False)
		>>> y = np.zeros(N)
		>>> plt.plot(x1, y, 'o')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.plot(x2, y + 0.5, 'o')
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.ylim([-0.5, 1])
		(-0.5, 1)
		>>> plt.show()
	**/
	static public function logspace(start:Dynamic, stop:Dynamic, ?num:Dynamic, ?endpoint:Dynamic, ?base:Dynamic, ?dtype:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Do a keyword search on docstrings.
		
		A list of objects that matched the search is displayed,
		sorted by relevance. All given keywords need to be found in the
		docstring for it to be returned as a result, but the order does
		not matter.
		
		Parameters
		----------
		what : str
		    String containing words to look for.
		module : str or list, optional
		    Name of module(s) whose docstrings to go through.
		import_modules : bool, optional
		    Whether to import sub-modules in packages. Default is True.
		regenerate : bool, optional
		    Whether to re-generate the docstring cache. Default is False.
		output : file-like, optional
		    File-like object to write the output to. If omitted, use a pager.
		
		See Also
		--------
		source, info
		
		Notes
		-----
		Relevance is determined only roughly, by checking if the keywords occur
		in the function name, at the start of a docstring, etc.
		
		Examples
		--------
		>>> np.lookfor('binary representation')
		Search results for 'binary representation'
		------------------------------------------
		numpy.binary_repr
		    Return the binary representation of the input number as a string.
		numpy.core.setup_common.long_double_representation
		    Given a binary dump as given by GNU od -b, look for long double
		numpy.base_repr
		    Return a string representation of a number in the given base system.
		...
	**/
	static public function lookfor(what:Dynamic, ?module:Dynamic, ?import_modules:Dynamic, ?regenerate:Dynamic, ?output:Dynamic):Dynamic;
	/**
		Return the least-squares solution to a linear matrix equation.
		
		Solves the equation `a x = b` by computing a vector `x` that
		minimizes the Euclidean 2-norm `|| b - a x ||^2`.  The equation may
		be under-, well-, or over- determined (i.e., the number of
		linearly independent rows of `a` can be less than, equal to, or
		greater than its number of linearly independent columns).  If `a`
		is square and of full rank, then `x` (but for round-off error) is
		the "exact" solution of the equation.
		
		Parameters
		----------
		a : (M, N) array_like
		    "Coefficient" matrix.
		b : {(M,), (M, K)} array_like
		    Ordinate or "dependent variable" values. If `b` is two-dimensional,
		    the least-squares solution is calculated for each of the `K` columns
		    of `b`.
		rcond : float, optional
		    Cut-off ratio for small singular values of `a`.
		    For the purposes of rank determination, singular values are treated
		    as zero if they are smaller than `rcond` times the largest singular
		    value of `a`.
		
		    .. versionchanged:: 1.14.0
		       If not set, a FutureWarning is given. The previous default
		       of ``-1`` will use the machine precision as `rcond` parameter,
		       the new default will use the machine precision times `max(M, N)`.
		       To silence the warning and use the new default, use ``rcond=None``,
		       to keep using the old behavior, use ``rcond=-1``.
		
		Returns
		-------
		x : {(N,), (N, K)} ndarray
		    Least-squares solution. If `b` is two-dimensional,
		    the solutions are in the `K` columns of `x`.
		residuals : {(1,), (K,), (0,)} ndarray
		    Sums of residuals; squared Euclidean 2-norm for each column in
		    ``b - a*x``.
		    If the rank of `a` is < N or M <= N, this is an empty array.
		    If `b` is 1-dimensional, this is a (1,) shape array.
		    Otherwise the shape is (K,).
		rank : int
		    Rank of matrix `a`.
		s : (min(M, N),) ndarray
		    Singular values of `a`.
		
		Raises
		------
		LinAlgError
		    If computation does not converge.
		
		Notes
		-----
		If `b` is a matrix, then all array results are returned as matrices.
		
		Examples
		--------
		Fit a line, ``y = mx + c``, through some noisy data-points:
		
		>>> x = np.array([0, 1, 2, 3])
		>>> y = np.array([-1, 0.2, 0.9, 2.1])
		
		By examining the coefficients, we see that the line should have a
		gradient of roughly 1 and cut the y-axis at, more or less, -1.
		
		We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
		and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:
		
		>>> A = np.vstack([x, np.ones(len(x))]).T
		>>> A
		array([[ 0.,  1.],
		       [ 1.,  1.],
		       [ 2.,  1.],
		       [ 3.,  1.]])
		
		>>> m, c = np.linalg.lstsq(A, y, rcond=None)[0]
		>>> print(m, c)
		1.0 -0.95
		
		Plot the data along with the fitted line:
		
		>>> import matplotlib.pyplot as plt
		>>> plt.plot(x, y, 'o', label='Original data', markersize=10)
		>>> plt.plot(x, m*x + c, 'r', label='Fitted line')
		>>> plt.legend()
		>>> plt.show()
	**/
	static public function lstsq(a:Dynamic, b:Dynamic, ?rcond:Dynamic):Dynamic;
	/**
		Load ASCII data stored in a text file and return a masked array.
		
		Parameters
		----------
		fname, kwargs : For a description of input parameters, see `genfromtxt`.
		
		See Also
		--------
		numpy.genfromtxt : generic function to load ASCII data.
	**/
	static public function mafromtxt(fname:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "magma".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function magma():Dynamic;
	/**
		Plot the magnitude spectrum.
		
		Compute the magnitude spectrum of *x*.  Data is padded to a
		length of *pad_to* and the windowing function *window* is applied to
		the signal.
		
		Parameters
		----------
		x : 1-D array or sequence
		    Array or sequence containing the data.
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  While not increasing the actual resolution of
		    the spectrum (the minimum distance between resolvable peaks),
		    this can give more points in the plot, allowing for more
		    detail. This corresponds to the *n* parameter in the call to fft().
		    The default is None, which sets *pad_to* equal to the length of the
		    input signal (i.e. no padding).
		
		scale : {'default', 'linear', 'dB'}
		    The scaling of the values in the *spec*.  'linear' is no scaling.
		    'dB' returns the values in dB scale, i.e., the dB amplitude
		    (20 * log10). 'default' is 'linear'.
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		Returns
		-------
		spectrum : 1-D array
		    The values for the magnitude spectrum before scaling (real valued).
		
		freqs : 1-D array
		    The frequencies corresponding to the elements in *spectrum*.
		
		line : a :class:`~matplotlib.lines.Line2D` instance
		    The line created by this function.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See Also
		--------
		:func:`psd`
		    :func:`psd` plots the power spectral density.`.
		
		:func:`angle_spectrum`
		    :func:`angle_spectrum` plots the angles of the corresponding
		    frequencies.
		
		:func:`phase_spectrum`
		    :func:`phase_spectrum` plots the phase (unwrapped angle) of the
		    corresponding frequencies.
		
		:func:`specgram`
		    :func:`specgram` can plot the magnitude spectrum of segments within
		    the signal in a colormap.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function magnitude_spectrum(x:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?window:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?scale:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set or retrieve autoscaling margins.
		
		The padding added to each limit of the axes is the *margin*
		times the data interval. All input parameters must be floats
		within the range [0, 1]. Passing both positional and keyword
		arguments is invalid and will raise a TypeError. If no
		arguments (positional or otherwise) are provided, the current
		margins will remain in place and simply be returned.
		
		Specifying any margin changes only the autoscaling; for example,
		if *xmargin* is not None, then *xmargin* times the X data
		interval will be added to each end of that interval before
		it is used in autoscaling.
		
		Parameters
		----------
		*margins : float, optional
		    If a single positional argument is provided, it specifies
		    both margins of the x-axis and y-axis limits. If two
		    positional arguments are provided, they will be interpreted
		    as *xmargin*, *ymargin*. If setting the margin on a single
		    axis is desired, use the keyword arguments described below.
		
		x, y : float, optional
		    Specific margin values for the x-axis and y-axis,
		    respectively. These cannot be used with positional
		    arguments, but can be used individually to alter on e.g.,
		    only the y-axis.
		
		tight : bool or None, default is True
		    The *tight* parameter is passed to :meth:`autoscale_view`,
		    which is executed after a margin is changed; the default
		    here is *True*, on the assumption that when margins are
		    specified, no additional padding to match tick marks is
		    usually desired.  Set *tight* to *None* will preserve
		    the previous setting.
		
		Returns
		-------
		xmargin, ymargin : float
		
		Notes
		-----
		If a previously used Axes method such as :meth:`pcolor` has set
		:attr:`use_sticky_edges` to `True`, only the limits not set by
		the "sticky artists" will be modified. To force all of the
		margins to be set, set :attr:`use_sticky_edges` to `False`
		before calling :meth:`margins`.
	**/
	static public function margins(?margins:python.VarArgs<Dynamic>, ?x:Dynamic, ?y:Dynamic, ?tight:Dynamic):Dynamic;
	/**
		Return the indices to access (n, n) arrays, given a masking function.
		
		Assume `mask_func` is a function that, for a square array a of size
		``(n, n)`` with a possible offset argument `k`, when called as
		``mask_func(a, k)`` returns a new array with zeros in certain locations
		(functions like `triu` or `tril` do precisely this). Then this function
		returns the indices where the non-zero values would be located.
		
		Parameters
		----------
		n : int
		    The returned indices will be valid to access arrays of shape (n, n).
		mask_func : callable
		    A function whose call signature is similar to that of `triu`, `tril`.
		    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.
		    `k` is an optional argument to the function.
		k : scalar
		    An optional argument which is passed through to `mask_func`. Functions
		    like `triu`, `tril` take a second argument that is interpreted as an
		    offset.
		
		Returns
		-------
		indices : tuple of arrays.
		    The `n` arrays of indices corresponding to the locations where
		    ``mask_func(np.ones((n, n)), k)`` is True.
		
		See Also
		--------
		triu, tril, triu_indices, tril_indices
		
		Notes
		-----
		.. versionadded:: 1.4.0
		
		Examples
		--------
		These are the indices that would allow you to access the upper triangular
		part of any 3x3 array:
		
		>>> iu = np.mask_indices(3, np.triu)
		
		For example, if `a` is a 3x3 array:
		
		>>> a = np.arange(9).reshape(3, 3)
		>>> a
		array([[0, 1, 2],
		       [3, 4, 5],
		       [6, 7, 8]])
		>>> a[iu]
		array([0, 1, 2, 4, 5, 8])
		
		An offset can be passed also to the masking function.  This gets us the
		indices starting on the first diagonal right of the main one:
		
		>>> iu1 = np.mask_indices(3, np.triu, 1)
		
		with which we now extract only three elements:
		
		>>> a[iu1]
		array([1, 2, 5])
	**/
	static public function mask_indices(n:Dynamic, mask_func:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Interpret the input as a matrix.
		
		Unlike `matrix`, `asmatrix` does not make a copy if the input is already
		a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.
		
		Parameters
		----------
		data : array_like
		    Input data.
		dtype : data-type
		   Data-type of the output matrix.
		
		Returns
		-------
		mat : matrix
		    `data` interpreted as a matrix.
		
		Examples
		--------
		>>> x = np.array([[1, 2], [3, 4]])
		
		>>> m = np.asmatrix(x)
		
		>>> x[0,0] = 5
		
		>>> m
		matrix([[5, 2],
		        [3, 4]])
	**/
	static public function mat(data:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Matrix product of two arrays.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays, scalars not allowed.
		out : ndarray, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that matches the signature `(n,k),(k,m)->(n,m)`. If not
		    provided or `None`, a freshly-allocated array is returned.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		    ..versionadded:: 1.16
		      Now handles ufunc kwargs
		
		Returns
		-------
		y : ndarray
		    The matrix product of the inputs.
		    This is a scalar only when both x1, x2 are 1-d vectors.
		
		Raises
		------
		ValueError
		    If the last dimension of `a` is not the same size as
		    the second-to-last dimension of `b`.
		
		    If a scalar value is passed in.
		
		See Also
		--------
		vdot : Complex-conjugating dot product.
		tensordot : Sum products over arbitrary axes.
		einsum : Einstein summation convention.
		dot : alternative matrix product with different broadcasting rules.
		
		Notes
		-----
		
		The behavior depends on the arguments in the following way.
		
		- If both arguments are 2-D they are multiplied like conventional
		  matrices.
		- If either argument is N-D, N > 2, it is treated as a stack of
		  matrices residing in the last two indexes and broadcast accordingly.
		- If the first argument is 1-D, it is promoted to a matrix by
		  prepending a 1 to its dimensions. After matrix multiplication
		  the prepended 1 is removed.
		- If the second argument is 1-D, it is promoted to a matrix by
		  appending a 1 to its dimensions. After matrix multiplication
		  the appended 1 is removed.
		
		``matmul`` differs from ``dot`` in two important ways:
		
		- Multiplication by scalars is not allowed, use ``*`` instead.
		- Stacks of matrices are broadcast together as if the matrices
		  were elements, respecting the signature ``(n,k),(k,m)->(n,m)``:
		
		  >>> a = np.ones([9, 5, 7, 4])
		  >>> c = np.ones([9, 5, 4, 3])
		  >>> np.dot(a, c).shape
		  (9, 5, 7, 9, 5, 3)
		  >>> np.matmul(a, c).shape
		  (9, 5, 7, 3)
		  >>> # n is 7, k is 4, m is 3
		
		The matmul function implements the semantics of the `@` operator introduced
		in Python 3.5 following PEP465.
		
		Examples
		--------
		For 2-D arrays it is the matrix product:
		
		>>> a = np.array([[1, 0],
		...               [0, 1]])
		>>> b = np.array([[4, 1],
		...               [2, 2]]
		>>> np.matmul(a, b)
		array([[4, 1],
		       [2, 2]])
		
		For 2-D mixed with 1-D, the result is the usual.
		
		>>> a = np.array([[1, 0],
		...               [0, 1]]
		>>> b = np.array([1, 2])
		>>> np.matmul(a, b)
		array([1, 2])
		>>> np.matmul(b, a)
		array([1, 2])
		
		
		Broadcasting is conventional for stacks of arrays
		
		>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
		>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
		>>> np.matmul(a,b).shape
		(2, 2, 2)
		>>> np.matmul(a, b)[0, 1, 1]
		98
		>>> sum(a[0, 1, :] * b[0 , :, 1])
		98
		
		Vector, vector returns the scalar inner product, but neither argument
		is complex-conjugated:
		
		>>> np.matmul([2j, 3j], [2j, 3j])
		(-13+0j)
		
		Scalar multiplication raises an error.
		
		>>> np.matmul([1,2], 3)
		Traceback (most recent call last):
		...
		ValueError: matmul: Input operand 1 does not have enough dimensions ...
		
		.. versionadded:: 1.10.0
	**/
	static public function matmul(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Raise a square matrix to the (integer) power `n`.
		
		For positive integers `n`, the power is computed by repeated matrix
		squarings and matrix multiplications. If ``n == 0``, the identity matrix
		of the same shape as M is returned. If ``n < 0``, the inverse
		is computed and then raised to the ``abs(n)``.
		
		.. note:: Stacks of object matrices are not currently supported.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Matrix to be "powered."
		n : int
		    The exponent can be any integer or long integer, positive,
		    negative, or zero.
		
		Returns
		-------
		a**n : (..., M, M) ndarray or matrix object
		    The return value is the same shape and type as `M`;
		    if the exponent is positive or zero then the type of the
		    elements is the same as those of `M`. If the exponent is
		    negative the elements are floating-point.
		
		Raises
		------
		LinAlgError
		    For matrices that are not square or that (for negative powers) cannot
		    be inverted numerically.
		
		Examples
		--------
		>>> from numpy.linalg import matrix_power
		>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
		>>> matrix_power(i, 3) # should = -i
		array([[ 0, -1],
		       [ 1,  0]])
		>>> matrix_power(i, 0)
		array([[1, 0],
		       [0, 1]])
		>>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
		array([[ 0.,  1.],
		       [-1.,  0.]])
		
		Somewhat more sophisticated example
		
		>>> q = np.zeros((4, 4))
		>>> q[0:2, 0:2] = -i
		>>> q[2:4, 2:4] = i
		>>> q # one of the three quaternion units not equal to 1
		array([[ 0., -1.,  0.,  0.],
		       [ 1.,  0.,  0.,  0.],
		       [ 0.,  0.,  0.,  1.],
		       [ 0.,  0., -1.,  0.]])
		>>> matrix_power(q, 2) # = -np.eye(4)
		array([[-1.,  0.,  0.,  0.],
		       [ 0., -1.,  0.,  0.],
		       [ 0.,  0., -1.,  0.],
		       [ 0.,  0.,  0., -1.]])
	**/
	static public function matrix_power(a:Dynamic, n:Dynamic):Dynamic;
	/**
		Return matrix rank of array using SVD method
		
		Rank of the array is the number of singular values of the array that are
		greater than `tol`.
		
		.. versionchanged:: 1.14
		   Can now operate on stacks of matrices
		
		Parameters
		----------
		M : {(M,), (..., M, N)} array_like
		    input vector or stack of matrices
		tol : (...) array_like, float, optional
		    threshold below which SVD values are considered zero. If `tol` is
		    None, and ``S`` is an array with singular values for `M`, and
		    ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
		    set to ``S.max() * max(M.shape) * eps``.
		
		    .. versionchanged:: 1.14
		       Broadcasted against the stack of matrices
		hermitian : bool, optional
		    If True, `M` is assumed to be Hermitian (symmetric if real-valued),
		    enabling a more efficient method for finding singular values.
		    Defaults to False.
		
		    .. versionadded:: 1.14
		
		Notes
		-----
		The default threshold to detect rank deficiency is a test on the magnitude
		of the singular values of `M`.  By default, we identify singular values less
		than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
		the symbols defined above). This is the algorithm MATLAB uses [1].  It also
		appears in *Numerical recipes* in the discussion of SVD solutions for linear
		least squares [2].
		
		This default threshold is designed to detect rank deficiency accounting for
		the numerical errors of the SVD computation.  Imagine that there is a column
		in `M` that is an exact (in floating point) linear combination of other
		columns in `M`. Computing the SVD on `M` will not produce a singular value
		exactly equal to 0 in general: any difference of the smallest SVD value from
		0 will be caused by numerical imprecision in the calculation of the SVD.
		Our threshold for small SVD values takes this numerical imprecision into
		account, and the default threshold will detect such numerical rank
		deficiency.  The threshold may declare a matrix `M` rank deficient even if
		the linear combination of some columns of `M` is not exactly equal to
		another column of `M` but only numerically very close to another column of
		`M`.
		
		We chose our default threshold because it is in wide use.  Other thresholds
		are possible.  For example, elsewhere in the 2007 edition of *Numerical
		recipes* there is an alternative threshold of ``S.max() *
		np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
		this threshold as being based on "expected roundoff error" (p 71).
		
		The thresholds above deal with floating point roundoff error in the
		calculation of the SVD.  However, you may have more information about the
		sources of error in `M` that would make you consider other tolerance values
		to detect *effective* rank deficiency.  The most useful measure of the
		tolerance depends on the operations you intend to use on your matrix.  For
		example, if your data come from uncertain measurements with uncertainties
		greater than floating point epsilon, choosing a tolerance near that
		uncertainty may be preferable.  The tolerance may be absolute if the
		uncertainties are absolute rather than relative.
		
		References
		----------
		.. [1] MATLAB reference documention, "Rank"
		       https://www.mathworks.com/help/techdoc/ref/rank.html
		.. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
		       "Numerical Recipes (3rd edition)", Cambridge University Press, 2007,
		       page 795.
		
		Examples
		--------
		>>> from numpy.linalg import matrix_rank
		>>> matrix_rank(np.eye(4)) # Full rank matrix
		4
		>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
		>>> matrix_rank(I)
		3
		>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
		1
		>>> matrix_rank(np.zeros((4,)))
		0
	**/
	static public function matrix_rank(M:Dynamic, ?tol:Dynamic, ?hermitian:Dynamic):Dynamic;
	/**
		Display an array as a matrix in a new figure window.
		
		The origin is set at the upper left hand corner and rows (first
		dimension of the array) are displayed horizontally.  The aspect
		ratio of the figure window is that of the array, unless this would
		make an excessively short or narrow figure.
		
		Tick labels for the xaxis are placed on top.
		
		Parameters
		----------
		A : array-like(M, N)
		    The matrix to be displayed.
		
		fignum : None or int or False
		    If *None*, create a new figure window with automatic numbering.
		
		    If a nonzero integer, draw into the figure with the given number
		    (create it if it does not exist).
		
		    If 0, use the current axes (or create one if it does not exist).
		
		    .. note::
		
		       Because of how `.Axes.matshow` tries to set the figure aspect
		       ratio to be the one of the array, strange things may happen if you
		       reuse an existing figure.
		
		Returns
		-------
		image : `~matplotlib.image.AxesImage`
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.axes.Axes.imshow` arguments
	**/
	static public function matshow(A:Dynamic, ?fignum:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Element-wise maximum of array elements.
		
		Compare two arrays and returns a new array containing the element-wise
		maxima. If one of the elements being compared is a NaN, then that
		element is returned. If both elements are NaNs then the first is
		returned. The latter distinction is important for complex NaNs, which
		are defined as at least one of the real or imaginary parts being a NaN.
		The net effect is that NaNs are propagated.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays holding the elements to be compared. They must have
		    the same shape, or shapes that can be broadcast to a single shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The maximum of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		minimum :
		    Element-wise minimum of two arrays, propagates NaNs.
		fmax :
		    Element-wise maximum of two arrays, ignores NaNs.
		amax :
		    The maximum value of an array along a given axis, propagates NaNs.
		nanmax :
		    The maximum value of an array along a given axis, ignores NaNs.
		
		fmin, amin, nanmin
		
		Notes
		-----
		The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when
		neither x1 nor x2 are nans, but it is faster and does proper
		broadcasting.
		
		Examples
		--------
		>>> np.maximum([2, 3, 4], [1, 5, 2])
		array([2, 5, 4])
		
		>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
		array([[ 1. ,  2. ],
		       [ 0.5,  2. ]])
		
		>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
		array([ NaN,  NaN,  NaN])
		>>> np.maximum(np.Inf, 1)
		inf
	**/
	static public function maximum(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the scalar type of highest precision of the same kind as the input.
		
		Parameters
		----------
		t : dtype or dtype specifier
		    The input data type. This can be a `dtype` object or an object that
		    is convertible to a `dtype`.
		
		Returns
		-------
		out : dtype
		    The highest precision data type of the same kind (`dtype.kind`) as `t`.
		
		See Also
		--------
		obj2sctype, mintypecode, sctype2char
		dtype
		
		Examples
		--------
		>>> np.maximum_sctype(int)
		<type 'numpy.int64'>
		>>> np.maximum_sctype(np.uint8)
		<type 'numpy.uint64'>
		>>> np.maximum_sctype(complex)
		<type 'numpy.complex192'>
		
		>>> np.maximum_sctype(str)
		<type 'numpy.string_'>
		
		>>> np.maximum_sctype('i2')
		<type 'numpy.int64'>
		>>> np.maximum_sctype('f4')
		<type 'numpy.float96'>
	**/
	static public function maximum_sctype(t:Dynamic):Dynamic;
	/**
		may_share_memory(a, b, max_work=None)
		
		Determine if two arrays might share memory
		
		A return of True does not necessarily mean that the two arrays
		share any element.  It just means that they *might*.
		
		Only the memory bounds of a and b are checked by default.
		
		Parameters
		----------
		a, b : ndarray
		    Input arrays
		max_work : int, optional
		    Effort to spend on solving the overlap problem.  See
		    `shares_memory` for details.  Default for ``may_share_memory``
		    is to do a bounds check.
		
		Returns
		-------
		out : bool
		
		See Also
		--------
		shares_memory
		
		Examples
		--------
		>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
		False
		>>> x = np.zeros([3, 4])
		>>> np.may_share_memory(x[:,0], x[:,1])
		True
	**/
	static public function may_share_memory(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the arithmetic mean along the specified axis.
		
		Returns the average of the array elements.  The average is taken over
		the flattened array by default, otherwise over the specified axis.
		`float64` intermediate and return values are used for integer inputs.
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose mean is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which the means are computed. The default is to
		    compute the mean of the flattened array.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, a mean is performed over multiple axes,
		    instead of a single axis or all the axes as before.
		dtype : data-type, optional
		    Type to use in computing the mean.  For integer inputs, the default
		    is `float64`; for floating point inputs, it is the same as the
		    input dtype.
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``; if provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.
		    See `doc.ufuncs` for details.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `mean` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		m : ndarray, see dtype parameter above
		    If `out=None`, returns a new array containing the mean values,
		    otherwise a reference to the output array is returned.
		
		See Also
		--------
		average : Weighted average
		std, var, nanmean, nanstd, nanvar
		
		Notes
		-----
		The arithmetic mean is the sum of the elements along the axis divided
		by the number of elements.
		
		Note that for floating-point input, the mean is computed using the
		same precision the input has.  Depending on the input data, this can
		cause the results to be inaccurate, especially for `float32` (see
		example below).  Specifying a higher-precision accumulator using the
		`dtype` keyword can alleviate this issue.
		
		By default, `float16` results are computed using `float32` intermediates
		for extra precision.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, 4]])
		>>> np.mean(a)
		2.5
		>>> np.mean(a, axis=0)
		array([ 2.,  3.])
		>>> np.mean(a, axis=1)
		array([ 1.5,  3.5])
		
		In single precision, `mean` can be inaccurate:
		
		>>> a = np.zeros((2, 512*512), dtype=np.float32)
		>>> a[0, :] = 1.0
		>>> a[1, :] = 0.1
		>>> np.mean(a)
		0.54999924
		
		Computing the mean in float64 is more accurate:
		
		>>> np.mean(a, dtype=np.float64)
		0.55000000074505806
	**/
	static public function mean(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the median along the specified axis.
		
		Returns the median of the array elements.
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		axis : {int, sequence of int, None}, optional
		    Axis or axes along which the medians are computed. The default
		    is to compute the median along a flattened version of the array.
		    A sequence of axes is supported since version 1.9.0.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		   If True, then allow use of memory of input array `a` for
		   calculations. The input array will be modified by the call to
		   `median`. This will save memory when you do not need to preserve
		   the contents of the input array. Treat the input as undefined,
		   but it will probably be fully or partially sorted. Default is
		   False. If `overwrite_input` is ``True`` and `a` is not already an
		   `ndarray`, an error will be raised.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `arr`.
		
		    .. versionadded:: 1.9.0
		
		Returns
		-------
		median : ndarray
		    A new array holding the result. If the input contains integers
		    or floats smaller than ``float64``, then the output data-type is
		    ``np.float64``.  Otherwise, the data-type of the output is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		mean, percentile
		
		Notes
		-----
		Given a vector ``V`` of length ``N``, the median of ``V`` is the
		middle value of a sorted copy of ``V``, ``V_sorted`` - i
		e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
		two middle values of ``V_sorted`` when ``N`` is even.
		
		Examples
		--------
		>>> a = np.array([[10, 7, 4], [3, 2, 1]])
		>>> a
		array([[10,  7,  4],
		       [ 3,  2,  1]])
		>>> np.median(a)
		3.5
		>>> np.median(a, axis=0)
		array([ 6.5,  4.5,  2.5])
		>>> np.median(a, axis=1)
		array([ 7.,  2.])
		>>> m = np.median(a, axis=0)
		>>> out = np.zeros_like(m)
		>>> np.median(a, axis=0, out=m)
		array([ 6.5,  4.5,  2.5])
		>>> m
		array([ 6.5,  4.5,  2.5])
		>>> b = a.copy()
		>>> np.median(b, axis=1, overwrite_input=True)
		array([ 7.,  2.])
		>>> assert not np.all(a==b)
		>>> b = a.copy()
		>>> np.median(b, axis=None, overwrite_input=True)
		3.5
		>>> assert not np.all(a==b)
	**/
	static public function median(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Return coordinate matrices from coordinate vectors.
		
		Make N-D coordinate arrays for vectorized evaluations of
		N-D scalar/vector fields over N-D grids, given
		one-dimensional coordinate arrays x1, x2,..., xn.
		
		.. versionchanged:: 1.9
		   1-D and 0-D cases are allowed.
		
		Parameters
		----------
		x1, x2,..., xn : array_like
		    1-D arrays representing the coordinates of a grid.
		indexing : {'xy', 'ij'}, optional
		    Cartesian ('xy', default) or matrix ('ij') indexing of output.
		    See Notes for more details.
		
		    .. versionadded:: 1.7.0
		sparse : bool, optional
		    If True a sparse grid is returned in order to conserve memory.
		    Default is False.
		
		    .. versionadded:: 1.7.0
		copy : bool, optional
		    If False, a view into the original arrays are returned in order to
		    conserve memory.  Default is True.  Please note that
		    ``sparse=False, copy=False`` will likely return non-contiguous
		    arrays.  Furthermore, more than one element of a broadcast array
		    may refer to a single memory location.  If you need to write to the
		    arrays, make copies first.
		
		    .. versionadded:: 1.7.0
		
		Returns
		-------
		X1, X2,..., XN : ndarray
		    For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,
		    return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'
		    or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'
		    with the elements of `xi` repeated to fill the matrix along
		    the first dimension for `x1`, the second for `x2` and so on.
		
		Notes
		-----
		This function supports both indexing conventions through the indexing
		keyword argument.  Giving the string 'ij' returns a meshgrid with
		matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
		In the 2-D case with inputs of length M and N, the outputs are of shape
		(N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
		with inputs of length M, N and P, outputs are of shape (N, M, P) for
		'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
		illustrated by the following code snippet::
		
		    xv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')
		    for i in range(nx):
		        for j in range(ny):
		            # treat xv[i,j], yv[i,j]
		
		    xv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')
		    for i in range(nx):
		        for j in range(ny):
		            # treat xv[j,i], yv[j,i]
		
		In the 1-D and 0-D case, the indexing and sparse keywords have no effect.
		
		See Also
		--------
		index_tricks.mgrid : Construct a multi-dimensional "meshgrid"
		                 using indexing notation.
		index_tricks.ogrid : Construct an open multi-dimensional "meshgrid"
		                 using indexing notation.
		
		Examples
		--------
		>>> nx, ny = (3, 2)
		>>> x = np.linspace(0, 1, nx)
		>>> y = np.linspace(0, 1, ny)
		>>> xv, yv = np.meshgrid(x, y)
		>>> xv
		array([[ 0. ,  0.5,  1. ],
		       [ 0. ,  0.5,  1. ]])
		>>> yv
		array([[ 0.,  0.,  0.],
		       [ 1.,  1.,  1.]])
		>>> xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
		>>> xv
		array([[ 0. ,  0.5,  1. ]])
		>>> yv
		array([[ 0.],
		       [ 1.]])
		
		`meshgrid` is very useful to evaluate functions on a grid.
		
		>>> import matplotlib.pyplot as plt
		>>> x = np.arange(-5, 5, 0.1)
		>>> y = np.arange(-5, 5, 0.1)
		>>> xx, yy = np.meshgrid(x, y, sparse=True)
		>>> z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)
		>>> h = plt.contourf(x,y,z)
		>>> plt.show()
	**/
	static public function meshgrid(?xi:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var mgrid : Dynamic;
	/**
		min_scalar_type(a)
		
		For scalar ``a``, returns the data type with the smallest size
		and smallest scalar kind which can hold its value.  For non-scalar
		array ``a``, returns the vector's dtype unmodified.
		
		Floating point values are not demoted to integers,
		and complex values are not demoted to floats.
		
		Parameters
		----------
		a : scalar or array_like
		    The value whose minimal data type is to be found.
		
		Returns
		-------
		out : dtype
		    The minimal data type.
		
		Notes
		-----
		.. versionadded:: 1.6.0
		
		See Also
		--------
		result_type, promote_types, dtype, can_cast
		
		Examples
		--------
		>>> np.min_scalar_type(10)
		dtype('uint8')
		
		>>> np.min_scalar_type(-260)
		dtype('int16')
		
		>>> np.min_scalar_type(3.1)
		dtype('float16')
		
		>>> np.min_scalar_type(1e50)
		dtype('float64')
		
		>>> np.min_scalar_type(np.arange(4,dtype='f8'))
		dtype('float64')
	**/
	static public function min_scalar_type(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Element-wise minimum of array elements.
		
		Compare two arrays and returns a new array containing the element-wise
		minima. If one of the elements being compared is a NaN, then that
		element is returned. If both elements are NaNs then the first is
		returned. The latter distinction is important for complex NaNs, which
		are defined as at least one of the real or imaginary parts being a NaN.
		The net effect is that NaNs are propagated.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays holding the elements to be compared. They must have
		    the same shape, or shapes that can be broadcast to a single shape.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The minimum of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		maximum :
		    Element-wise maximum of two arrays, propagates NaNs.
		fmin :
		    Element-wise minimum of two arrays, ignores NaNs.
		amin :
		    The minimum value of an array along a given axis, propagates NaNs.
		nanmin :
		    The minimum value of an array along a given axis, ignores NaNs.
		
		fmax, amax, nanmax
		
		Notes
		-----
		The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when
		neither x1 nor x2 are NaNs, but it is faster and does proper
		broadcasting.
		
		Examples
		--------
		>>> np.minimum([2, 3, 4], [1, 5, 2])
		array([1, 3, 2])
		
		>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
		array([[ 0.5,  0. ],
		       [ 0. ,  1. ]])
		
		>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
		array([ NaN,  NaN,  NaN])
		>>> np.minimum(-np.Inf, 1)
		-inf
	**/
	static public function minimum(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Remove minor ticks from the axes.
	**/
	static public function minorticks_off():Dynamic;
	/**
		Display minor ticks on the axes.
		
		Displaying minor ticks may reduce performance; you may turn them off
		using `minorticks_off()` if drawing speed is a problem.
	**/
	static public function minorticks_on():Dynamic;
	/**
		Return the character for the minimum-size type to which given types can
		be safely cast.
		
		The returned type character must represent the smallest size dtype such
		that an array of the returned type can handle the data from an array of
		all types in `typechars` (or if `typechars` is an array, then its
		dtype.char).
		
		Parameters
		----------
		typechars : list of str or array_like
		    If a list of strings, each string should represent a dtype.
		    If array_like, the character representation of the array dtype is used.
		typeset : str or list of str, optional
		    The set of characters that the returned character is chosen from.
		    The default set is 'GDFgdf'.
		default : str, optional
		    The default character, this is returned if none of the characters in
		    `typechars` matches a character in `typeset`.
		
		Returns
		-------
		typechar : str
		    The character representing the minimum-size type that was found.
		
		See Also
		--------
		dtype, sctype2char, maximum_sctype
		
		Examples
		--------
		>>> np.mintypecode(['d', 'f', 'S'])
		'd'
		>>> x = np.array([1.1, 2-3.j])
		>>> np.mintypecode(x)
		'D'
		
		>>> np.mintypecode('abceh', default='G')
		'G'
	**/
	static public function mintypecode(typechars:Dynamic, ?typeset:Dynamic, ?_default:Dynamic):String;
	/**
		Modified internal rate of return.
		
		Parameters
		----------
		values : array_like
		    Cash flows (must contain at least one positive and one negative
		    value) or nan is returned.  The first value is considered a sunk
		    cost at time zero.
		finance_rate : scalar
		    Interest rate paid on the cash flows
		reinvest_rate : scalar
		    Interest rate received on the cash flows upon reinvestment
		
		Returns
		-------
		out : float
		    Modified internal rate of return
	**/
	static public function mirr(values:Dynamic, finance_rate:Dynamic, reinvest_rate:Dynamic):Float;
	/**
		remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return element-wise remainder of division.
		
		Computes the remainder complementary to the `floor_divide` function.  It is
		equivalent to the Python modulus operator``x1 % x2`` and has the same sign
		as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
		is ``mod``.
		
		.. warning::
		
		    This should not be confused with:
		
		    * Python 3.7's `math.remainder` and C's ``remainder``, which
		      computes the IEEE remainder, which are the complement to
		      ``round(x1 / x2)``.
		    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
		      complement to ``int(x1 / x2)``.
		
		Parameters
		----------
		x1 : array_like
		    Dividend array.
		x2 : array_like
		    Divisor array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		floor_divide : Equivalent of Python ``//`` operator.
		divmod : Simultaneous floor division and remainder.
		fmod : Equivalent of the MATLAB ``rem`` function.
		divide, floor
		
		Notes
		-----
		Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
		integers.
		
		Examples
		--------
		>>> np.remainder([4, 7], [2, 3])
		array([0, 1])
		>>> np.remainder(np.arange(7), 5)
		array([0, 1, 2, 3, 4, 0, 1])
	**/
	static public function mod(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the fractional and integral parts of an array, element-wise.
		
		The fractional and integral parts are negative if the given number is
		negative.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y1 : ndarray
		    Fractional part of `x`.
		    This is a scalar if `x` is a scalar.
		y2 : ndarray
		    Integral part of `x`.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		For integer input the return values are floats.
		
		See Also
		--------
		divmod : ``divmod(x, 1)`` is equivalent to ``modf`` with the return values
		         switched, except it always has a positive remainder.
		
		Examples
		--------
		>>> np.modf([0, 3.5])
		(array([ 0. ,  0.5]), array([ 0.,  3.]))
		>>> np.modf(-0.5)
		(-0.5, -0)
	**/
	static public function modf(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Move axes of an array to new positions.
		
		Other axes remain in their original order.
		
		.. versionadded:: 1.11.0
		
		Parameters
		----------
		a : np.ndarray
		    The array whose axes should be reordered.
		source : int or sequence of int
		    Original positions of the axes to move. These must be unique.
		destination : int or sequence of int
		    Destination positions for each of the original axes. These must also be
		    unique.
		
		Returns
		-------
		result : np.ndarray
		    Array with moved axes. This array is a view of the input array.
		
		See Also
		--------
		transpose: Permute the dimensions of an array.
		swapaxes: Interchange two axes of an array.
		
		Examples
		--------
		
		>>> x = np.zeros((3, 4, 5))
		>>> np.moveaxis(x, 0, -1).shape
		(4, 5, 3)
		>>> np.moveaxis(x, -1, 0).shape
		(5, 3, 4)
		
		These all achieve the same result:
		
		>>> np.transpose(x).shape
		(5, 4, 3)
		>>> np.swapaxes(x, 0, -1).shape
		(5, 4, 3)
		>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
		(5, 4, 3)
		>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
		(5, 4, 3)
	**/
	static public function moveaxis(a:Dynamic, source:Dynamic, destination:Dynamic):Dynamic;
	/**
		Return a copy of an array sorted along the first axis.
		
		Parameters
		----------
		a : array_like
		    Array to be sorted.
		
		Returns
		-------
		sorted_array : ndarray
		    Array of the same type and shape as `a`.
		
		See Also
		--------
		sort
		
		Notes
		-----
		``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.
	**/
	static public function msort(a:Dynamic):Dynamic;
	/**
		Compute the dot product of two or more arrays in a single function call,
		while automatically selecting the fastest evaluation order.
		
		`multi_dot` chains `numpy.dot` and uses optimal parenthesization
		of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
		this can speed up the multiplication a lot.
		
		If the first argument is 1-D it is treated as a row vector.
		If the last argument is 1-D it is treated as a column vector.
		The other arguments must be 2-D.
		
		Think of `multi_dot` as::
		
		    def multi_dot(arrays): return functools.reduce(np.dot, arrays)
		
		
		Parameters
		----------
		arrays : sequence of array_like
		    If the first argument is 1-D it is treated as row vector.
		    If the last argument is 1-D it is treated as column vector.
		    The other arguments must be 2-D.
		
		Returns
		-------
		output : ndarray
		    Returns the dot product of the supplied arrays.
		
		See Also
		--------
		dot : dot multiplication with two arguments.
		
		References
		----------
		
		.. [1] Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378
		.. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication
		
		Examples
		--------
		`multi_dot` allows you to write::
		
		>>> from numpy.linalg import multi_dot
		>>> # Prepare some data
		>>> A = np.random.random(10000, 100)
		>>> B = np.random.random(100, 1000)
		>>> C = np.random.random(1000, 5)
		>>> D = np.random.random(5, 333)
		>>> # the actual dot multiplication
		>>> multi_dot([A, B, C, D])
		
		instead of::
		
		>>> np.dot(np.dot(np.dot(A, B), C), D)
		>>> # or
		>>> A.dot(B).dot(C).dot(D)
		
		Notes
		-----
		The cost for a matrix multiplication can be calculated with the
		following function::
		
		    def cost(A, B):
		        return A.shape[0] * A.shape[1] * B.shape[1]
		
		Let's assume we have three matrices
		:math:`A_{10x100}, B_{100x5}, C_{5x50}`.
		
		The costs for the two different parenthesizations are as follows::
		
		    cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
		    cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
	**/
	static public function multi_dot(arrays:Dynamic):Dynamic;
	/**
		multinomial(n, pvals, size=None)
		
		Draw samples from a multinomial distribution.
		
		The multinomial distribution is a multivariate generalisation of the
		binomial distribution.  Take an experiment with one of ``p``
		possible outcomes.  An example of such an experiment is throwing a dice,
		where the outcome can be 1 through 6.  Each sample drawn from the
		distribution represents `n` such experiments.  Its values,
		``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the
		outcome was ``i``.
		
		Parameters
		----------
		n : int
		    Number of experiments.
		pvals : sequence of floats, length p
		    Probabilities of each of the ``p`` different outcomes.  These
		    should sum to 1 (however, the last element is always assumed to
		    account for the remaining probability, as long as
		    ``sum(pvals[:-1]) <= 1)``.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : ndarray
		    The drawn samples, of shape *size*, if that was provided.  If not,
		    the shape is ``(N,)``.
		
		    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
		    value drawn from the distribution.
		
		Examples
		--------
		Throw a dice 20 times:
		
		>>> np.random.multinomial(20, [1/6.]*6, size=1)
		array([[4, 1, 7, 5, 2, 1]])
		
		It landed 4 times on 1, once on 2, etc.
		
		Now, throw the dice 20 times, and 20 times again:
		
		>>> np.random.multinomial(20, [1/6.]*6, size=2)
		array([[3, 4, 3, 3, 4, 3],
		       [2, 4, 3, 4, 0, 7]])
		
		For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
		we threw 2 times 1, 4 times 2, etc.
		
		A loaded die is more likely to land on number 6:
		
		>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
		array([11, 16, 14, 17, 16, 26])
		
		The probability inputs should be normalized. As an implementation
		detail, the value of the last entry is ignored and assumed to take
		up any leftover probability mass, but this should not be relied on.
		A biased coin which has twice as much weight on one side as on the
		other should be sampled like so:
		
		>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
		array([38, 62])
		
		not like:
		
		>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
		array([100,   0])
	**/
	static public function multinomial(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Multiply arguments element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays to be multiplied.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The product of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		Equivalent to `x1` * `x2` in terms of array broadcasting.
		
		Examples
		--------
		>>> np.multiply(2.0, 4.0)
		8.0
		
		>>> x1 = np.arange(9.0).reshape((3, 3))
		>>> x2 = np.arange(3.0)
		>>> np.multiply(x1, x2)
		array([[  0.,   1.,   4.],
		       [  0.,   4.,  10.],
		       [  0.,   7.,  16.]])
	**/
	static public function multiply(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		multivariate_normal(mean, cov[, size, check_valid, tol])
		
		Draw random samples from a multivariate normal distribution.
		
		The multivariate normal, multinormal or Gaussian distribution is a
		generalization of the one-dimensional normal distribution to higher
		dimensions.  Such a distribution is specified by its mean and
		covariance matrix.  These parameters are analogous to the mean
		(average or "center") and variance (standard deviation, or "width,"
		squared) of the one-dimensional normal distribution.
		
		Parameters
		----------
		mean : 1-D array_like, of length N
		    Mean of the N-dimensional distribution.
		cov : 2-D array_like, of shape (N, N)
		    Covariance matrix of the distribution. It must be symmetric and
		    positive-semidefinite for proper sampling.
		size : int or tuple of ints, optional
		    Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
		    generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
		    each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
		    If no shape is specified, a single (`N`-D) sample is returned.
		check_valid : { 'warn', 'raise', 'ignore' }, optional
		    Behavior when the covariance matrix is not positive semidefinite.
		tol : float, optional
		    Tolerance when checking the singular values in covariance matrix.
		    cov is cast to double before the check.
		
		Returns
		-------
		out : ndarray
		    The drawn samples, of shape *size*, if that was provided.  If not,
		    the shape is ``(N,)``.
		
		    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
		    value drawn from the distribution.
		
		Notes
		-----
		The mean is a coordinate in N-dimensional space, which represents the
		location where samples are most likely to be generated.  This is
		analogous to the peak of the bell curve for the one-dimensional or
		univariate normal distribution.
		
		Covariance indicates the level to which two variables vary together.
		From the multivariate normal distribution, we draw N-dimensional
		samples, :math:`X = [x_1, x_2, ... x_N]`.  The covariance matrix
		element :math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.
		The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its
		"spread").
		
		Instead of specifying the full covariance matrix, popular
		approximations include:
		
		  - Spherical covariance (`cov` is a multiple of the identity matrix)
		  - Diagonal covariance (`cov` has non-negative elements, and only on
		    the diagonal)
		
		This geometrical property can be seen in two dimensions by plotting
		generated data-points:
		
		>>> mean = [0, 0]
		>>> cov = [[1, 0], [0, 100]]  # diagonal covariance
		
		Diagonal covariance means that points are oriented along x or y-axis:
		
		>>> import matplotlib.pyplot as plt
		>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
		>>> plt.plot(x, y, 'x')
		>>> plt.axis('equal')
		>>> plt.show()
		
		Note that the covariance matrix must be positive semidefinite (a.k.a.
		nonnegative-definite). Otherwise, the behavior of this method is
		undefined and backwards compatibility is not guaranteed.
		
		References
		----------
		.. [1] Papoulis, A., "Probability, Random Variables, and Stochastic
		       Processes," 3rd ed., New York: McGraw-Hill, 1991.
		.. [2] Duda, R. O., Hart, P. E., and Stork, D. G., "Pattern
		       Classification," 2nd ed., New York: Wiley, 2001.
		
		Examples
		--------
		>>> mean = (1, 2)
		>>> cov = [[1, 0], [0, 1]]
		>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
		>>> x.shape
		(3, 3, 2)
		
		The following is probably true, given that 0.6 is roughly twice the
		standard deviation:
		
		>>> list((x[0,0,:] - mean) < 0.6)
		[True, True]
	**/
	static public function multivariate_normal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Convert mx :class:`datetime` instance (or sequence of mx
		instances) to the new date format.
	**/
	static public function mx2num(mxdates:Dynamic):Dynamic;
	static public var nan : Dynamic;
	/**
		Replace NaN with zero and infinity with large finite numbers.
		
		If `x` is inexact, NaN is replaced by zero, and infinity and -infinity
		replaced by the respectively largest and most negative finite floating
		point values representable by ``x.dtype``.
		
		For complex dtypes, the above is applied to each of the real and
		imaginary components of `x` separately.
		
		If `x` is not inexact, then no replacements are made.
		
		Parameters
		----------
		x : scalar or array_like
		    Input data.
		copy : bool, optional
		    Whether to create a copy of `x` (True) or to replace values
		    in-place (False). The in-place operation only occurs if
		    casting to an array does not require a copy.
		    Default is True.
		
		    .. versionadded:: 1.13
		
		Returns
		-------
		out : ndarray
		    `x`, with the non-finite values replaced. If `copy` is False, this may
		    be `x` itself.
		
		See Also
		--------
		isinf : Shows which elements are positive or negative infinity.
		isneginf : Shows which elements are negative infinity.
		isposinf : Shows which elements are positive infinity.
		isnan : Shows which elements are Not a Number (NaN).
		isfinite : Shows which elements are finite (not NaN, not infinity)
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754). This means that Not a Number is not equivalent to infinity.
		
		Examples
		--------
		>>> np.nan_to_num(np.inf)
		1.7976931348623157e+308
		>>> np.nan_to_num(-np.inf)
		-1.7976931348623157e+308
		>>> np.nan_to_num(np.nan)
		0.0
		>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
		>>> np.nan_to_num(x)
		array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
		        -1.28000000e+002,   1.28000000e+002])
		>>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
		>>> np.nan_to_num(y)
		array([  1.79769313e+308 +0.00000000e+000j,
		         0.00000000e+000 +0.00000000e+000j,
		         0.00000000e+000 +1.79769313e+308j])
	**/
	static public function nan_to_num(x:Dynamic, ?copy:Dynamic):Dynamic;
	/**
		Return the indices of the maximum values in the specified axis ignoring
		NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
		results cannot be trusted if a slice contains only NaNs and -Infs.
		
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : int, optional
		    Axis along which to operate.  By default flattened input is used.
		
		Returns
		-------
		index_array : ndarray
		    An array of indices or a single index value.
		
		See Also
		--------
		argmax, nanargmin
		
		Examples
		--------
		>>> a = np.array([[np.nan, 4], [2, 3]])
		>>> np.argmax(a)
		0
		>>> np.nanargmax(a)
		1
		>>> np.nanargmax(a, axis=0)
		array([1, 0])
		>>> np.nanargmax(a, axis=1)
		array([1, 1])
	**/
	static public function nanargmax(a:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return the indices of the minimum values in the specified axis ignoring
		NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
		cannot be trusted if a slice contains only NaNs and Infs.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : int, optional
		    Axis along which to operate.  By default flattened input is used.
		
		Returns
		-------
		index_array : ndarray
		    An array of indices or a single index value.
		
		See Also
		--------
		argmin, nanargmax
		
		Examples
		--------
		>>> a = np.array([[np.nan, 4], [2, 3]])
		>>> np.argmin(a)
		0
		>>> np.nanargmin(a)
		2
		>>> np.nanargmin(a, axis=0)
		array([1, 1])
		>>> np.nanargmin(a, axis=1)
		array([1, 0])
	**/
	static public function nanargmin(a:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return the cumulative product of array elements over a given axis treating Not a
		Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
		encountered and leading NaNs are replaced by ones.
		
		Ones are returned for slices that are all-NaN or empty.
		
		.. versionadded:: 1.12.0
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    Axis along which the cumulative product is computed.  By default
		    the input is flattened.
		dtype : dtype, optional
		    Type of the returned array, as well as of the accumulator in which
		    the elements are multiplied.  If *dtype* is not specified, it
		    defaults to the dtype of `a`, unless `a` has an integer dtype with
		    a precision less than that of the default platform integer.  In
		    that case, the default platform integer is used instead.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output
		    but the type of the resulting values will be cast if necessary.
		
		Returns
		-------
		nancumprod : ndarray
		    A new array holding the result is returned unless `out` is
		    specified, in which case it is returned.
		
		See Also
		--------
		numpy.cumprod : Cumulative product across array propagating NaNs.
		isnan : Show which elements are NaN.
		
		Examples
		--------
		>>> np.nancumprod(1)
		array([1])
		>>> np.nancumprod([1])
		array([1])
		>>> np.nancumprod([1, np.nan])
		array([ 1.,  1.])
		>>> a = np.array([[1, 2], [3, np.nan]])
		>>> np.nancumprod(a)
		array([ 1.,  2.,  6.,  6.])
		>>> np.nancumprod(a, axis=0)
		array([[ 1.,  2.],
		       [ 3.,  2.]])
		>>> np.nancumprod(a, axis=1)
		array([[ 1.,  2.],
		       [ 3.,  3.]])
	**/
	static public function nancumprod(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Return the cumulative sum of array elements over a given axis treating Not a
		Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
		encountered and leading NaNs are replaced by zeros.
		
		Zeros are returned for slices that are all-NaN or empty.
		
		.. versionadded:: 1.12.0
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis : int, optional
		    Axis along which the cumulative sum is computed. The default
		    (None) is to compute the cumsum over the flattened array.
		dtype : dtype, optional
		    Type of the returned array and of the accumulator in which the
		    elements are summed.  If `dtype` is not specified, it defaults
		    to the dtype of `a`, unless `a` has an integer dtype with a
		    precision less than that of the default platform integer.  In
		    that case, the default platform integer is used.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output
		    but the type will be cast if necessary. See `doc.ufuncs`
		    (Section "Output arguments") for more details.
		
		Returns
		-------
		nancumsum : ndarray.
		    A new array holding the result is returned unless `out` is
		    specified, in which it is returned. The result has the same
		    size as `a`, and the same shape as `a` if `axis` is not None
		    or `a` is a 1-d array.
		
		See Also
		--------
		numpy.cumsum : Cumulative sum across array propagating NaNs.
		isnan : Show which elements are NaN.
		
		Examples
		--------
		>>> np.nancumsum(1)
		array([1])
		>>> np.nancumsum([1])
		array([1])
		>>> np.nancumsum([1, np.nan])
		array([ 1.,  1.])
		>>> a = np.array([[1, 2], [3, np.nan]])
		>>> np.nancumsum(a)
		array([ 1.,  3.,  6.,  6.])
		>>> np.nancumsum(a, axis=0)
		array([[ 1.,  2.],
		       [ 4.,  2.]])
		>>> np.nancumsum(a, axis=1)
		array([[ 1.,  3.],
		       [ 3.,  3.]])
	**/
	static public function nancumsum(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Return the maximum of an array or maximum along an axis, ignoring any
		NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
		raised and NaN is returned for that slice.
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose maximum is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the maximum is computed. The default is to compute
		    the maximum of the flattened array.
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``; if provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.  See
		    `doc.ufuncs` for details.
		
		    .. versionadded:: 1.8.0
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		    If the value is anything but the default, then
		    `keepdims` will be passed through to the `max` method
		    of sub-classes of `ndarray`.  If the sub-classes methods
		    does not implement `keepdims` any exceptions will be raised.
		
		    .. versionadded:: 1.8.0
		
		Returns
		-------
		nanmax : ndarray
		    An array with the same shape as `a`, with the specified axis removed.
		    If `a` is a 0-d array, or if axis is None, an ndarray scalar is
		    returned.  The same dtype as `a` is returned.
		
		See Also
		--------
		nanmin :
		    The minimum value of an array along a given axis, ignoring any NaNs.
		amax :
		    The maximum value of an array along a given axis, propagating any NaNs.
		fmax :
		    Element-wise maximum of two arrays, ignoring any NaNs.
		maximum :
		    Element-wise maximum of two arrays, propagating any NaNs.
		isnan :
		    Shows which elements are Not a Number (NaN).
		isfinite:
		    Shows which elements are neither NaN nor infinity.
		
		amin, fmin, minimum
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754). This means that Not a Number is not equivalent to infinity.
		Positive infinity is treated as a very large number and negative
		infinity is treated as a very small (i.e. negative) number.
		
		If the input has a integer type the function is equivalent to np.max.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, np.nan]])
		>>> np.nanmax(a)
		3.0
		>>> np.nanmax(a, axis=0)
		array([ 3.,  2.])
		>>> np.nanmax(a, axis=1)
		array([ 2.,  3.])
		
		When positive infinity and negative infinity are present:
		
		>>> np.nanmax([1, 2, np.nan, np.NINF])
		2.0
		>>> np.nanmax([1, 2, np.nan, np.inf])
		inf
	**/
	static public function nanmax(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the arithmetic mean along the specified axis, ignoring NaNs.
		
		Returns the average of the array elements.  The average is taken over
		the flattened array by default, otherwise over the specified axis.
		`float64` intermediate and return values are used for integer inputs.
		
		For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.
		
		.. versionadded:: 1.8.0
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose mean is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the means are computed. The default is to compute
		    the mean of the flattened array.
		dtype : data-type, optional
		    Type to use in computing the mean.  For integer inputs, the default
		    is `float64`; for inexact inputs, it is the same as the input
		    dtype.
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``; if provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.  See
		    `doc.ufuncs` for details.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		    If the value is anything but the default, then
		    `keepdims` will be passed through to the `mean` or `sum` methods
		    of sub-classes of `ndarray`.  If the sub-classes methods
		    does not implement `keepdims` any exceptions will be raised.
		
		Returns
		-------
		m : ndarray, see dtype parameter above
		    If `out=None`, returns a new array containing the mean values,
		    otherwise a reference to the output array is returned. Nan is
		    returned for slices that contain only NaNs.
		
		See Also
		--------
		average : Weighted average
		mean : Arithmetic mean taken while not ignoring NaNs
		var, nanvar
		
		Notes
		-----
		The arithmetic mean is the sum of the non-NaN elements along the axis
		divided by the number of non-NaN elements.
		
		Note that for floating-point input, the mean is computed using the same
		precision the input has.  Depending on the input data, this can cause
		the results to be inaccurate, especially for `float32`.  Specifying a
		higher-precision accumulator using the `dtype` keyword can alleviate
		this issue.
		
		Examples
		--------
		>>> a = np.array([[1, np.nan], [3, 4]])
		>>> np.nanmean(a)
		2.6666666666666665
		>>> np.nanmean(a, axis=0)
		array([ 2.,  4.])
		>>> np.nanmean(a, axis=1)
		array([ 1.,  3.5])
	**/
	static public function nanmean(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the median along the specified axis, while ignoring NaNs.
		
		Returns the median of the array elements.
		
		.. versionadded:: 1.9.0
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		axis : {int, sequence of int, None}, optional
		    Axis or axes along which the medians are computed. The default
		    is to compute the median along a flattened version of the array.
		    A sequence of axes is supported since version 1.9.0.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		   If True, then allow use of memory of input array `a` for
		   calculations. The input array will be modified by the call to
		   `median`. This will save memory when you do not need to preserve
		   the contents of the input array. Treat the input as undefined,
		   but it will probably be fully or partially sorted. Default is
		   False. If `overwrite_input` is ``True`` and `a` is not already an
		   `ndarray`, an error will be raised.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		    If this is anything but the default value it will be passed
		    through (in the special case of an empty array) to the
		    `mean` function of the underlying array.  If the array is
		    a sub-class and `mean` does not have the kwarg `keepdims` this
		    will raise a RuntimeError.
		
		Returns
		-------
		median : ndarray
		    A new array holding the result. If the input contains integers
		    or floats smaller than ``float64``, then the output data-type is
		    ``np.float64``.  Otherwise, the data-type of the output is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		mean, median, percentile
		
		Notes
		-----
		Given a vector ``V`` of length ``N``, the median of ``V`` is the
		middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,
		``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two
		middle values of ``V_sorted`` when ``N`` is even.
		
		Examples
		--------
		>>> a = np.array([[10.0, 7, 4], [3, 2, 1]])
		>>> a[0, 1] = np.nan
		>>> a
		array([[ 10.,  nan,   4.],
		   [  3.,   2.,   1.]])
		>>> np.median(a)
		nan
		>>> np.nanmedian(a)
		3.0
		>>> np.nanmedian(a, axis=0)
		array([ 6.5,  2.,  2.5])
		>>> np.median(a, axis=1)
		array([ 7.,  2.])
		>>> b = a.copy()
		>>> np.nanmedian(b, axis=1, overwrite_input=True)
		array([ 7.,  2.])
		>>> assert not np.all(a==b)
		>>> b = a.copy()
		>>> np.nanmedian(b, axis=None, overwrite_input=True)
		3.0
		>>> assert not np.all(a==b)
	**/
	static public function nanmedian(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Return minimum of an array or minimum along an axis, ignoring any NaNs.
		When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
		Nan is returned for that slice.
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose minimum is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the minimum is computed. The default is to compute
		    the minimum of the flattened array.
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``; if provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.  See
		    `doc.ufuncs` for details.
		
		    .. versionadded:: 1.8.0
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		    If the value is anything but the default, then
		    `keepdims` will be passed through to the `min` method
		    of sub-classes of `ndarray`.  If the sub-classes methods
		    does not implement `keepdims` any exceptions will be raised.
		
		    .. versionadded:: 1.8.0
		
		Returns
		-------
		nanmin : ndarray
		    An array with the same shape as `a`, with the specified axis
		    removed.  If `a` is a 0-d array, or if axis is None, an ndarray
		    scalar is returned.  The same dtype as `a` is returned.
		
		See Also
		--------
		nanmax :
		    The maximum value of an array along a given axis, ignoring any NaNs.
		amin :
		    The minimum value of an array along a given axis, propagating any NaNs.
		fmin :
		    Element-wise minimum of two arrays, ignoring any NaNs.
		minimum :
		    Element-wise minimum of two arrays, propagating any NaNs.
		isnan :
		    Shows which elements are Not a Number (NaN).
		isfinite:
		    Shows which elements are neither NaN nor infinity.
		
		amax, fmax, maximum
		
		Notes
		-----
		NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
		(IEEE 754). This means that Not a Number is not equivalent to infinity.
		Positive infinity is treated as a very large number and negative
		infinity is treated as a very small (i.e. negative) number.
		
		If the input has a integer type the function is equivalent to np.min.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, np.nan]])
		>>> np.nanmin(a)
		1.0
		>>> np.nanmin(a, axis=0)
		array([ 1.,  2.])
		>>> np.nanmin(a, axis=1)
		array([ 1.,  3.])
		
		When positive infinity and negative infinity are present:
		
		>>> np.nanmin([1, 2, np.nan, np.inf])
		1.0
		>>> np.nanmin([1, 2, np.nan, np.NINF])
		-inf
	**/
	static public function nanmin(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the qth percentile of the data along the specified axis,
		while ignoring nan values.
		
		Returns the qth percentile(s) of the array elements.
		
		.. versionadded:: 1.9.0
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array, containing
		    nan values to be ignored.
		q : array_like of float
		    Percentile or sequence of percentiles to compute, which must be between
		    0 and 100 inclusive.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the percentiles are computed. The
		    default is to compute the percentile(s) along a flattened
		    version of the array.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		    If True, then allow the input array `a` to be modified by intermediate
		    calculations, to save memory. In this case, the contents of the input
		    `a` after this function completes is undefined.
		interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
		    This optional parameter specifies the interpolation method to
		    use when the desired percentile lies between two data points
		    ``i < j``:
		
		    * 'linear': ``i + (j - i) * fraction``, where ``fraction``
		      is the fractional part of the index surrounded by ``i``
		      and ``j``.
		    * 'lower': ``i``.
		    * 'higher': ``j``.
		    * 'nearest': ``i`` or ``j``, whichever is nearest.
		    * 'midpoint': ``(i + j) / 2``.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left in
		    the result as dimensions with size one. With this option, the
		    result will broadcast correctly against the original array `a`.
		
		    If this is anything but the default value it will be passed
		    through (in the special case of an empty array) to the
		    `mean` function of the underlying array.  If the array is
		    a sub-class and `mean` does not have the kwarg `keepdims` this
		    will raise a RuntimeError.
		
		Returns
		-------
		percentile : scalar or ndarray
		    If `q` is a single percentile and `axis=None`, then the result
		    is a scalar. If multiple percentiles are given, first axis of
		    the result corresponds to the percentiles. The other axes are
		    the axes that remain after the reduction of `a`. If the input
		    contains integers or floats smaller than ``float64``, the output
		    data-type is ``float64``. Otherwise, the output data-type is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		nanmean
		nanmedian : equivalent to ``nanpercentile(..., 50)``
		percentile, median, mean
		nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].
		
		Notes
		-----
		Given a vector ``V`` of length ``N``, the ``q``-th percentile of
		``V`` is the value ``q/100`` of the way from the minimum to the
		maximum in a sorted copy of ``V``. The values and distances of
		the two nearest neighbors as well as the `interpolation` parameter
		will determine the percentile if the normalized ranking does not
		match the location of ``q`` exactly. This function is the same as
		the median if ``q=50``, the same as the minimum if ``q=0`` and the
		same as the maximum if ``q=100``.
		
		Examples
		--------
		>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
		>>> a[0][1] = np.nan
		>>> a
		array([[ 10.,  nan,   4.],
		      [  3.,   2.,   1.]])
		>>> np.percentile(a, 50)
		nan
		>>> np.nanpercentile(a, 50)
		3.5
		>>> np.nanpercentile(a, 50, axis=0)
		array([ 6.5,  2.,   2.5])
		>>> np.nanpercentile(a, 50, axis=1, keepdims=True)
		array([[ 7.],
		       [ 2.]])
		>>> m = np.nanpercentile(a, 50, axis=0)
		>>> out = np.zeros_like(m)
		>>> np.nanpercentile(a, 50, axis=0, out=out)
		array([ 6.5,  2.,   2.5])
		>>> m
		array([ 6.5,  2. ,  2.5])
		
		>>> b = a.copy()
		>>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)
		array([  7.,  2.])
		>>> assert not np.all(a==b)
	**/
	static public function nanpercentile(a:Dynamic, q:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?interpolation:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Return the product of array elements over a given axis treating Not a
		Numbers (NaNs) as ones.
		
		One is returned for slices that are all-NaN or empty.
		
		.. versionadded:: 1.10.0
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose product is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the product is computed. The default is to compute
		    the product of the flattened array.
		dtype : data-type, optional
		    The type of the returned array and of the accumulator in which the
		    elements are summed.  By default, the dtype of `a` is used.  An
		    exception is when `a` has an integer type with less precision than
		    the platform (u)intp. In that case, the default will be either
		    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
		    bits. For inexact inputs, dtype must be inexact.
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``. If provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.  See
		    `doc.ufuncs` for details. The casting of NaN to integer can yield
		    unexpected results.
		keepdims : bool, optional
		    If True, the axes which are reduced are left in the result as
		    dimensions with size one. With this option, the result will
		    broadcast correctly against the original `arr`.
		
		Returns
		-------
		nanprod : ndarray
		    A new array holding the result is returned unless `out` is
		    specified, in which case it is returned.
		
		See Also
		--------
		numpy.prod : Product across array propagating NaNs.
		isnan : Show which elements are NaN.
		
		Examples
		--------
		>>> np.nanprod(1)
		1
		>>> np.nanprod([1])
		1
		>>> np.nanprod([1, np.nan])
		1.0
		>>> a = np.array([[1, 2], [3, np.nan]])
		>>> np.nanprod(a)
		6.0
		>>> np.nanprod(a, axis=0)
		array([ 3.,  2.])
	**/
	static public function nanprod(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the qth quantile of the data along the specified axis,
		while ignoring nan values.
		Returns the qth quantile(s) of the array elements.
		.. versionadded:: 1.15.0
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array, containing
		    nan values to be ignored
		q : array_like of float
		    Quantile or sequence of quantiles to compute, which must be between
		    0 and 1 inclusive.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the quantiles are computed. The
		    default is to compute the quantile(s) along a flattened
		    version of the array.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		    If True, then allow the input array `a` to be modified by intermediate
		    calculations, to save memory. In this case, the contents of the input
		    `a` after this function completes is undefined.
		interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
		    This optional parameter specifies the interpolation method to
		    use when the desired quantile lies between two data points
		    ``i < j``:
		
		    * linear: ``i + (j - i) * fraction``, where ``fraction``
		      is the fractional part of the index surrounded by ``i``
		      and ``j``.
		    * lower: ``i``.
		    * higher: ``j``.
		    * nearest: ``i`` or ``j``, whichever is nearest.
		    * midpoint: ``(i + j) / 2``.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left in
		    the result as dimensions with size one. With this option, the
		    result will broadcast correctly against the original array `a`.
		
		    If this is anything but the default value it will be passed
		    through (in the special case of an empty array) to the
		    `mean` function of the underlying array.  If the array is
		    a sub-class and `mean` does not have the kwarg `keepdims` this
		    will raise a RuntimeError.
		
		Returns
		-------
		quantile : scalar or ndarray
		    If `q` is a single percentile and `axis=None`, then the result
		    is a scalar. If multiple quantiles are given, first axis of
		    the result corresponds to the quantiles. The other axes are
		    the axes that remain after the reduction of `a`. If the input
		    contains integers or floats smaller than ``float64``, the output
		    data-type is ``float64``. Otherwise, the output data-type is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		quantile
		nanmean, nanmedian
		nanmedian : equivalent to ``nanquantile(..., 0.5)``
		nanpercentile : same as nanquantile, but with q in the range [0, 100].
		
		Examples
		--------
		>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
		>>> a[0][1] = np.nan
		>>> a
		array([[ 10.,  nan,   4.],
		      [  3.,   2.,   1.]])
		>>> np.quantile(a, 0.5)
		nan
		>>> np.nanquantile(a, 0.5)
		3.5
		>>> np.nanquantile(a, 0.5, axis=0)
		array([ 6.5,  2.,   2.5])
		>>> np.nanquantile(a, 0.5, axis=1, keepdims=True)
		array([[ 7.],
		       [ 2.]])
		>>> m = np.nanquantile(a, 0.5, axis=0)
		>>> out = np.zeros_like(m)
		>>> np.nanquantile(a, 0.5, axis=0, out=out)
		array([ 6.5,  2.,   2.5])
		>>> m
		array([ 6.5,  2. ,  2.5])
		>>> b = a.copy()
		>>> np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
		array([  7.,  2.])
		>>> assert not np.all(a==b)
	**/
	static public function nanquantile(a:Dynamic, q:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?interpolation:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the standard deviation along the specified axis, while
		ignoring NaNs.
		
		Returns the standard deviation, a measure of the spread of a
		distribution, of the non-NaN array elements. The standard deviation is
		computed for the flattened array by default, otherwise over the
		specified axis.
		
		For all-NaN slices or slices with zero degrees of freedom, NaN is
		returned and a `RuntimeWarning` is raised.
		
		.. versionadded:: 1.8.0
		
		Parameters
		----------
		a : array_like
		    Calculate the standard deviation of the non-NaN values.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the standard deviation is computed. The default is
		    to compute the standard deviation of the flattened array.
		dtype : dtype, optional
		    Type to use in computing the standard deviation. For arrays of
		    integer type the default is float64, for arrays of float types it
		    is the same as the array type.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must have
		    the same shape as the expected output but the type (of the
		    calculated values) will be cast if necessary.
		ddof : int, optional
		    Means Delta Degrees of Freedom.  The divisor used in calculations
		    is ``N - ddof``, where ``N`` represents the number of non-NaN
		    elements.  By default `ddof` is zero.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		    If this value is anything but the default it is passed through
		    as-is to the relevant functions of the sub-classes.  If these
		    functions do not have a `keepdims` kwarg, a RuntimeError will
		    be raised.
		
		Returns
		-------
		standard_deviation : ndarray, see dtype parameter above.
		    If `out` is None, return a new array containing the standard
		    deviation, otherwise return a reference to the output array. If
		    ddof is >= the number of non-NaN elements in a slice or the slice
		    contains only NaNs, then the result for that slice is NaN.
		
		See Also
		--------
		var, mean, std
		nanvar, nanmean
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		The standard deviation is the square root of the average of the squared
		deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.
		
		The average squared deviation is normally calculated as
		``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
		specified, the divisor ``N - ddof`` is used instead. In standard
		statistical practice, ``ddof=1`` provides an unbiased estimator of the
		variance of the infinite population. ``ddof=0`` provides a maximum
		likelihood estimate of the variance for normally distributed variables.
		The standard deviation computed in this function is the square root of
		the estimated variance, so even with ``ddof=1``, it will not be an
		unbiased estimate of the standard deviation per se.
		
		Note that, for complex numbers, `std` takes the absolute value before
		squaring, so that the result is always real and nonnegative.
		
		For floating-point input, the *std* is computed using the same
		precision the input has. Depending on the input data, this can cause
		the results to be inaccurate, especially for float32 (see example
		below).  Specifying a higher-accuracy accumulator using the `dtype`
		keyword can alleviate this issue.
		
		Examples
		--------
		>>> a = np.array([[1, np.nan], [3, 4]])
		>>> np.nanstd(a)
		1.247219128924647
		>>> np.nanstd(a, axis=0)
		array([ 1.,  0.])
		>>> np.nanstd(a, axis=1)
		array([ 0.,  0.5])
	**/
	static public function nanstd(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?ddof:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Return the sum of array elements over a given axis treating Not a
		Numbers (NaNs) as zero.
		
		In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or
		empty. In later versions zero is returned.
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose sum is desired. If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the sum is computed. The default is to compute the
		    sum of the flattened array.
		dtype : data-type, optional
		    The type of the returned array and of the accumulator in which the
		    elements are summed.  By default, the dtype of `a` is used.  An
		    exception is when `a` has an integer type with less precision than
		    the platform (u)intp. In that case, the default will be either
		    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
		    bits. For inexact inputs, dtype must be inexact.
		
		    .. versionadded:: 1.8.0
		out : ndarray, optional
		    Alternate output array in which to place the result.  The default
		    is ``None``. If provided, it must have the same shape as the
		    expected output, but the type will be cast if necessary.  See
		    `doc.ufuncs` for details. The casting of NaN to integer can yield
		    unexpected results.
		
		    .. versionadded:: 1.8.0
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		
		    If the value is anything but the default, then
		    `keepdims` will be passed through to the `mean` or `sum` methods
		    of sub-classes of `ndarray`.  If the sub-classes methods
		    does not implement `keepdims` any exceptions will be raised.
		
		    .. versionadded:: 1.8.0
		
		Returns
		-------
		nansum : ndarray.
		    A new array holding the result is returned unless `out` is
		    specified, in which it is returned. The result has the same
		    size as `a`, and the same shape as `a` if `axis` is not None
		    or `a` is a 1-d array.
		
		See Also
		--------
		numpy.sum : Sum across array propagating NaNs.
		isnan : Show which elements are NaN.
		isfinite: Show which elements are not NaN or +/-inf.
		
		Notes
		-----
		If both positive and negative infinity are present, the sum will be Not
		A Number (NaN).
		
		Examples
		--------
		>>> np.nansum(1)
		1
		>>> np.nansum([1])
		1
		>>> np.nansum([1, np.nan])
		1.0
		>>> a = np.array([[1, 1], [1, np.nan]])
		>>> np.nansum(a)
		3.0
		>>> np.nansum(a, axis=0)
		array([ 2.,  1.])
		>>> np.nansum([1, np.nan, np.inf])
		inf
		>>> np.nansum([1, np.nan, np.NINF])
		-inf
		>>> np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
		nan
	**/
	static public function nansum(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Compute the variance along the specified axis, while ignoring NaNs.
		
		Returns the variance of the array elements, a measure of the spread of
		a distribution.  The variance is computed for the flattened array by
		default, otherwise over the specified axis.
		
		For all-NaN slices or slices with zero degrees of freedom, NaN is
		returned and a `RuntimeWarning` is raised.
		
		.. versionadded:: 1.8.0
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose variance is desired.  If `a` is not an
		    array, a conversion is attempted.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the variance is computed.  The default is to compute
		    the variance of the flattened array.
		dtype : data-type, optional
		    Type to use in computing the variance.  For arrays of integer type
		    the default is `float32`; for arrays of float types it is the same as
		    the array type.
		out : ndarray, optional
		    Alternate output array in which to place the result.  It must have
		    the same shape as the expected output, but the type is cast if
		    necessary.
		ddof : int, optional
		    "Delta Degrees of Freedom": the divisor used in the calculation is
		    ``N - ddof``, where ``N`` represents the number of non-NaN
		    elements. By default `ddof` is zero.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the original `a`.
		
		
		Returns
		-------
		variance : ndarray, see dtype parameter above
		    If `out` is None, return a new array containing the variance,
		    otherwise return a reference to the output array. If ddof is >= the
		    number of non-NaN elements in a slice or the slice contains only
		    NaNs, then the result for that slice is NaN.
		
		See Also
		--------
		std : Standard deviation
		mean : Average
		var : Variance while not ignoring NaNs
		nanstd, nanmean
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		The variance is the average of the squared deviations from the mean,
		i.e.,  ``var = mean(abs(x - x.mean())**2)``.
		
		The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
		If, however, `ddof` is specified, the divisor ``N - ddof`` is used
		instead.  In standard statistical practice, ``ddof=1`` provides an
		unbiased estimator of the variance of a hypothetical infinite
		population.  ``ddof=0`` provides a maximum likelihood estimate of the
		variance for normally distributed variables.
		
		Note that for complex numbers, the absolute value is taken before
		squaring, so that the result is always real and nonnegative.
		
		For floating-point input, the variance is computed using the same
		precision the input has.  Depending on the input data, this can cause
		the results to be inaccurate, especially for `float32` (see example
		below).  Specifying a higher-accuracy accumulator using the ``dtype``
		keyword can alleviate this issue.
		
		For this function to work on sub-classes of ndarray, they must define
		`sum` with the kwarg `keepdims`
		
		Examples
		--------
		>>> a = np.array([[1, np.nan], [3, 4]])
		>>> np.var(a)
		1.5555555555555554
		>>> np.nanvar(a, axis=0)
		array([ 1.,  0.])
		>>> np.nanvar(a, axis=1)
		array([ 0.,  0.25])
	**/
	static public function nanvar(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?ddof:Dynamic, ?keepdims:Dynamic):Dynamic;
	static public var nbytes : Dynamic;
	/**
		Load ASCII data stored in a file and return it as a single array.
		
		Parameters
		----------
		fname, kwargs : For a description of input parameters, see `genfromtxt`.
		
		See Also
		--------
		numpy.genfromtxt : generic function.
	**/
	static public function ndfromtxt(fname:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the number of dimensions of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.  If it is not already an ndarray, a conversion is
		    attempted.
		
		Returns
		-------
		number_of_dimensions : int
		    The number of dimensions in `a`.  Scalars are zero-dimensional.
		
		See Also
		--------
		ndarray.ndim : equivalent method
		shape : dimensions of array
		ndarray.shape : dimensions of array
		
		Examples
		--------
		>>> np.ndim([[1,2,3],[4,5,6]])
		2
		>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
		2
		>>> np.ndim(1)
		0
	**/
	static public function ndim(a:Dynamic):Int;
	/**
		negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Numerical negative, element-wise.
		
		Parameters
		----------
		x : array_like or scalar
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    Returned array or scalar: `y = -x`.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> np.negative([1.,-1.])
		array([-1.,  1.])
	**/
	static public function negative(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		negative_binomial(n, p, size=None)
		
		Draw samples from a negative binomial distribution.
		
		Samples are drawn from a negative binomial distribution with specified
		parameters, `n` successes and `p` probability of success where `n` is an
		integer > 0 and `p` is in the interval [0, 1].
		
		Parameters
		----------
		n : int or array_like of ints
		    Parameter of the distribution, > 0. Floats are also accepted,
		    but they will be truncated to integers.
		p : float or array_like of floats
		    Parameter of the distribution, >= 0 and <=1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``n`` and ``p`` are both scalars.
		    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized negative binomial distribution,
		    where each sample is equal to N, the number of failures that
		    occurred before a total of n successes was reached.
		
		Notes
		-----
		The probability density for the negative binomial distribution is
		
		.. math:: P(N;n,p) = \binom{N+n-1}{N}p^{n}(1-p)^{N},
		
		where :math:`n` is the number of successes, :math:`p` is the
		probability of success, and :math:`N+n` is the number of trials.
		The negative binomial distribution gives the probability of N
		failures given n successes, with a success on the last trial.
		
		If one throws a die repeatedly until the third time a "1" appears,
		then the probability distribution of the number of non-"1"s that
		appear before the third "1" is a negative binomial distribution.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Negative Binomial Distribution." From
		       MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/NegativeBinomialDistribution.html
		.. [2] Wikipedia, "Negative binomial distribution",
		       https://en.wikipedia.org/wiki/Negative_binomial_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		A real world example. A company drills wild-cat oil
		exploration wells, each with an estimated probability of
		success of 0.1.  What is the probability of having one success
		for each successive well, that is what is the probability of a
		single success after drilling 5 wells, after 6 wells, etc.?
		
		>>> s = np.random.negative_binomial(1, 0.1, 100000)
		>>> for i in range(1, 11):
		...    probability = sum(s<i) / 100000.
		...    print i, "wells drilled, probability of one success =", probability
	**/
	static public function negative_binomial(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Create nditers for use in nested loops
		
		Create a tuple of `nditer` objects which iterate in nested loops over
		different axes of the op argument. The first iterator is used in the
		outermost loop, the last in the innermost loop. Advancing one will change
		the subsequent iterators to point at its new element.
		
		Parameters
		----------
		op : ndarray or sequence of array_like
		    The array(s) to iterate over.
		
		axes : list of list of int
		    Each item is used as an "op_axes" argument to an nditer
		
		flags, op_flags, op_dtypes, order, casting, buffersize (optional)
		    See `nditer` parameters of the same name
		
		Returns
		-------
		iters : tuple of nditer
		    An nditer for each item in `axes`, outermost first
		
		See Also
		--------
		nditer
		
		Examples
		--------
		
		Basic usage. Note how y is the "flattened" version of
		[a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
		the first iter's axes as [1]
		
		>>> a = np.arange(12).reshape(2, 3, 2)
		>>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])
		>>> for x in i:
		...      print(i.multi_index)
		...      for y in j:
		...          print('', j.multi_index, y)
		
		(0,)
		 (0, 0) 0
		 (0, 1) 1
		 (1, 0) 6
		 (1, 1) 7
		(1,)
		 (0, 0) 2
		 (0, 1) 3
		 (1, 0) 8
		 (1, 1) 9
		(2,)
		 (0, 0) 4
		 (0, 1) 5
		 (1, 0) 10
		 (1, 1) 11
	**/
	static public function nested_iters(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Create a new figure manager instance.
		        
	**/
	static public function new_figure_manager(num:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var newaxis : Dynamic;
	/**
		nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the next floating-point value after x1 towards x2, element-wise.
		
		Parameters
		----------
		x1 : array_like
		    Values to find the next representable value of.
		x2 : array_like
		    The direction where to look for the next representable value of `x1`.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    The next representable values of `x1` in the direction of `x2`.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Examples
		--------
		>>> eps = np.finfo(np.float64).eps
		>>> np.nextafter(1, 2) == eps + 1
		True
		>>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]
		array([ True,  True])
	**/
	static public function nextafter(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set the colormap to "nipy_spectral".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function nipy_spectral():Dynamic;
	/**
		noncentral_chisquare(df, nonc, size=None)
		
		Draw samples from a noncentral chi-square distribution.
		
		The noncentral :math:`\chi^2` distribution is a generalisation of
		the :math:`\chi^2` distribution.
		
		Parameters
		----------
		df : float or array_like of floats
		    Degrees of freedom, should be > 0.
		
		    .. versionchanged:: 1.10.0
		       Earlier NumPy versions required dfnum > 1.
		nonc : float or array_like of floats
		    Non-centrality, should be non-negative.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``df`` and ``nonc`` are both scalars.
		    Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized noncentral chi-square distribution.
		
		Notes
		-----
		The probability density function for the noncentral Chi-square
		distribution is
		
		.. math:: P(x;df,nonc) = \sum^{\infty}_{i=0}
		                       \frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
		                       \P_{Y_{df+2i}}(x),
		
		where :math:`Y_{q}` is the Chi-square with q degrees of freedom.
		
		In Delhi (2007), it is noted that the noncentral chi-square is
		useful in bombing and coverage problems, the probability of
		killing the point target given by the noncentral chi-squared
		distribution.
		
		References
		----------
		.. [1] Delhi, M.S. Holla, "On a noncentral chi-square distribution in
		       the analysis of weapon systems effectiveness", Metrika,
		       Volume 15, Number 1 / December, 1970.
		.. [2] Wikipedia, "Noncentral chi-squared distribution"
		       https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution
		
		Examples
		--------
		Draw values from the distribution and plot the histogram
		
		>>> import matplotlib.pyplot as plt
		>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
		...                   bins=200, density=True)
		>>> plt.show()
		
		Draw values from a noncentral chisquare with very small noncentrality,
		and compare to a chisquare.
		
		>>> plt.figure()
		>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
		...                   bins=np.arange(0., 25, .1), density=True)
		>>> values2 = plt.hist(np.random.chisquare(3, 100000),
		...                    bins=np.arange(0., 25, .1), density=True)
		>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
		>>> plt.show()
		
		Demonstrate how large values of non-centrality lead to a more symmetric
		distribution.
		
		>>> plt.figure()
		>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
		...                   bins=200, density=True)
		>>> plt.show()
	**/
	static public function noncentral_chisquare(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		noncentral_f(dfnum, dfden, nonc, size=None)
		
		Draw samples from the noncentral F distribution.
		
		Samples are drawn from an F distribution with specified parameters,
		`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
		freedom in denominator), where both parameters > 1.
		`nonc` is the non-centrality parameter.
		
		Parameters
		----------
		dfnum : float or array_like of floats
		    Numerator degrees of freedom, should be > 0.
		
		    .. versionchanged:: 1.14.0
		       Earlier NumPy versions required dfnum > 1.
		dfden : float or array_like of floats
		    Denominator degrees of freedom, should be > 0.
		nonc : float or array_like of floats
		    Non-centrality parameter, the sum of the squares of the numerator
		    means, should be >= 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``dfnum``, ``dfden``, and ``nonc``
		    are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``
		    samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized noncentral Fisher distribution.
		
		Notes
		-----
		When calculating the power of an experiment (power = probability of
		rejecting the null hypothesis when a specific alternative is true) the
		non-central F statistic becomes important.  When the null hypothesis is
		true, the F statistic follows a central F distribution. When the null
		hypothesis is not true, then it follows a non-central F statistic.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Noncentral F-Distribution."
		       From MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/NoncentralF-Distribution.html
		.. [2] Wikipedia, "Noncentral F-distribution",
		       https://en.wikipedia.org/wiki/Noncentral_F-distribution
		
		Examples
		--------
		In a study, testing for a specific alternative to the null hypothesis
		requires use of the Noncentral F distribution. We need to calculate the
		area in the tail of the distribution that exceeds the value of the F
		distribution for the null hypothesis.  We'll plot the two probability
		distributions for comparison.
		
		>>> dfnum = 3 # between group deg of freedom
		>>> dfden = 20 # within groups degrees of freedom
		>>> nonc = 3.0
		>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
		>>> NF = np.histogram(nc_vals, bins=50, density=True)
		>>> c_vals = np.random.f(dfnum, dfden, 1000000)
		>>> F = np.histogram(c_vals, bins=50, density=True)
		>>> import matplotlib.pyplot as plt
		>>> plt.plot(F[1][1:], F[0])
		>>> plt.plot(NF[1][1:], NF[0])
		>>> plt.show()
	**/
	static public function noncentral_f(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the indices of the elements that are non-zero.
		
		Returns a tuple of arrays, one for each dimension of `a`,
		containing the indices of the non-zero elements in that
		dimension. The values in `a` are always tested and returned in
		row-major, C-style order. The corresponding non-zero
		values can be obtained with::
		
		    a[nonzero(a)]
		
		To group the indices by element, rather than dimension, use::
		
		    transpose(nonzero(a))
		
		The result of this is always a 2-D array, with a row for
		each non-zero element.
		
		Parameters
		----------
		a : array_like
		    Input array.
		
		Returns
		-------
		tuple_of_arrays : tuple
		    Indices of elements that are non-zero.
		
		See Also
		--------
		flatnonzero :
		    Return indices that are non-zero in the flattened version of the input
		    array.
		ndarray.nonzero :
		    Equivalent ndarray method.
		count_nonzero :
		    Counts the number of non-zero elements in the input array.
		
		Examples
		--------
		>>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
		>>> x
		array([[3, 0, 0],
		       [0, 4, 0],
		       [5, 6, 0]])
		>>> np.nonzero(x)
		(array([0, 1, 2, 2]), array([0, 1, 0, 1]))
		
		>>> x[np.nonzero(x)]
		array([3, 4, 5, 6])
		>>> np.transpose(np.nonzero(x))
		array([[0, 0],
		       [1, 1],
		       [2, 0],
		       [2, 1])
		
		A common use for ``nonzero`` is to find the indices of an array, where
		a condition is True.  Given an array `a`, the condition `a` > 3 is a
		boolean array and since False is interpreted as 0, np.nonzero(a > 3)
		yields the indices of the `a` where the condition is true.
		
		>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
		>>> a > 3
		array([[False, False, False],
		       [ True,  True,  True],
		       [ True,  True,  True]])
		>>> np.nonzero(a > 3)
		(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
		
		Using this result to index `a` is equivalent to using the mask directly:
		
		>>> a[np.nonzero(a > 3)]
		array([4, 5, 6, 7, 8, 9])
		>>> a[a > 3]  # prefer this spelling
		array([4, 5, 6, 7, 8, 9])
		
		``nonzero`` can also be called as a method of the array.
		
		>>> (a > 3).nonzero()
		(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
	**/
	static public function nonzero(a:Dynamic):python.Tuple<Dynamic>;
	/**
		Matrix or vector norm.
		
		This function is able to return one of eight different matrix norms,
		or one of an infinite number of vector norms (described below), depending
		on the value of the ``ord`` parameter.
		
		Parameters
		----------
		x : array_like
		    Input array.  If `axis` is None, `x` must be 1-D or 2-D.
		ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
		    Order of the norm (see table under ``Notes``). inf means numpy's
		    `inf` object.
		axis : {int, 2-tuple of ints, None}, optional
		    If `axis` is an integer, it specifies the axis of `x` along which to
		    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
		    axes that hold 2-D matrices, and the matrix norms of these matrices
		    are computed.  If `axis` is None then either a vector norm (when `x`
		    is 1-D) or a matrix norm (when `x` is 2-D) is returned.
		
		    .. versionadded:: 1.8.0
		
		keepdims : bool, optional
		    If this is set to True, the axes which are normed over are left in the
		    result as dimensions with size one.  With this option the result will
		    broadcast correctly against the original `x`.
		
		    .. versionadded:: 1.10.0
		
		Returns
		-------
		n : float or ndarray
		    Norm of the matrix or vector(s).
		
		Notes
		-----
		For values of ``ord <= 0``, the result is, strictly speaking, not a
		mathematical 'norm', but it may still be useful for various numerical
		purposes.
		
		The following norms can be calculated:
		
		=====  ============================  ==========================
		ord    norm for matrices             norm for vectors
		=====  ============================  ==========================
		None   Frobenius norm                2-norm
		'fro'  Frobenius norm                --
		'nuc'  nuclear norm                  --
		inf    max(sum(abs(x), axis=1))      max(abs(x))
		-inf   min(sum(abs(x), axis=1))      min(abs(x))
		0      --                            sum(x != 0)
		1      max(sum(abs(x), axis=0))      as below
		-1     min(sum(abs(x), axis=0))      as below
		2      2-norm (largest sing. value)  as below
		-2     smallest singular value       as below
		other  --                            sum(abs(x)**ord)**(1./ord)
		=====  ============================  ==========================
		
		The Frobenius norm is given by [1]_:
		
		    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
		
		The nuclear norm is the sum of the singular values.
		
		References
		----------
		.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
		       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
		
		Examples
		--------
		>>> from numpy import linalg as LA
		>>> a = np.arange(9) - 4
		>>> a
		array([-4, -3, -2, -1,  0,  1,  2,  3,  4])
		>>> b = a.reshape((3, 3))
		>>> b
		array([[-4, -3, -2],
		       [-1,  0,  1],
		       [ 2,  3,  4]])
		
		>>> LA.norm(a)
		7.745966692414834
		>>> LA.norm(b)
		7.745966692414834
		>>> LA.norm(b, 'fro')
		7.745966692414834
		>>> LA.norm(a, np.inf)
		4.0
		>>> LA.norm(b, np.inf)
		9.0
		>>> LA.norm(a, -np.inf)
		0.0
		>>> LA.norm(b, -np.inf)
		2.0
		
		>>> LA.norm(a, 1)
		20.0
		>>> LA.norm(b, 1)
		7.0
		>>> LA.norm(a, -1)
		-4.6566128774142013e-010
		>>> LA.norm(b, -1)
		6.0
		>>> LA.norm(a, 2)
		7.745966692414834
		>>> LA.norm(b, 2)
		7.3484692283495345
		
		>>> LA.norm(a, -2)
		nan
		>>> LA.norm(b, -2)
		1.8570331885190563e-016
		>>> LA.norm(a, 3)
		5.8480354764257312
		>>> LA.norm(a, -3)
		nan
		
		Using the `axis` argument to compute vector norms:
		
		>>> c = np.array([[ 1, 2, 3],
		...               [-1, 1, 4]])
		>>> LA.norm(c, axis=0)
		array([ 1.41421356,  2.23606798,  5.        ])
		>>> LA.norm(c, axis=1)
		array([ 3.74165739,  4.24264069])
		>>> LA.norm(c, ord=1, axis=1)
		array([ 6.,  6.])
		
		Using the `axis` argument to compute matrix norms:
		
		>>> m = np.arange(8).reshape(2,2,2)
		>>> LA.norm(m, axis=(1,2))
		array([  3.74165739,  11.22497216])
		>>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
		(3.7416573867739413, 11.224972160321824)
	**/
	static public function norm(x:Dynamic, ?ord:Dynamic, ?axis:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		normal(loc=0.0, scale=1.0, size=None)
		
		Draw random samples from a normal (Gaussian) distribution.
		
		The probability density function of the normal distribution, first
		derived by De Moivre and 200 years later by both Gauss and Laplace
		independently [2]_, is often called the bell curve because of
		its characteristic shape (see the example below).
		
		The normal distributions occurs often in nature.  For example, it
		describes the commonly occurring distribution of samples influenced
		by a large number of tiny, random disturbances, each with its own
		unique distribution [2]_.
		
		Parameters
		----------
		loc : float or array_like of floats
		    Mean ("centre") of the distribution.
		scale : float or array_like of floats
		    Standard deviation (spread or "width") of the distribution.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``loc`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized normal distribution.
		
		See Also
		--------
		scipy.stats.norm : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Gaussian distribution is
		
		.. math:: p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
		                 e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },
		
		where :math:`\mu` is the mean and :math:`\sigma` the standard
		deviation. The square of the standard deviation, :math:`\sigma^2`,
		is called the variance.
		
		The function has its peak at the mean, and its "spread" increases with
		the standard deviation (the function reaches 0.607 times its maximum at
		:math:`x + \sigma` and :math:`x - \sigma` [2]_).  This implies that
		`numpy.random.normal` is more likely to return samples lying close to
		the mean, rather than those far away.
		
		References
		----------
		.. [1] Wikipedia, "Normal distribution",
		       https://en.wikipedia.org/wiki/Normal_distribution
		.. [2] P. R. Peebles Jr., "Central Limit Theorem" in "Probability,
		       Random Variables and Random Signal Principles", 4th ed., 2001,
		       pp. 51, 51, 125.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> mu, sigma = 0, 0.1 # mean and standard deviation
		>>> s = np.random.normal(mu, sigma, 1000)
		
		Verify the mean and the variance:
		
		>>> abs(mu - np.mean(s)) < 0.01
		True
		
		>>> abs(sigma - np.std(s, ddof=1)) < 0.01
		True
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 30, density=True)
		>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
		...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
		...          linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function normal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return (x1 != x2) element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    Input arrays.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array, element-wise comparison of `x1` and `x2`.
		    Typically of type bool, unless ``dtype=object`` is passed.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		equal, greater, greater_equal, less, less_equal
		
		Examples
		--------
		>>> np.not_equal([1.,2.], [1., 3.])
		array([False,  True])
		>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
		array([[False,  True],
		       [False,  True]])
	**/
	static public function not_equal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the number of periodic payments.
		
		:class:`decimal.Decimal` type is not supported.
		
		Parameters
		----------
		rate : array_like
		    Rate of interest (per period)
		pmt : array_like
		    Payment
		pv : array_like
		    Present value
		fv : array_like, optional
		    Future value
		when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
		    When payments are due ('begin' (1) or 'end' (0))
		
		Notes
		-----
		The number of periods ``nper`` is computed by solving the equation::
		
		 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0
		
		but if ``rate = 0`` then::
		
		 fv + pv + pmt*nper = 0
		
		Examples
		--------
		If you only had $150/month to pay towards the loan, how long would it take
		to pay-off a loan of $8,000 at 7% annual interest?
		
		>>> print(round(np.nper(0.07/12, -150, 8000), 5))
		64.07335
		
		So, over 64 months would be required to pay off the loan.
		
		The same analysis could be done with several different interest rates
		and/or payments and/or total amounts to produce an entire table.
		
		>>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,
		...                    -150   : -99     : 50    ,
		...                    8000   : 9001    : 1000]))
		array([[[  64.07334877,   74.06368256],
		        [ 108.07548412,  127.99022654]],
		       [[  66.12443902,   76.87897353],
		        [ 114.70165583,  137.90124779]]])
	**/
	static public function nper(rate:Dynamic, pmt:Dynamic, pv:Dynamic, ?fv:Dynamic, ?when:Dynamic):Dynamic;
	/**
		Returns the NPV (Net Present Value) of a cash flow series.
		
		Parameters
		----------
		rate : scalar
		    The discount rate.
		values : array_like, shape(M, )
		    The values of the time series of cash flows.  The (fixed) time
		    interval between cash flow "events" must be the same as that for
		    which `rate` is given (i.e., if `rate` is per year, then precisely
		    a year is understood to elapse between each cash flow event).  By
		    convention, investments or "deposits" are negative, income or
		    "withdrawals" are positive; `values` must begin with the initial
		    investment, thus `values[0]` will typically be negative.
		
		Returns
		-------
		out : float
		    The NPV of the input cash flow series `values` at the discount
		    `rate`.
		
		Notes
		-----
		Returns the result of: [G]_
		
		.. math :: \sum_{t=0}^{M-1}{\frac{values_t}{(1+rate)^{t}}}
		
		References
		----------
		.. [G] L. J. Gitman, "Principles of Managerial Finance, Brief," 3rd ed.,
		   Addison-Wesley, 2003, pg. 346.
		
		Examples
		--------
		>>> np.npv(0.281,[-100, 39, 59, 55, 20])
		-0.0084785916384548798
		
		(Compare with the Example given for numpy.lib.financial.irr)
	**/
	static public function npv(rate:Dynamic, values:Dynamic):Float;
	/**
		Convert Matplotlib dates to `~datetime.datetime` objects.
		
		Parameters
		----------
		x : float or sequence of floats
		    Number of days (fraction part represents hours, minutes, seconds)
		    since 0001-01-01 00:00:00 UTC, plus one.
		tz : string, optional
		    Timezone of *x* (defaults to rcparams ``timezone``).
		
		Returns
		-------
		`~datetime.datetime` or sequence of `~datetime.datetime`
		    Dates are returned in timezone *tz*.
		
		    If *x* is a sequence, a sequence of :class:`datetime` objects will
		    be returned.
		
		Notes
		-----
		The addition of one here is a historical artifact. Also, note that the
		Gregorian calendar is assumed; this is not universal practice.
		For details, see the module docstring.
	**/
	static public function num2date(x:Dynamic, ?tz:Dynamic):Dynamic;
	/**
		Convert days since 0001 to epoch.  *d* can be a number or sequence.
	**/
	static public function num2epoch(d:Dynamic):Dynamic;
	/**
		Return the scalar dtype or NumPy equivalent of Python type of an object.
		
		Parameters
		----------
		rep : any
		    The object of which the type is returned.
		default : any, optional
		    If given, this is returned for objects whose types can not be
		    determined. If not given, None is returned for those objects.
		
		Returns
		-------
		dtype : dtype or Python type
		    The data type of `rep`.
		
		See Also
		--------
		sctype2char, issctype, issubsctype, issubdtype, maximum_sctype
		
		Examples
		--------
		>>> np.obj2sctype(np.int32)
		<type 'numpy.int32'>
		>>> np.obj2sctype(np.array([1., 2.]))
		<type 'numpy.float64'>
		>>> np.obj2sctype(np.array([1.j]))
		<type 'numpy.complex128'>
		
		>>> np.obj2sctype(dict)
		<type 'numpy.object_'>
		>>> np.obj2sctype('string')
		<type 'numpy.string_'>
		
		>>> np.obj2sctype(1, default=list)
		<type 'list'>
	**/
	static public function obj2sctype(rep:Dynamic, ?_default:Dynamic):Dynamic;
	static public var ogrid : Dynamic;
	/**
		Return a new array of given shape and type, filled with ones.
		
		Parameters
		----------
		shape : int or sequence of ints
		    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
		dtype : data-type, optional
		    The desired data-type for the array, e.g., `numpy.int8`.  Default is
		    `numpy.float64`.
		order : {'C', 'F'}, optional, default: C
		    Whether to store multi-dimensional data in row-major
		    (C-style) or column-major (Fortran-style) order in
		    memory.
		
		Returns
		-------
		out : ndarray
		    Array of ones with the given shape, dtype, and order.
		
		See Also
		--------
		ones_like : Return an array of ones with shape and type of input.
		empty : Return a new uninitialized array.
		zeros : Return a new array setting values to zero.
		full : Return a new array of given shape filled with value.
		
		
		Examples
		--------
		>>> np.ones(5)
		array([ 1.,  1.,  1.,  1.,  1.])
		
		>>> np.ones((5,), dtype=int)
		array([1, 1, 1, 1, 1])
		
		>>> np.ones((2, 1))
		array([[ 1.],
		       [ 1.]])
		
		>>> s = (2,2)
		>>> np.ones(s)
		array([[ 1.,  1.],
		       [ 1.,  1.]])
	**/
	static public function ones(shape:Dynamic, ?dtype:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Return an array of ones with the same shape and type as a given array.
		
		Parameters
		----------
		a : array_like
		    The shape and data-type of `a` define these same attributes of
		    the returned array.
		dtype : data-type, optional
		    Overrides the data type of the result.
		
		    .. versionadded:: 1.6.0
		order : {'C', 'F', 'A', or 'K'}, optional
		    Overrides the memory layout of the result. 'C' means C-order,
		    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
		    'C' otherwise. 'K' means match the layout of `a` as closely
		    as possible.
		
		    .. versionadded:: 1.6.0
		subok : bool, optional.
		    If True, then the newly created array will use the sub-class
		    type of 'a', otherwise it will be a base-class array. Defaults
		    to True.
		
		Returns
		-------
		out : ndarray
		    Array of ones with the same shape and type as `a`.
		
		See Also
		--------
		empty_like : Return an empty array with shape and type of input.
		zeros_like : Return an array of zeros with shape and type of input.
		full_like : Return a new array with shape of input filled with value.
		ones : Return a new array setting values to one.
		
		Examples
		--------
		>>> x = np.arange(6)
		>>> x = x.reshape((2, 3))
		>>> x
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.ones_like(x)
		array([[1, 1, 1],
		       [1, 1, 1]])
		
		>>> y = np.arange(3, dtype=float)
		>>> y
		array([ 0.,  1.,  2.])
		>>> np.ones_like(y)
		array([ 1.,  1.,  1.])
	**/
	static public function ones_like(a:Dynamic, ?dtype:Dynamic, ?order:Dynamic, ?subok:Dynamic):Dynamic;
	/**
		Compute the outer product of two vectors.
		
		Given two vectors, ``a = [a0, a1, ..., aM]`` and
		``b = [b0, b1, ..., bN]``,
		the outer product [1]_ is::
		
		  [[a0*b0  a0*b1 ... a0*bN ]
		   [a1*b0    .
		   [ ...          .
		   [aM*b0            aM*bN ]]
		
		Parameters
		----------
		a : (M,) array_like
		    First input vector.  Input is flattened if
		    not already 1-dimensional.
		b : (N,) array_like
		    Second input vector.  Input is flattened if
		    not already 1-dimensional.
		out : (M, N) ndarray, optional
		    A location where the result is stored
		
		    .. versionadded:: 1.9.0
		
		Returns
		-------
		out : (M, N) ndarray
		    ``out[i, j] = a[i] * b[j]``
		
		See also
		--------
		inner
		einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
		ufunc.outer : A generalization to N dimensions and other operations.
		              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.
		
		References
		----------
		.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
		         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
		         pg. 8.
		
		Examples
		--------
		Make a (*very* coarse) grid for computing a Mandelbrot set:
		
		>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
		>>> rl
		array([[-2., -1.,  0.,  1.,  2.],
		       [-2., -1.,  0.,  1.,  2.],
		       [-2., -1.,  0.,  1.,  2.],
		       [-2., -1.,  0.,  1.,  2.],
		       [-2., -1.,  0.,  1.,  2.]])
		>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
		>>> im
		array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
		       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
		       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
		       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
		       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
		>>> grid = rl + im
		>>> grid
		array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
		       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
		       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
		       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
		       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
		
		An example using a "vector" of letters:
		
		>>> x = np.array(['a', 'b', 'c'], dtype=object)
		>>> np.outer(x, [1, 2, 3])
		array([[a, aa, aaa],
		       [b, bb, bbb],
		       [c, cc, ccc]], dtype=object)
	**/
	static public function outer(a:Dynamic, b:Dynamic, ?out:Dynamic):Dynamic;
	/**
		packbits(myarray, axis=None)
		
		Packs the elements of a binary-valued array into bits in a uint8 array.
		
		The result is padded to full bytes by inserting zero bits at the end.
		
		Parameters
		----------
		myarray : array_like
		    An array of integers or booleans whose elements should be packed to
		    bits.
		axis : int, optional
		    The dimension over which bit-packing is done.
		    ``None`` implies packing the flattened array.
		
		Returns
		-------
		packed : ndarray
		    Array of type uint8 whose elements represent bits corresponding to the
		    logical (0 or nonzero) value of the input elements. The shape of
		    `packed` has the same number of dimensions as the input (unless `axis`
		    is None, in which case the output is 1-D).
		
		See Also
		--------
		unpackbits: Unpacks elements of a uint8 array into a binary-valued output
		            array.
		
		Examples
		--------
		>>> a = np.array([[[1,0,1],
		...                [0,1,0]],
		...               [[1,1,0],
		...                [0,0,1]]])
		>>> b = np.packbits(a, axis=-1)
		>>> b
		array([[[160],[64]],[[192],[32]]], dtype=uint8)
		
		Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
		and 32 = 0010 0000.
	**/
	static public function packbits(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Pads an array.
		
		Parameters
		----------
		array : array_like of rank N
		    Input array
		pad_width : {sequence, array_like, int}
		    Number of values padded to the edges of each axis.
		    ((before_1, after_1), ... (before_N, after_N)) unique pad widths
		    for each axis.
		    ((before, after),) yields same before and after pad for each axis.
		    (pad,) or int is a shortcut for before = after = pad width for all
		    axes.
		mode : str or function
		    One of the following string values or a user supplied function.
		
		    'constant'
		        Pads with a constant value.
		    'edge'
		        Pads with the edge values of array.
		    'linear_ramp'
		        Pads with the linear ramp between end_value and the
		        array edge value.
		    'maximum'
		        Pads with the maximum value of all or part of the
		        vector along each axis.
		    'mean'
		        Pads with the mean value of all or part of the
		        vector along each axis.
		    'median'
		        Pads with the median value of all or part of the
		        vector along each axis.
		    'minimum'
		        Pads with the minimum value of all or part of the
		        vector along each axis.
		    'reflect'
		        Pads with the reflection of the vector mirrored on
		        the first and last values of the vector along each
		        axis.
		    'symmetric'
		        Pads with the reflection of the vector mirrored
		        along the edge of the array.
		    'wrap'
		        Pads with the wrap of the vector along the axis.
		        The first values are used to pad the end and the
		        end values are used to pad the beginning.
		    <function>
		        Padding function, see Notes.
		stat_length : sequence or int, optional
		    Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
		    values at edge of each axis used to calculate the statistic value.
		
		    ((before_1, after_1), ... (before_N, after_N)) unique statistic
		    lengths for each axis.
		
		    ((before, after),) yields same before and after statistic lengths
		    for each axis.
		
		    (stat_length,) or int is a shortcut for before = after = statistic
		    length for all axes.
		
		    Default is ``None``, to use the entire axis.
		constant_values : sequence or int, optional
		    Used in 'constant'.  The values to set the padded values for each
		    axis.
		
		    ((before_1, after_1), ... (before_N, after_N)) unique pad constants
		    for each axis.
		
		    ((before, after),) yields same before and after constants for each
		    axis.
		
		    (constant,) or int is a shortcut for before = after = constant for
		    all axes.
		
		    Default is 0.
		end_values : sequence or int, optional
		    Used in 'linear_ramp'.  The values used for the ending value of the
		    linear_ramp and that will form the edge of the padded array.
		
		    ((before_1, after_1), ... (before_N, after_N)) unique end values
		    for each axis.
		
		    ((before, after),) yields same before and after end values for each
		    axis.
		
		    (constant,) or int is a shortcut for before = after = end value for
		    all axes.
		
		    Default is 0.
		reflect_type : {'even', 'odd'}, optional
		    Used in 'reflect', and 'symmetric'.  The 'even' style is the
		    default with an unaltered reflection around the edge value.  For
		    the 'odd' style, the extended part of the array is created by
		    subtracting the reflected values from two times the edge value.
		
		Returns
		-------
		pad : ndarray
		    Padded array of rank equal to `array` with shape increased
		    according to `pad_width`.
		
		Notes
		-----
		.. versionadded:: 1.7.0
		
		For an array with rank greater than 1, some of the padding of later
		axes is calculated from padding of previous axes.  This is easiest to
		think about with a rank 2 array where the corners of the padded array
		are calculated by using padded values from the first axis.
		
		The padding function, if used, should return a rank 1 array equal in
		length to the vector argument with padded values replaced. It has the
		following signature::
		
		    padding_func(vector, iaxis_pad_width, iaxis, kwargs)
		
		where
		
		    vector : ndarray
		        A rank 1 array already padded with zeros.  Padded values are
		        vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].
		    iaxis_pad_width : tuple
		        A 2-tuple of ints, iaxis_pad_width[0] represents the number of
		        values padded at the beginning of vector where
		        iaxis_pad_width[1] represents the number of values padded at
		        the end of vector.
		    iaxis : int
		        The axis currently being calculated.
		    kwargs : dict
		        Any keyword arguments the function requires.
		
		Examples
		--------
		>>> a = [1, 2, 3, 4, 5]
		>>> np.pad(a, (2,3), 'constant', constant_values=(4, 6))
		array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])
		
		>>> np.pad(a, (2, 3), 'edge')
		array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])
		
		>>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
		array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])
		
		>>> np.pad(a, (2,), 'maximum')
		array([5, 5, 1, 2, 3, 4, 5, 5, 5])
		
		>>> np.pad(a, (2,), 'mean')
		array([3, 3, 1, 2, 3, 4, 5, 3, 3])
		
		>>> np.pad(a, (2,), 'median')
		array([3, 3, 1, 2, 3, 4, 5, 3, 3])
		
		>>> a = [[1, 2], [3, 4]]
		>>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
		array([[1, 1, 1, 2, 1, 1, 1],
		       [1, 1, 1, 2, 1, 1, 1],
		       [1, 1, 1, 2, 1, 1, 1],
		       [1, 1, 1, 2, 1, 1, 1],
		       [3, 3, 3, 4, 3, 3, 3],
		       [1, 1, 1, 2, 1, 1, 1],
		       [1, 1, 1, 2, 1, 1, 1]])
		
		>>> a = [1, 2, 3, 4, 5]
		>>> np.pad(a, (2, 3), 'reflect')
		array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])
		
		>>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
		array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
		
		>>> np.pad(a, (2, 3), 'symmetric')
		array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])
		
		>>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
		array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])
		
		>>> np.pad(a, (2, 3), 'wrap')
		array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])
		
		>>> def pad_with(vector, pad_width, iaxis, kwargs):
		...     pad_value = kwargs.get('padder', 10)
		...     vector[:pad_width[0]] = pad_value
		...     vector[-pad_width[1]:] = pad_value
		...     return vector
		>>> a = np.arange(6)
		>>> a = a.reshape((2, 3))
		>>> np.pad(a, 2, pad_with)
		array([[10, 10, 10, 10, 10, 10, 10],
		       [10, 10, 10, 10, 10, 10, 10],
		       [10, 10,  0,  1,  2, 10, 10],
		       [10, 10,  3,  4,  5, 10, 10],
		       [10, 10, 10, 10, 10, 10, 10],
		       [10, 10, 10, 10, 10, 10, 10]])
		>>> np.pad(a, 2, pad_with, padder=100)
		array([[100, 100, 100, 100, 100, 100, 100],
		       [100, 100, 100, 100, 100, 100, 100],
		       [100, 100,   0,   1,   2, 100, 100],
		       [100, 100,   3,   4,   5, 100, 100],
		       [100, 100, 100, 100, 100, 100, 100],
		       [100, 100, 100, 100, 100, 100, 100]])
	**/
	static public function pad(array:Dynamic, pad_width:Dynamic, mode:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		pareto(a, size=None)
		
		Draw samples from a Pareto II or Lomax distribution with
		specified shape.
		
		The Lomax or Pareto II distribution is a shifted Pareto
		distribution. The classical Pareto distribution can be
		obtained from the Lomax distribution by adding 1 and
		multiplying by the scale parameter ``m`` (see Notes).  The
		smallest value of the Lomax distribution is zero while for the
		classical Pareto distribution it is ``mu``, where the standard
		Pareto distribution has location ``mu = 1``.  Lomax can also
		be considered as a simplified version of the Generalized
		Pareto distribution (available in SciPy), with the scale set
		to one and the location set to zero.
		
		The Pareto distribution must be greater than zero, and is
		unbounded above.  It is also known as the "80-20 rule".  In
		this distribution, 80 percent of the weights are in the lowest
		20 percent of the range, while the other 20 percent fill the
		remaining 80 percent of the range.
		
		Parameters
		----------
		a : float or array_like of floats
		    Shape of the distribution. Should be greater than zero.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``a`` is a scalar.  Otherwise,
		    ``np.array(a).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Pareto distribution.
		
		See Also
		--------
		scipy.stats.lomax : probability density function, distribution or
		    cumulative density function, etc.
		scipy.stats.genpareto : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Pareto distribution is
		
		.. math:: p(x) = \frac{am^a}{x^{a+1}}
		
		where :math:`a` is the shape and :math:`m` the scale.
		
		The Pareto distribution, named after the Italian economist
		Vilfredo Pareto, is a power law probability distribution
		useful in many real world problems.  Outside the field of
		economics it is generally referred to as the Bradford
		distribution. Pareto developed the distribution to describe
		the distribution of wealth in an economy.  It has also found
		use in insurance, web page access statistics, oil field sizes,
		and many other problems, including the download frequency for
		projects in Sourceforge [1]_.  It is one of the so-called
		"fat-tailed" distributions.
		
		
		References
		----------
		.. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of
		       Sourceforge projects.
		.. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.
		.. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
		       Values, Birkhauser Verlag, Basel, pp 23-30.
		.. [4] Wikipedia, "Pareto distribution",
		       https://en.wikipedia.org/wiki/Pareto_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> a, m = 3., 2.  # shape and mode
		>>> s = (np.random.pareto(a, 1000) + 1) * m
		
		Display the histogram of the samples, along with the probability
		density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, _ = plt.hist(s, 100, density=True)
		>>> fit = a*m**a / bins**(a+1)
		>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function pareto(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return a partitioned copy of an array.
		
		Creates a copy of the array with its elements rearranged in such a
		way that the value of the element in k-th position is in the
		position it would be in a sorted array. All elements smaller than
		the k-th element are moved before this element and all equal or
		greater are moved behind it. The ordering of the elements in the two
		partitions is undefined.
		
		.. versionadded:: 1.8.0
		
		Parameters
		----------
		a : array_like
		    Array to be sorted.
		kth : int or sequence of ints
		    Element index to partition by. The k-th value of the element
		    will be in its final sorted position and all smaller elements
		    will be moved before it and all equal or greater elements behind
		    it. The order of all elements in the partitions is undefined. If
		    provided with a sequence of k-th it will partition all elements
		    indexed by k-th  of them into their sorted position at once.
		axis : int or None, optional
		    Axis along which to sort. If None, the array is flattened before
		    sorting. The default is -1, which sorts along the last axis.
		kind : {'introselect'}, optional
		    Selection algorithm. Default is 'introselect'.
		order : str or list of str, optional
		    When `a` is an array with fields defined, this argument
		    specifies which fields to compare first, second, etc.  A single
		    field can be specified as a string.  Not all fields need be
		    specified, but unspecified fields will still be used, in the
		    order in which they come up in the dtype, to break ties.
		
		Returns
		-------
		partitioned_array : ndarray
		    Array of the same type and shape as `a`.
		
		See Also
		--------
		ndarray.partition : Method to sort an array in-place.
		argpartition : Indirect partition.
		sort : Full sorting
		
		Notes
		-----
		The various selection algorithms are characterized by their average
		speed, worst case performance, work space size, and whether they are
		stable. A stable sort keeps items with the same key in the same
		relative order. The available algorithms have the following
		properties:
		
		================= ======= ============= ============ =======
		   kind            speed   worst case    work space  stable
		================= ======= ============= ============ =======
		'introselect'        1        O(n)           0         no
		================= ======= ============= ============ =======
		
		All the partition algorithms make temporary copies of the data when
		partitioning along any but the last axis.  Consequently,
		partitioning along the last axis is faster and uses less space than
		partitioning along any other axis.
		
		The sort order for complex numbers is lexicographic. If both the
		real and imaginary parts are non-nan then the order is determined by
		the real parts except when they are equal, in which case the order
		is determined by the imaginary parts.
		
		Examples
		--------
		>>> a = np.array([3, 4, 2, 1])
		>>> np.partition(a, 3)
		array([2, 1, 3, 4])
		
		>>> np.partition(a, (1, 3))
		array([1, 2, 3, 4])
	**/
	static public function partition(a:Dynamic, kth:Dynamic, ?axis:Dynamic, ?kind:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Pause for *interval* seconds.
		
		If there is an active figure, it will be updated and displayed before the
		pause, and the GUI event loop (if any) will run during the pause.
		
		This can be used for crude animation.  For more complex animation, see
		:mod:`matplotlib.animation`.
		
		Notes
		-----
		This function is experimental; its behavior may be changed or extended in a
		future release.
	**/
	static public function pause(interval:Dynamic):Dynamic;
	/**
		Create a pseudocolor plot with a non-regular rectangular grid.
		
		Call signature::
		
		    pcolor([X, Y,] C, **kwargs)
		
		*X* and *Y* can be used to specify the corners of the quadrilaterals.
		
		.. hint::
		
		    ``pcolor()`` can be very slow for large arrays. In most
		    cases you should use the similar but much faster
		    `~.Axes.pcolormesh` instead. See there for a discussion of the
		    differences.
		
		Parameters
		----------
		C : array_like
		    A scalar 2-D array. The values will be color-mapped.
		
		X, Y : array_like, optional
		    The coordinates of the quadrilateral corners. The quadrilateral
		    for ``C[i,j]`` has corners at::
		
		        (X[i+1, j], Y[i+1, j])          (X[i+1, j+1], Y[i+1, j+1])
		                              +--------+
		                              | C[i,j] |
		                              +--------+
		            (X[i, j], Y[i, j])          (X[i, j+1], Y[i, j+1]),
		
		    Note that the column index corresponds to the
		    x-coordinate, and the row index corresponds to y. For
		    details, see the :ref:`Notes <axes-pcolor-grid-orientation>`
		    section below.
		
		    The dimensions of *X* and *Y* should be one greater than those of
		    *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in
		    which case the last row and column of *C* will be ignored.
		
		    If *X* and/or *Y* are 1-D arrays or column vectors they will be
		    expanded as needed into the appropriate 2-D arrays, making a
		    rectangular grid.
		
		cmap : str or `~matplotlib.colors.Colormap`, optional
		    A Colormap instance or registered colormap name. The colormap
		    maps the *C* values to colors. Defaults to :rc:`image.cmap`.
		
		norm : `~matplotlib.colors.Normalize`, optional
		    The Normalize instance scales the data values to the canonical
		    colormap range [0, 1] for mapping to colors. By default, the data
		    range is mapped to the colorbar range using linear scaling.
		
		vmin, vmax : scalar, optional, default: None
		    The colorbar range. If *None*, suitable min/max values are
		    automatically chosen by the `~.Normalize` instance (defaults to
		    the respective min/max values of *C* in case of the default linear
		    scaling).
		
		edgecolors : {'none', None, 'face', color, color sequence}, optional
		    The color of the edges. Defaults to 'none'. Possible values:
		
		    - 'none' or '': No edge.
		    - *None*: :rc:`patch.edgecolor` will be used. Note that currently
		      :rc:`patch.force_edgecolor` has to be True for this to work.
		    - 'face': Use the adjacent face color.
		    - An mpl color or sequence of colors will set the edge color.
		
		    The singular form *edgecolor* works as an alias.
		
		alpha : scalar, optional, default: None
		    The alpha blending value of the face color, between 0 (transparent)
		    and 1 (opaque). Note: The edgecolor is currently not affected by
		    this.
		
		snap : bool, optional, default: False
		    Whether to snap the mesh to pixel boundaries.
		
		Returns
		-------
		collection : `matplotlib.collections.Collection`
		
		Other Parameters
		----------------
		antialiaseds : bool, optional, default: False
		    The default *antialiaseds* is False if the default
		    *edgecolors*\ ="none" is used.  This eliminates artificial lines
		    at patch boundaries, and works regardless of the value of alpha.
		    If *edgecolors* is not "none", then the default *antialiaseds*
		    is taken from :rc:`patch.antialiased`, which defaults to True.
		    Stroking the edges may be preferred if *alpha* is 1, but will
		    cause artifacts otherwise.
		
		**kwargs
		    Additionally, the following arguments are allowed. They are passed
		    along to the `~matplotlib.collections.PolyCollection` constructor:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		See Also
		--------
		pcolormesh : for an explanation of the differences between
		    pcolor and pcolormesh.
		imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
		    faster alternative.
		
		Notes
		-----
		
		**Masked arrays**
		
		*X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
		of the vertices surrounding ``C[i,j]`` (*X* or *Y* at
		``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
		plotted.
		
		.. _axes-pcolor-grid-orientation:
		
		**Grid orientation**
		
		The grid orientation follows the standard matrix convention: An array
		*C* with shape (nrows, ncolumns) is plotted with the column number as
		*X* and the row number as *Y*.
		
		**Handling of pcolor() end-cases**
		
		``pcolor()`` displays all columns of *C* if *X* and *Y* are not
		specified, or if *X* and *Y* have one more column than *C*.
		If *X* and *Y* have the same number of columns as *C* then the last
		column of *C* is dropped. Similarly for the rows.
		
		Note: This behavior is different from MATLAB's ``pcolor()``, which
		always discards the last row and column of *C*.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function pcolor(?args:python.VarArgs<Dynamic>, ?alpha:Dynamic, ?norm:Dynamic, ?cmap:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Create a pseudocolor plot with a non-regular rectangular grid.
		
		Call signature::
		
		    pcolor([X, Y,] C, **kwargs)
		
		*X* and *Y* can be used to specify the corners of the quadrilaterals.
		
		.. note::
		
		   ``pcolormesh()`` is similar to :func:`~Axes.pcolor`. It's much
		   faster and preferred in most cases. For a detailed discussion on
		   the differences see
		   :ref:`Differences between pcolor() and pcolormesh()
		   <differences-pcolor-pcolormesh>`.
		
		Parameters
		----------
		C : array_like
		    A scalar 2-D array. The values will be color-mapped.
		
		X, Y : array_like, optional
		    The coordinates of the quadrilateral corners. The quadrilateral
		    for ``C[i,j]`` has corners at::
		
		        (X[i+1, j], Y[i+1, j])          (X[i+1, j+1], Y[i+1, j+1])
		                              +--------+
		                              | C[i,j] |
		                              +--------+
		            (X[i, j], Y[i, j])          (X[i, j+1], Y[i, j+1]),
		
		    Note that the column index corresponds to the
		    x-coordinate, and the row index corresponds to y. For
		    details, see the :ref:`Notes <axes-pcolormesh-grid-orientation>`
		    section below.
		
		    The dimensions of *X* and *Y* should be one greater than those of
		    *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in
		    which case the last row and column of *C* will be ignored.
		
		    If *X* and/or *Y* are 1-D arrays or column vectors they will be
		    expanded as needed into the appropriate 2-D arrays, making a
		    rectangular grid.
		
		cmap : str or `~matplotlib.colors.Colormap`, optional
		    A Colormap instance or registered colormap name. The colormap
		    maps the *C* values to colors. Defaults to :rc:`image.cmap`.
		
		norm : `~matplotlib.colors.Normalize`, optional
		    The Normalize instance scales the data values to the canonical
		    colormap range [0, 1] for mapping to colors. By default, the data
		    range is mapped to the colorbar range using linear scaling.
		
		vmin, vmax : scalar, optional, default: None
		    The colorbar range. If *None*, suitable min/max values are
		    automatically chosen by the `~.Normalize` instance (defaults to
		    the respective min/max values of *C* in case of the default linear
		    scaling).
		
		edgecolors : {'none', None, 'face', color, color sequence}, optional
		    The color of the edges. Defaults to 'none'. Possible values:
		
		    - 'none' or '': No edge.
		    - *None*: :rc:`patch.edgecolor` will be used. Note that currently
		      :rc:`patch.force_edgecolor` has to be True for this to work.
		    - 'face': Use the adjacent face color.
		    - An mpl color or sequence of colors will set the edge color.
		
		    The singular form *edgecolor* works as an alias.
		
		alpha : scalar, optional, default: None
		    The alpha blending value, between 0 (transparent) and 1 (opaque).
		
		shading : {'flat', 'gouraud'}, optional
		    The fill style, Possible values:
		
		    - 'flat': A solid color is used for each quad. The color of the
		      quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
		      ``C[i,j]``.
		    - 'gouraud': Each quad will be Gouraud shaded: The color of the
		      corners (i', j') are given by ``C[i',j']``. The color values of
		      the area in between is interpolated from the corner values.
		      When Gouraud shading is used, *edgecolors* is ignored.
		
		snap : bool, optional, default: False
		    Whether to snap the mesh to pixel boundaries.
		
		Returns
		-------
		mesh : `matplotlib.collections.QuadMesh`
		
		Other Parameters
		----------------
		**kwargs
		    Additionally, the following arguments are allowed. They are passed
		    along to the `~matplotlib.collections.QuadMesh` constructor:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		
		See Also
		--------
		pcolor : An alternative implementation with slightly different
		    features. For a detailed discussion on the differences see
		    :ref:`Differences between pcolor() and pcolormesh()
		    <differences-pcolor-pcolormesh>`.
		imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
		    faster alternative.
		
		Notes
		-----
		
		**Masked arrays**
		
		*C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
		quadrilateral will be transparent. Masking of *X* and *Y* is not
		supported. Use `~.Axes.pcolor` if you need this functionality.
		
		.. _axes-pcolormesh-grid-orientation:
		
		**Grid orientation**
		
		The grid orientation follows the standard matrix convention: An array
		*C* with shape (nrows, ncolumns) is plotted with the column number as
		*X* and the row number as *Y*.
		
		.. _differences-pcolor-pcolormesh:
		
		**Differences between pcolor() and pcolormesh()**
		
		Both methods are used to create a pseudocolor plot of a 2-D array
		using quadrilaterals.
		
		The main difference lies in the created object and internal data
		handling:
		While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
		returns a `.QuadMesh`. The latter is more specialized for the given
		purpose and thus is faster. It should almost always be preferred.
		
		There is also a slight difference in the handling of masked arrays.
		Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
		for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
		and *Y*. The reason lies in the internal handling of the masked values.
		`~.Axes.pcolor` leaves out the respective polygons from the
		PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
		elements to transparent. You can see the difference when using
		edgecolors. While all edges are drawn irrespective of masking in a
		QuadMesh, the edge between two adjacent masked quadrilaterals in
		`~.Axes.pcolor` is not drawn as the corresponding polygons do not
		exist in the PolyCollection.
		
		Another difference is the support of Gouraud shading in
		`~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function pcolormesh(?args:python.VarArgs<Dynamic>, ?alpha:Dynamic, ?norm:Dynamic, ?cmap:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?shading:Dynamic, ?antialiased:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Compute the q-th percentile of the data along the specified axis.
		
		Returns the q-th percentile(s) of the array elements.
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		q : array_like of float
		    Percentile or sequence of percentiles to compute, which must be between
		    0 and 100 inclusive.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the percentiles are computed. The
		    default is to compute the percentile(s) along a flattened
		    version of the array.
		
		    .. versionchanged:: 1.9.0
		        A tuple of axes is supported
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		    If True, then allow the input array `a` to be modified by intermediate
		    calculations, to save memory. In this case, the contents of the input
		    `a` after this function completes is undefined.
		
		interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
		    This optional parameter specifies the interpolation method to
		    use when the desired percentile lies between two data points
		    ``i < j``:
		
		    * 'linear': ``i + (j - i) * fraction``, where ``fraction``
		      is the fractional part of the index surrounded by ``i``
		      and ``j``.
		    * 'lower': ``i``.
		    * 'higher': ``j``.
		    * 'nearest': ``i`` or ``j``, whichever is nearest.
		    * 'midpoint': ``(i + j) / 2``.
		
		    .. versionadded:: 1.9.0
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left in
		    the result as dimensions with size one. With this option, the
		    result will broadcast correctly against the original array `a`.
		
		    .. versionadded:: 1.9.0
		
		Returns
		-------
		percentile : scalar or ndarray
		    If `q` is a single percentile and `axis=None`, then the result
		    is a scalar. If multiple percentiles are given, first axis of
		    the result corresponds to the percentiles. The other axes are
		    the axes that remain after the reduction of `a`. If the input
		    contains integers or floats smaller than ``float64``, the output
		    data-type is ``float64``. Otherwise, the output data-type is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		mean
		median : equivalent to ``percentile(..., 50)``
		nanpercentile
		quantile : equivalent to percentile, except with q in the range [0, 1].
		
		Notes
		-----
		Given a vector ``V`` of length ``N``, the q-th percentile of
		``V`` is the value ``q/100`` of the way from the minimum to the
		maximum in a sorted copy of ``V``. The values and distances of
		the two nearest neighbors as well as the `interpolation` parameter
		will determine the percentile if the normalized ranking does not
		match the location of ``q`` exactly. This function is the same as
		the median if ``q=50``, the same as the minimum if ``q=0`` and the
		same as the maximum if ``q=100``.
		
		Examples
		--------
		>>> a = np.array([[10, 7, 4], [3, 2, 1]])
		>>> a
		array([[10,  7,  4],
		       [ 3,  2,  1]])
		>>> np.percentile(a, 50)
		3.5
		>>> np.percentile(a, 50, axis=0)
		array([[ 6.5,  4.5,  2.5]])
		>>> np.percentile(a, 50, axis=1)
		array([ 7.,  2.])
		>>> np.percentile(a, 50, axis=1, keepdims=True)
		array([[ 7.],
		       [ 2.]])
		
		>>> m = np.percentile(a, 50, axis=0)
		>>> out = np.zeros_like(m)
		>>> np.percentile(a, 50, axis=0, out=out)
		array([[ 6.5,  4.5,  2.5]])
		>>> m
		array([[ 6.5,  4.5,  2.5]])
		
		>>> b = a.copy()
		>>> np.percentile(b, 50, axis=1, overwrite_input=True)
		array([ 7.,  2.])
		>>> assert not np.all(a == b)
		
		The different types of interpolation can be visualized graphically:
		
		.. plot::
		
		    import matplotlib.pyplot as plt
		
		    a = np.arange(4)
		    p = np.linspace(0, 100, 6001)
		    ax = plt.gca()
		    lines = [
		        ('linear', None),
		        ('higher', '--'),
		        ('lower', '--'),
		        ('nearest', '-.'),
		        ('midpoint', '-.'),
		    ]
		    for interpolation, style in lines:
		        ax.plot(
		            p, np.percentile(a, p, interpolation=interpolation),
		            label=interpolation, linestyle=style)
		    ax.set(
		        title='Interpolation methods for list: ' + str(a),
		        xlabel='Percentile',
		        ylabel='List item returned',
		        yticks=a)
		    ax.legend()
		    plt.show()
	**/
	static public function percentile(a:Dynamic, q:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?interpolation:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		permutation(x)
		
		Randomly permute a sequence, or return a permuted range.
		
		If `x` is a multi-dimensional array, it is only shuffled along its
		first index.
		
		Parameters
		----------
		x : int or array_like
		    If `x` is an integer, randomly permute ``np.arange(x)``.
		    If `x` is an array, make a copy and shuffle the elements
		    randomly.
		
		Returns
		-------
		out : ndarray
		    Permuted sequence or array range.
		
		Examples
		--------
		>>> np.random.permutation(10)
		array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])
		
		>>> np.random.permutation([1, 4, 9, 12, 15])
		array([15,  1,  9,  4, 12])
		
		>>> arr = np.arange(9).reshape((3, 3))
		>>> np.random.permutation(arr)
		array([[6, 7, 8],
		       [0, 1, 2],
		       [3, 4, 5]])
	**/
	static public function permutation(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Plot the phase spectrum.
		
		Compute the phase spectrum (unwrapped angle spectrum) of *x*.
		Data is padded to a length of *pad_to* and the windowing function
		*window* is applied to the signal.
		
		Parameters
		----------
		x : 1-D array or sequence
		    Array or sequence containing the data
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  While not increasing the actual resolution of
		    the spectrum (the minimum distance between resolvable peaks),
		    this can give more points in the plot, allowing for more
		    detail. This corresponds to the *n* parameter in the call to fft().
		    The default is None, which sets *pad_to* equal to the length of the
		    input signal (i.e. no padding).
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		Returns
		-------
		spectrum : 1-D array
		    The values for the phase spectrum in radians (real valued).
		
		freqs : 1-D array
		    The frequencies corresponding to the elements in *spectrum*.
		
		line : a :class:`~matplotlib.lines.Line2D` instance
		    The line created by this function.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See Also
		--------
		:func:`magnitude_spectrum`
		    :func:`magnitude_spectrum` plots the magnitudes of the
		    corresponding frequencies.
		
		:func:`angle_spectrum`
		    :func:`angle_spectrum` plots the wrapped version of this function.
		
		:func:`specgram`
		    :func:`specgram` can plot the phase spectrum of segments within the
		    signal in a colormap.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function phase_spectrum(x:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?window:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var pi : Dynamic;
	/**
		Plot a pie chart.
		
		Make a pie chart of array *x*.  The fractional area of each wedge is
		given by ``x/sum(x)``.  If ``sum(x) < 1``, then the values of *x* give
		the fractional area directly and the array will not be normalized. The
		resulting pie will have an empty wedge of size ``1 - sum(x)``.
		
		The wedges are plotted counterclockwise, by default starting from the
		x-axis.
		
		Parameters
		----------
		x : array-like
		    The wedge sizes.
		
		explode : array-like, optional, default: None
		    If not *None*, is a ``len(x)`` array which specifies the fraction
		    of the radius with which to offset each wedge.
		
		labels : list, optional, default: None
		    A sequence of strings providing the labels for each wedge
		
		colors : array-like, optional, default: None
		    A sequence of matplotlib color args through which the pie chart
		    will cycle.  If *None*, will use the colors in the currently
		    active cycle.
		
		autopct : None (default), string, or function, optional
		    If not *None*, is a string or function used to label the wedges
		    with their numeric value.  The label will be placed inside the
		    wedge.  If it is a format string, the label will be ``fmt%pct``.
		    If it is a function, it will be called.
		
		pctdistance : float, optional, default: 0.6
		    The ratio between the center of each pie slice and the start of
		    the text generated by *autopct*.  Ignored if *autopct* is *None*.
		
		shadow : bool, optional, default: False
		    Draw a shadow beneath the pie.
		
		labeldistance : float or None, optional, default: 1.1
		    The radial distance at which the pie labels are drawn.
		    If set to ``None``, label are not drawn, but are stored for use in
		    ``legend()``
		
		startangle : float, optional, default: None
		    If not *None*, rotates the start of the pie chart by *angle*
		    degrees counterclockwise from the x-axis.
		
		radius : float, optional, default: None
		    The radius of the pie, if *radius* is *None* it will be set to 1.
		
		counterclock : bool, optional, default: True
		    Specify fractions direction, clockwise or counterclockwise.
		
		wedgeprops : dict, optional, default: None
		    Dict of arguments passed to the wedge objects making the pie.
		    For example, you can pass in ``wedgeprops = {'linewidth': 3}``
		    to set the width of the wedge border lines equal to 3.
		    For more details, look at the doc/arguments of the wedge object.
		    By default ``clip_on=False``.
		
		textprops : dict, optional, default: None
		    Dict of arguments to pass to the text objects.
		
		center :  list of float, optional, default: (0, 0)
		    Center position of the chart. Takes value (0, 0) or is a sequence
		    of 2 scalars.
		
		frame : bool, optional, default: False
		    Plot axes frame with the chart if true.
		
		rotatelabels : bool, optional, default: False
		    Rotate each label to the angle of the corresponding slice if true.
		
		Returns
		-------
		patches : list
		    A sequence of :class:`matplotlib.patches.Wedge` instances
		
		texts : list
		    A list of the label :class:`matplotlib.text.Text` instances.
		
		autotexts : list
		    A list of :class:`~matplotlib.text.Text` instances for the numeric
		    labels. This will only be returned if the parameter *autopct* is
		    not *None*.
		
		Notes
		-----
		The pie chart will probably look best if the figure and axes are
		square, or the Axes aspect is equal.
		This method sets the aspect ratio of the axis to "equal".
		The axes aspect ratio can be controlled with `Axes.set_aspect`.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'colors', 'explode', 'labels', 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function pie(x:Dynamic, ?explode:Dynamic, ?labels:Dynamic, ?colors:Dynamic, ?autopct:Dynamic, ?pctdistance:Dynamic, ?shadow:Dynamic, ?labeldistance:Dynamic, ?startangle:Dynamic, ?radius:Dynamic, ?counterclock:Dynamic, ?wedgeprops:Dynamic, ?textprops:Dynamic, ?center:Dynamic, ?frame:Dynamic, ?rotatelabels:Dynamic, ?data:Dynamic):Array<Dynamic>;
	/**
		Evaluate a piecewise-defined function.
		
		Given a set of conditions and corresponding functions, evaluate each
		function on the input data wherever its condition is true.
		
		Parameters
		----------
		x : ndarray or scalar
		    The input domain.
		condlist : list of bool arrays or bool scalars
		    Each boolean array corresponds to a function in `funclist`.  Wherever
		    `condlist[i]` is True, `funclist[i](x)` is used as the output value.
		
		    Each boolean array in `condlist` selects a piece of `x`,
		    and should therefore be of the same shape as `x`.
		
		    The length of `condlist` must correspond to that of `funclist`.
		    If one extra function is given, i.e. if
		    ``len(funclist) == len(condlist) + 1``, then that extra function
		    is the default value, used wherever all conditions are false.
		funclist : list of callables, f(x,*args,**kw), or scalars
		    Each function is evaluated over `x` wherever its corresponding
		    condition is True.  It should take a 1d array as input and give an 1d
		    array or a scalar value as output.  If, instead of a callable,
		    a scalar is provided then a constant function (``lambda x: scalar``) is
		    assumed.
		args : tuple, optional
		    Any further arguments given to `piecewise` are passed to the functions
		    upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
		    each function is called as ``f(x, 1, 'a')``.
		kw : dict, optional
		    Keyword arguments used in calling `piecewise` are passed to the
		    functions upon execution, i.e., if called
		    ``piecewise(..., ..., alpha=1)``, then each function is called as
		    ``f(x, alpha=1)``.
		
		Returns
		-------
		out : ndarray
		    The output is the same shape and type as x and is found by
		    calling the functions in `funclist` on the appropriate portions of `x`,
		    as defined by the boolean arrays in `condlist`.  Portions not covered
		    by any condition have a default value of 0.
		
		
		See Also
		--------
		choose, select, where
		
		Notes
		-----
		This is similar to choose or select, except that functions are
		evaluated on elements of `x` that satisfy the corresponding condition from
		`condlist`.
		
		The result is::
		
		        |--
		        |funclist[0](x[condlist[0]])
		  out = |funclist[1](x[condlist[1]])
		        |...
		        |funclist[n2](x[condlist[n2]])
		        |--
		
		Examples
		--------
		Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.
		
		>>> x = np.linspace(-2.5, 2.5, 6)
		>>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
		array([-1., -1., -1.,  1.,  1.,  1.])
		
		Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
		``x >= 0``.
		
		>>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
		array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])
		
		Apply the same function to a scalar value.
		
		>>> y = -2
		>>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
		array(2)
	**/
	static public function piecewise(x:Dynamic, condlist:Dynamic, funclist:Dynamic, ?args:python.VarArgs<Dynamic>, ?kw:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "pink".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function pink():Dynamic;
	/**
		Compute the (Moore-Penrose) pseudo-inverse of a matrix.
		
		Calculate the generalized inverse of a matrix using its
		singular-value decomposition (SVD) and including all
		*large* singular values.
		
		.. versionchanged:: 1.14
		   Can now operate on stacks of matrices
		
		Parameters
		----------
		a : (..., M, N) array_like
		    Matrix or stack of matrices to be pseudo-inverted.
		rcond : (...) array_like of float
		    Cutoff for small singular values.
		    Singular values smaller (in modulus) than
		    `rcond` * largest_singular_value (again, in modulus)
		    are set to zero. Broadcasts against the stack of matrices
		
		Returns
		-------
		B : (..., N, M) ndarray
		    The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
		    is `B`.
		
		Raises
		------
		LinAlgError
		    If the SVD computation does not converge.
		
		Notes
		-----
		The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
		defined as: "the matrix that 'solves' [the least-squares problem]
		:math:`Ax = b`," i.e., if :math:`\bar{x}` is said solution, then
		:math:`A^+` is that matrix such that :math:`\bar{x} = A^+b`.
		
		It can be shown that if :math:`Q_1 \Sigma Q_2^T = A` is the singular
		value decomposition of A, then
		:math:`A^+ = Q_2 \Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
		orthogonal matrices, :math:`\Sigma` is a diagonal matrix consisting
		of A's so-called singular values, (followed, typically, by
		zeros), and then :math:`\Sigma^+` is simply the diagonal matrix
		consisting of the reciprocals of A's singular values
		(again, followed by zeros). [1]_
		
		References
		----------
		.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
		       FL, Academic Press, Inc., 1980, pp. 139-142.
		
		Examples
		--------
		The following example checks that ``a * a+ * a == a`` and
		``a+ * a * a+ == a+``:
		
		>>> a = np.random.randn(9, 6)
		>>> B = np.linalg.pinv(a)
		>>> np.allclose(a, np.dot(a, np.dot(B, a)))
		True
		>>> np.allclose(B, np.dot(B, np.dot(a, B)))
		True
	**/
	static public function pinv(a:Dynamic, ?rcond:Dynamic):Dynamic;
	/**
		Change elements of an array based on conditional and input values.
		
		Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
		`place` uses the first N elements of `vals`, where N is the number of
		True values in `mask`, while `copyto` uses the elements where `mask`
		is True.
		
		Note that `extract` does the exact opposite of `place`.
		
		Parameters
		----------
		arr : ndarray
		    Array to put data into.
		mask : array_like
		    Boolean mask array. Must have the same size as `a`.
		vals : 1-D sequence
		    Values to put into `a`. Only the first N elements are used, where
		    N is the number of True values in `mask`. If `vals` is smaller
		    than N, it will be repeated, and if elements of `a` are to be masked,
		    this sequence must be non-empty.
		
		See Also
		--------
		copyto, put, take, extract
		
		Examples
		--------
		>>> arr = np.arange(6).reshape(2, 3)
		>>> np.place(arr, arr>2, [44, 55])
		>>> arr
		array([[ 0,  1,  2],
		       [44, 55, 44]])
	**/
	static public function place(arr:Dynamic, mask:Dynamic, vals:Dynamic):Dynamic;
	/**
		Set the colormap to "plasma".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function plasma():Dynamic;
	/**
		Plot y versus x as lines and/or markers.
		
		Call signatures::
		
		    plot([x], y, [fmt], *, data=None, **kwargs)
		    plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
		
		The coordinates of the points or line nodes are given by *x*, *y*.
		
		The optional parameter *fmt* is a convenient way for defining basic
		formatting like color, marker and linestyle. It's a shortcut string
		notation described in the *Notes* section below.
		
		>>> plot(x, y)        # plot x and y using default line style and color
		>>> plot(x, y, 'bo')  # plot x and y using blue circle markers
		>>> plot(y)           # plot y using x as index array 0..N-1
		>>> plot(y, 'r+')     # ditto, but with red plusses
		
		You can use `.Line2D` properties as keyword arguments for more
		control on the appearance. Line properties and *fmt* can be mixed.
		The following two calls yield identical results:
		
		>>> plot(x, y, 'go--', linewidth=2, markersize=12)
		>>> plot(x, y, color='green', marker='o', linestyle='dashed',
		...      linewidth=2, markersize=12)
		
		When conflicting with *fmt*, keyword arguments take precedence.
		
		
		**Plotting labelled data**
		
		There's a convenient way for plotting objects with labelled data (i.e.
		data that can be accessed by index ``obj['y']``). Instead of giving
		the data in *x* and *y*, you can provide the object in the *data*
		parameter and just give the labels for *x* and *y*::
		
		>>> plot('xlabel', 'ylabel', data=obj)
		
		All indexable objects are supported. This could e.g. be a `dict`, a
		`pandas.DataFame` or a structured numpy array.
		
		
		**Plotting multiple sets of data**
		
		There are various ways to plot multiple sets of data.
		
		- The most straight forward way is just to call `plot` multiple times.
		  Example:
		
		  >>> plot(x1, y1, 'bo')
		  >>> plot(x2, y2, 'go')
		
		- Alternatively, if your data is already a 2d array, you can pass it
		  directly to *x*, *y*. A separate data set will be drawn for every
		  column.
		
		  Example: an array ``a`` where the first column represents the *x*
		  values and the other columns are the *y* columns::
		
		  >>> plot(a[0], a[1:])
		
		- The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
		  groups::
		
		  >>> plot(x1, y1, 'g^', x2, y2, 'g-')
		
		  In this case, any additional keyword argument applies to all
		  datasets. Also this syntax cannot be combined with the *data*
		  parameter.
		
		By default, each line is assigned a different style specified by a
		'style cycle'. The *fmt* and line property parameters are only
		necessary if you want explicit deviations from these defaults.
		Alternatively, you can also change the style cycle using the
		'axes.prop_cycle' rcParam.
		
		
		Parameters
		----------
		x, y : array-like or scalar
		    The horizontal / vertical coordinates of the data points.
		    *x* values are optional and default to `range(len(y))`.
		
		    Commonly, these parameters are 1D arrays.
		
		    They can also be scalars, or two-dimensional (in that case, the
		    columns represent separate data sets).
		
		    These arguments cannot be passed as keywords.
		
		fmt : str, optional
		    A format string, e.g. 'ro' for red circles. See the *Notes*
		    section for a full description of the format strings.
		
		    Format strings are just an abbreviation for quickly setting
		    basic line properties. All of these and more can also be
		    controlled by keyword arguments.
		
		    This argument cannot be passed as keyword.
		
		data : indexable object, optional
		    An object with labelled data. If given, provide the label names to
		    plot in *x* and *y*.
		
		    .. note::
		        Technically there's a slight ambiguity in calls where the
		        second label is a valid *fmt*. `plot('n', 'o', data=obj)`
		        could be `plt(x, y)` or `plt(y, fmt)`. In such cases,
		        the former interpretation is chosen, but a warning is issued.
		        You may suppress the warning by adding an empty format string
		        `plot('n', 'o', '', data=obj)`.
		
		Other Parameters
		----------------
		scalex, scaley : bool, optional, default: True
		    These parameters determined if the view limits are adapted to
		    the data limits. The values are passed on to `autoscale_view`.
		
		**kwargs : `.Line2D` properties, optional
		    *kwargs* are used to specify properties like a line label (for
		    auto legends), linewidth, antialiasing, marker face color.
		    Example::
		
		    >>> plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)
		    >>> plot([1,2,3], [1,4,9], 'rs',  label='line 2')
		
		    If you make multiple lines with one plot command, the kwargs
		    apply to all those lines.
		
		    Here is a list of available `.Line2D` properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		Returns
		-------
		lines
		    A list of `.Line2D` objects representing the plotted data.
		
		See Also
		--------
		scatter : XY scatter plot with markers of varying size and/or color (
		    sometimes also called bubble chart).
		
		Notes
		-----
		**Format Strings**
		
		A format string consists of a part for color, marker and line::
		
		    fmt = '[marker][line][color]'
		
		Each of them is optional. If not provided, the value from the style
		cycle is used. Exception: If ``line`` is given, but no ``marker``,
		the data will be a line without markers.
		
		Other combinations such as ``[color][marker][line]`` are also
		supported, but note that their parsing may be ambiguous.
		
		**Markers**
		
		=============    ===============================
		character        description
		=============    ===============================
		``'.'``          point marker
		``','``          pixel marker
		``'o'``          circle marker
		``'v'``          triangle_down marker
		``'^'``          triangle_up marker
		``'<'``          triangle_left marker
		``'>'``          triangle_right marker
		``'1'``          tri_down marker
		``'2'``          tri_up marker
		``'3'``          tri_left marker
		``'4'``          tri_right marker
		``'s'``          square marker
		``'p'``          pentagon marker
		``'*'``          star marker
		``'h'``          hexagon1 marker
		``'H'``          hexagon2 marker
		``'+'``          plus marker
		``'x'``          x marker
		``'D'``          diamond marker
		``'d'``          thin_diamond marker
		``'|'``          vline marker
		``'_'``          hline marker
		=============    ===============================
		
		**Line Styles**
		
		=============    ===============================
		character        description
		=============    ===============================
		``'-'``          solid line style
		``'--'``         dashed line style
		``'-.'``         dash-dot line style
		``':'``          dotted line style
		=============    ===============================
		
		Example format strings::
		
		    'b'    # blue markers with default shape
		    'or'   # red circles
		    '-g'   # green solid line
		    '--'   # dashed line with default color
		    '^k:'  # black triangle_up markers connected by a dotted line
		
		**Colors**
		
		The supported color abbreviations are the single letter codes
		
		=============    ===============================
		character        color
		=============    ===============================
		``'b'``          blue
		``'g'``          green
		``'r'``          red
		``'c'``          cyan
		``'m'``          magenta
		``'y'``          yellow
		``'k'``          black
		``'w'``          white
		=============    ===============================
		
		and the ``'CN'`` colors that index into the default property cycle.
		
		If the color is the only part of the format string, you can
		additionally use any  `matplotlib.colors` spec, e.g. full names
		(``'green'``) or hex strings (``'#008000'``).
	**/
	static public function plot(?args:python.VarArgs<Dynamic>, ?scalex:Dynamic, ?scaley:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Plot data that contains dates.
		
		Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
		However, the axis labels are formatted as dates depending on *xdate*
		and *ydate*.
		
		Parameters
		----------
		x, y : array-like
		    The coordinates of the data points. If *xdate* or *ydate* is
		    *True*, the respective values *x* or *y* are interpreted as
		    :ref:`Matplotlib dates <date-format>`.
		
		fmt : str, optional
		    The plot format string. For details, see the corresponding
		    parameter in `.plot`.
		
		tz : [ *None* | timezone string | :class:`tzinfo` instance]
		    The time zone to use in labeling dates. If *None*, defaults to
		    rcParam ``timezone``.
		
		xdate : bool, optional, default: True
		    If *True*, the *x*-axis will be interpreted as Matplotlib dates.
		
		ydate : bool, optional, default: False
		    If *True*, the *y*-axis will be interpreted as Matplotlib dates.
		
		
		Returns
		-------
		lines
		    A list of `~.Line2D` objects representing the plotted data.
		
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		
		See Also
		--------
		matplotlib.dates : Helper functions on dates.
		matplotlib.dates.date2num : Convert dates to num.
		matplotlib.dates.num2date : Convert num to dates.
		matplotlib.dates.drange : Create an equally spaced sequence of dates.
		
		
		Notes
		-----
		If you are using custom date tickers and formatters, it may be
		necessary to set the formatters/locators after the call to
		`.plot_date`. `.plot_date` will set the default tick locator to
		`.AutoDateLocator` (if the tick locator is not already set to a
		`.DateLocator` instance) and the default tick formatter to
		`.AutoDateFormatter` (if the tick formatter is not already set to a
		`.DateFormatter` instance).
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function plot_date(x:Dynamic, y:Dynamic, ?fmt:Dynamic, ?tz:Dynamic, ?xdate:Dynamic, ?ydate:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Plot the data in a file.
		
		*cols* is a sequence of column identifiers to plot.  An identifier
		is either an int or a string.  If it is an int, it indicates the
		column number.  If it is a string, it indicates the column header.
		matplotlib will make column headers lower case, replace spaces with
		underscores, and remove all illegal characters; so ``'Adj Close*'``
		will have name ``'adj_close'``.
		
		- If len(*cols*) == 1, only that column will be plotted on the *y* axis.
		
		- If len(*cols*) > 1, the first element will be an identifier for
		  data for the *x* axis and the remaining elements will be the
		  column indexes for multiple subplots if *subplots* is *True*
		  (the default), or for lines in a single subplot if *subplots*
		  is *False*.
		
		*plotfuncs*, if not *None*, is a dictionary mapping identifier to
		an :class:`~matplotlib.axes.Axes` plotting function as a string.
		Default is 'plot', other choices are 'semilogy', 'fill', 'bar',
		etc.  You must use the same type of identifier in the *cols*
		vector as you use in the *plotfuncs* dictionary, e.g., integer
		column numbers in both or column names in both. If *subplots*
		is *False*, then including any function such as 'semilogy'
		that changes the axis scaling will set the scaling for all
		columns.
		
		- *comments*: the character used to indicate the start of a comment
		  in the file, or *None* to switch off the removal of comments
		
		- *skiprows*: is the number of rows from the top to skip
		
		- *checkrows*: is the number of rows to check to validate the column
		  data type.  When set to zero all rows are validated.
		
		- *delimiter*: is the character(s) separating row items
		
		- *names*: if not None, is a list of header names.  In this case, no
		  header will be read from the file
		
		If *newfig* is *True*, the plot always will be made in a new figure;
		if *False*, it will be made in the current figure if one exists,
		else in a new figure.
		
		kwargs are passed on to plotting functions.
		
		Example usage::
		
		  # plot the 2nd and 4th column against the 1st in two subplots
		  plotfile(fname, (0,1,3))
		
		  # plot using column names; specify an alternate plot type for volume
		  plotfile(fname, ('date', 'volume', 'adj_close'),
		                                plotfuncs={'volume': 'semilogy'})
		
		Note: plotfile is intended as a convenience for quickly plotting
		data from flat files; it is not intended as an alternative
		interface to general plotting with pyplot or matplotlib.
	**/
	static public function plotfile(fname:Dynamic, ?cols:Dynamic, ?plotfuncs:Dynamic, ?comments:Dynamic, ?skiprows:Dynamic, ?checkrows:Dynamic, ?delimiter:Dynamic, ?names:Dynamic, ?subplots:Dynamic, ?newfig:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		============================ =============================================================================================================================
		Function                     Description                                                                                                                  
		============================ =============================================================================================================================
		`acorr`                      Plot the autocorrelation of *x*.                                                                                             
		`angle_spectrum`             Plot the angle spectrum.                                                                                                     
		`annotate`                   Annotate the point *xy* with text *text*.                                                                                    
		`arrow`                      Add an arrow to the axes.                                                                                                    
		`autoscale`                  Autoscale the axis view to the data (toggle).                                                                                
		`axes`                       Add an axes to the current figure and make it the current axes.                                                              
		`axhline`                    Add a horizontal line across the axis.                                                                                       
		`axhspan`                    Add a horizontal span (rectangle) across the axis.                                                                           
		`axis`                       Convenience method to get or set some axis properties.                                                                       
		`axvline`                    Add a vertical line across the axes.                                                                                         
		`axvspan`                    Add a vertical span (rectangle) across the axes.                                                                             
		`bar`                        Make a bar plot.                                                                                                             
		`barbs`                      Plot a 2-D field of barbs.                                                                                                   
		`barh`                       Make a horizontal bar plot.                                                                                                  
		`box`                        Turn the axes box on or off on the current axes.                                                                             
		`boxplot`                    Make a box and whisker plot.                                                                                                 
		`broken_barh`                Plot a horizontal sequence of rectangles.                                                                                    
		`cla`                        Clear the current axes.                                                                                                      
		`clabel`                     Label a contour plot.                                                                                                        
		`clf`                        Clear the current figure.                                                                                                    
		`clim`                       Set the color limits of the current image.                                                                                   
		`close`                      Close a figure window.                                                                                                       
		`cohere`                     Plot the coherence between *x* and *y*.                                                                                      
		`colorbar`                   Add a colorbar to a plot.                                                                                                    
		`contour`                    Plot contours.                                                                                                               
		`contourf`                   Plot contours.                                                                                                               
		`csd`                        Plot the cross-spectral density.                                                                                             
		`delaxes`                    Remove the `Axes` *ax* (defaulting to the current axes) from its figure.                                                     
		`draw`                       Redraw the current figure.                                                                                                   
		`errorbar`                   Plot y versus x as lines and/or markers with attached errorbars.                                                             
		`eventplot`                  Plot identical parallel lines at the given positions.                                                                        
		`figimage`                   Add a non-resampled image to the figure.                                                                                     
		`figlegend`                  Place a legend on the figure.                                                                                                
		`fignum_exists`              Return whether the figure with the given id exists.                                                                          
		`figtext`                    Add text to figure.                                                                                                          
		`figure`                     Create a new figure.                                                                                                         
		`fill`                       Plot filled polygons.                                                                                                        
		`fill_between`               Fill the area between two horizontal curves.                                                                                 
		`fill_betweenx`              Fill the area between two vertical curves.                                                                                   
		`findobj`                    Find artist objects.                                                                                                         
		`gca`                        Get the current :class:`~matplotlib.axes.Axes` instance on the current figure matching the given keyword args, or create one.
		`gcf`                        Get the current figure.                                                                                                      
		`gci`                        Get the current colorable artist.                                                                                            
		`get_figlabels`              Return a list of existing figure labels.                                                                                     
		`get_fignums`                Return a list of existing figure numbers.                                                                                    
		`grid`                       Configure the grid lines.                                                                                                    
		`hexbin`                     Make a hexagonal binning plot.                                                                                               
		`hist`                       Plot a histogram.                                                                                                            
		`hist2d`                     Make a 2D histogram plot.                                                                                                    
		`hlines`                     Plot horizontal lines at each *y* from *xmin* to *xmax*.                                                                     
		`imread`                     Read an image from a file into an array.                                                                                     
		`imsave`                     Save an array as an image file.                                                                                              
		`imshow`                     Display an image, i.e.                                                                                                       
		`install_repl_displayhook`   Install a repl display hook so that any stale figure are automatically redrawn when control is returned to the repl.         
		`ioff`                       Turn the interactive mode off.                                                                                               
		`ion`                        Turn the interactive mode on.                                                                                                
		`isinteractive`              Return the status of interactive mode.                                                                                       
		`legend`                     Place a legend on the axes.                                                                                                  
		`locator_params`             Control behavior of major tick locators.                                                                                     
		`loglog`                     Make a plot with log scaling on both the x and y axis.                                                                       
		`magnitude_spectrum`         Plot the magnitude spectrum.                                                                                                 
		`margins`                    Set or retrieve autoscaling margins.                                                                                         
		`matshow`                    Display an array as a matrix in a new figure window.                                                                         
		`minorticks_off`             Remove minor ticks from the axes.                                                                                            
		`minorticks_on`              Display minor ticks on the axes.                                                                                             
		`pause`                      Pause for *interval* seconds.                                                                                                
		`pcolor`                     Create a pseudocolor plot with a non-regular rectangular grid.                                                               
		`pcolormesh`                 Create a pseudocolor plot with a non-regular rectangular grid.                                                               
		`phase_spectrum`             Plot the phase spectrum.                                                                                                     
		`pie`                        Plot a pie chart.                                                                                                            
		`plot`                       Plot y versus x as lines and/or markers.                                                                                     
		`plot_date`                  Plot data that contains dates.                                                                                               
		`plotfile`                   Plot the data in a file.                                                                                                     
		`polar`                      Make a polar plot.                                                                                                           
		`psd`                        Plot the power spectral density.                                                                                             
		`quiver`                     Plot a 2D field of arrows.                                                                                                   
		`quiverkey`                  Add a key to a quiver plot.                                                                                                  
		`rc`                         Set the current rc params.                                                                                                   
		`rc_context`                 Return a context manager for managing rc settings.                                                                           
		`rcdefaults`                 Restore the rc params from Matplotlib's internal default style.                                                              
		`rgrids`                     Get or set the radial gridlines on the current polar plot.                                                                   
		`savefig`                    Save the current figure.                                                                                                     
		`sca`                        Set the current Axes instance to *ax*.                                                                                       
		`scatter`                    A scatter plot of *y* vs *x* with varying marker size and/or color.                                                          
		`sci`                        Set the current image.                                                                                                       
		`semilogx`                   Make a plot with log scaling on the x axis.                                                                                  
		`semilogy`                   Make a plot with log scaling on the y axis.                                                                                  
		`set_cmap`                   Set the default colormap.                                                                                                    
		`setp`                       Set a property on an artist object.                                                                                          
		`show`                       Display a figure.                                                                                                            
		`specgram`                   Plot a spectrogram.                                                                                                          
		`spy`                        Plot the sparsity pattern of a 2D array.                                                                                     
		`stackplot`                  Draw a stacked area plot.                                                                                                    
		`stem`                       Create a stem plot.                                                                                                          
		`step`                       Make a step plot.                                                                                                            
		`streamplot`                 Draw streamlines of a vector flow.                                                                                           
		`subplot`                    Add a subplot to the current figure.                                                                                         
		`subplot2grid`               Create an axis at specific location inside a regular grid.                                                                   
		`subplot_tool`               Launch a subplot tool window for a figure.                                                                                   
		`subplots`                   Create a figure and a set of subplots.                                                                                       
		`subplots_adjust`            Tune the subplot layout.                                                                                                     
		`suptitle`                   Add a centered title to the figure.                                                                                          
		`switch_backend`             Close all open figures and set the Matplotlib backend.                                                                       
		`table`                      Add a table to an `~.axes.Axes`.                                                                                             
		`text`                       Add text to the axes.                                                                                                        
		`thetagrids`                 Get or set the theta gridlines on the current polar plot.                                                                    
		`tick_params`                Change the appearance of ticks, tick labels, and gridlines.                                                                  
		`ticklabel_format`           Change the `~matplotlib.ticker.ScalarFormatter` used by default for linear axes.                                             
		`tight_layout`               Automatically adjust subplot parameters to give specified padding.                                                           
		`title`                      Set a title for the axes.                                                                                                    
		`tricontour`                 Draw contours on an unstructured triangular grid.                                                                            
		`tricontourf`                Draw contours on an unstructured triangular grid.                                                                            
		`tripcolor`                  Create a pseudocolor plot of an unstructured triangular grid.                                                                
		`triplot`                    Draw a unstructured triangular grid as lines and/or markers.                                                                 
		`twinx`                      Make and return a second axes that shares the *x*-axis.                                                                      
		`twiny`                      Make and return a second axes that shares the *y*-axis.                                                                      
		`uninstall_repl_displayhook` Uninstall the matplotlib display hook.                                                                                       
		`violinplot`                 Make a violin plot.                                                                                                          
		`vlines`                     Plot vertical lines.                                                                                                         
		`xcorr`                      Plot the cross correlation between *x* and *y*.                                                                              
		`xkcd`                       Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.                                                               
		`xlabel`                     Set the label for the x-axis.                                                                                                
		`xlim`                       Get or set the x limits of the current axes.                                                                                 
		`xscale`                     Set the x-axis scale.                                                                                                        
		`xticks`                     Get or set the current tick locations and labels of the x-axis.                                                              
		`ylabel`                     Set the label for the y-axis.                                                                                                
		`ylim`                       Get or set the y-limits of the current axes.                                                                                 
		`yscale`                     Set the y-axis scale.                                                                                                        
		`yticks`                     Get or set the current tick locations and labels of the y-axis.                                                              
		============================ =============================================================================================================================
	**/
	static public function plotting():Dynamic;
	/**
		Compute the payment against loan principal plus interest.
		
		Given:
		 * a present value, `pv` (e.g., an amount borrowed)
		 * a future value, `fv` (e.g., 0)
		 * an interest `rate` compounded once per period, of which
		   there are
		 * `nper` total
		 * and (optional) specification of whether payment is made
		   at the beginning (`when` = {'begin', 1}) or the end
		   (`when` = {'end', 0}) of each period
		
		Return:
		   the (fixed) periodic payment.
		
		Parameters
		----------
		rate : array_like
		    Rate of interest (per period)
		nper : array_like
		    Number of compounding periods
		pv : array_like
		    Present value
		fv : array_like,  optional
		    Future value (default = 0)
		when : {{'begin', 1}, {'end', 0}}, {string, int}
		    When payments are due ('begin' (1) or 'end' (0))
		
		Returns
		-------
		out : ndarray
		    Payment against loan plus interest.  If all input is scalar, returns a
		    scalar float.  If any input is array_like, returns payment for each
		    input element. If multiple inputs are array_like, they all must have
		    the same shape.
		
		Notes
		-----
		The payment is computed by solving the equation::
		
		 fv +
		 pv*(1 + rate)**nper +
		 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0
		
		or, when ``rate == 0``::
		
		  fv + pv + pmt * nper == 0
		
		for ``pmt``.
		
		Note that computing a monthly mortgage payment is only
		one use for this function.  For example, pmt returns the
		periodic deposit one must make to achieve a specified
		future balance given an initial deposit, a fixed,
		periodically compounded interest rate, and the total
		number of periods.
		
		References
		----------
		.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
		   Open Document Format for Office Applications (OpenDocument)v1.2,
		   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
		   Pre-Draft 12. Organization for the Advancement of Structured Information
		   Standards (OASIS). Billerica, MA, USA. [ODT Document].
		   Available:
		   http://www.oasis-open.org/committees/documents.php
		   ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt
		
		Examples
		--------
		What is the monthly payment needed to pay off a $200,000 loan in 15
		years at an annual interest rate of 7.5%?
		
		>>> np.pmt(0.075/12, 12*15, 200000)
		-1854.0247200054619
		
		In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained
		today, a monthly payment of $1,854.02 would be required.  Note that this
		example illustrates usage of `fv` having a default value of 0.
	**/
	static public function pmt(rate:Dynamic, nper:Dynamic, pv:Dynamic, ?fv:Dynamic, ?when:Dynamic):Dynamic;
	/**
		poisson(lam=1.0, size=None)
		
		Draw samples from a Poisson distribution.
		
		The Poisson distribution is the limit of the binomial distribution
		for large N.
		
		Parameters
		----------
		lam : float or array_like of floats
		    Expectation of interval, should be >= 0. A sequence of expectation
		    intervals must be broadcastable over the requested size.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``lam`` is a scalar. Otherwise,
		    ``np.array(lam).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Poisson distribution.
		
		Notes
		-----
		The Poisson distribution
		
		.. math:: f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}
		
		For events with an expected separation :math:`\lambda` the Poisson
		distribution :math:`f(k; \lambda)` describes the probability of
		:math:`k` events occurring within the observed
		interval :math:`\lambda`.
		
		Because the output is limited to the range of the C long type, a
		ValueError is raised when `lam` is within 10 sigma of the maximum
		representable value.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Poisson Distribution."
		       From MathWorld--A Wolfram Web Resource.
		       http://mathworld.wolfram.com/PoissonDistribution.html
		.. [2] Wikipedia, "Poisson distribution",
		       https://en.wikipedia.org/wiki/Poisson_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> import numpy as np
		>>> s = np.random.poisson(5, 10000)
		
		Display histogram of the sample:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 14, density=True)
		>>> plt.show()
		
		Draw each 100 values for lambda 100 and 500:
		
		>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))
	**/
	static public function poisson(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Make a polar plot.
		
		call signature::
		
		  polar(theta, r, **kwargs)
		
		Multiple *theta*, *r* arguments are supported, with format
		strings, as in :func:`~matplotlib.pyplot.plot`.
	**/
	static public function polar(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Find the coefficients of a polynomial with the given sequence of roots.
		
		Returns the coefficients of the polynomial whose leading coefficient
		is one for the given sequence of zeros (multiple roots must be included
		in the sequence as many times as their multiplicity; see Examples).
		A square matrix (or array, which will be treated as a matrix) can also
		be given, in which case the coefficients of the characteristic polynomial
		of the matrix are returned.
		
		Parameters
		----------
		seq_of_zeros : array_like, shape (N,) or (N, N)
		    A sequence of polynomial roots, or a square array or matrix object.
		
		Returns
		-------
		c : ndarray
		    1D array of polynomial coefficients from highest to lowest degree:
		
		    ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``
		    where c[0] always equals 1.
		
		Raises
		------
		ValueError
		    If input is the wrong shape (the input must be a 1-D or square
		    2-D array).
		
		See Also
		--------
		polyval : Compute polynomial values.
		roots : Return the roots of a polynomial.
		polyfit : Least squares polynomial fit.
		poly1d : A one-dimensional polynomial class.
		
		Notes
		-----
		Specifying the roots of a polynomial still leaves one degree of
		freedom, typically represented by an undetermined leading
		coefficient. [1]_ In the case of this function, that coefficient -
		the first one in the returned array - is always taken as one. (If
		for some reason you have one other point, the only automatic way
		presently to leverage that information is to use ``polyfit``.)
		
		The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`
		matrix **A** is given by
		
		    :math:`p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})`,
		
		where **I** is the `n`-by-`n` identity matrix. [2]_
		
		References
		----------
		.. [1] M. Sullivan and M. Sullivan, III, "Algebra and Trignometry,
		   Enhanced With Graphing Utilities," Prentice-Hall, pg. 318, 1996.
		
		.. [2] G. Strang, "Linear Algebra and Its Applications, 2nd Edition,"
		   Academic Press, pg. 182, 1980.
		
		Examples
		--------
		Given a sequence of a polynomial's zeros:
		
		>>> np.poly((0, 0, 0)) # Multiple root example
		array([1, 0, 0, 0])
		
		The line above represents z**3 + 0*z**2 + 0*z + 0.
		
		>>> np.poly((-1./2, 0, 1./2))
		array([ 1.  ,  0.  , -0.25,  0.  ])
		
		The line above represents z**3 - z/4
		
		>>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))
		array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random
		
		Given a square array object:
		
		>>> P = np.array([[0, 1./3], [-1./2, 0]])
		>>> np.poly(P)
		array([ 1.        ,  0.        ,  0.16666667])
		
		Note how in all cases the leading coefficient is always 1.
	**/
	static public function poly(seq_of_zeros:Dynamic):Dynamic;
	/**
		Find the sum of two polynomials.
		
		Returns the polynomial resulting from the sum of two input polynomials.
		Each input must be either a poly1d object or a 1D sequence of polynomial
		coefficients, from highest to lowest degree.
		
		Parameters
		----------
		a1, a2 : array_like or poly1d object
		    Input polynomials.
		
		Returns
		-------
		out : ndarray or poly1d object
		    The sum of the inputs. If either input is a poly1d object, then the
		    output is also a poly1d object. Otherwise, it is a 1D array of
		    polynomial coefficients from highest to lowest degree.
		
		See Also
		--------
		poly1d : A one-dimensional polynomial class.
		poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
		
		Examples
		--------
		>>> np.polyadd([1, 2], [9, 5, 4])
		array([9, 6, 6])
		
		Using poly1d objects:
		
		>>> p1 = np.poly1d([1, 2])
		>>> p2 = np.poly1d([9, 5, 4])
		>>> print(p1)
		1 x + 2
		>>> print(p2)
		   2
		9 x + 5 x + 4
		>>> print(np.polyadd(p1, p2))
		   2
		9 x + 6 x + 6
	**/
	static public function polyadd(a1:Dynamic, a2:Dynamic):Dynamic;
	/**
		Return the derivative of the specified order of a polynomial.
		
		Parameters
		----------
		p : poly1d or sequence
		    Polynomial to differentiate.
		    A sequence is interpreted as polynomial coefficients, see `poly1d`.
		m : int, optional
		    Order of differentiation (default: 1)
		
		Returns
		-------
		der : poly1d
		    A new polynomial representing the derivative.
		
		See Also
		--------
		polyint : Anti-derivative of a polynomial.
		poly1d : Class for one-dimensional polynomials.
		
		Examples
		--------
		The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:
		
		>>> p = np.poly1d([1,1,1,1])
		>>> p2 = np.polyder(p)
		>>> p2
		poly1d([3, 2, 1])
		
		which evaluates to:
		
		>>> p2(2.)
		17.0
		
		We can verify this, approximating the derivative with
		``(f(x + h) - f(x))/h``:
		
		>>> (p(2. + 0.001) - p(2.)) / 0.001
		17.007000999997857
		
		The fourth-order derivative of a 3rd-order polynomial is zero:
		
		>>> np.polyder(p, 2)
		poly1d([6, 2])
		>>> np.polyder(p, 3)
		poly1d([6])
		>>> np.polyder(p, 4)
		poly1d([ 0.])
	**/
	static public function polyder(p:Dynamic, ?m:Dynamic):Dynamic;
	/**
		Returns the quotient and remainder of polynomial division.
		
		The input arrays are the coefficients (including any coefficients
		equal to zero) of the "numerator" (dividend) and "denominator"
		(divisor) polynomials, respectively.
		
		Parameters
		----------
		u : array_like or poly1d
		    Dividend polynomial's coefficients.
		
		v : array_like or poly1d
		    Divisor polynomial's coefficients.
		
		Returns
		-------
		q : ndarray
		    Coefficients, including those equal to zero, of the quotient.
		r : ndarray
		    Coefficients, including those equal to zero, of the remainder.
		
		See Also
		--------
		poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,
		polyval
		
		Notes
		-----
		Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need
		not equal `v.ndim`. In other words, all four possible combinations -
		``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,
		``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.
		
		Examples
		--------
		.. math:: \frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25
		
		>>> x = np.array([3.0, 5.0, 2.0])
		>>> y = np.array([2.0, 1.0])
		>>> np.polydiv(x, y)
		(array([ 1.5 ,  1.75]), array([ 0.25]))
	**/
	static public function polydiv(u:Dynamic, v:Dynamic):Dynamic;
	/**
		Least squares polynomial fit.
		
		Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
		to points `(x, y)`. Returns a vector of coefficients `p` that minimises
		the squared error in the order `deg`, `deg-1`, ... `0`.
		
		The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class
		method is recommended for new code as it is more stable numerically. See
		the documentation of the method for more information.
		
		Parameters
		----------
		x : array_like, shape (M,)
		    x-coordinates of the M sample points ``(x[i], y[i])``.
		y : array_like, shape (M,) or (M, K)
		    y-coordinates of the sample points. Several data sets of sample
		    points sharing the same x-coordinates can be fitted at once by
		    passing in a 2D-array that contains one dataset per column.
		deg : int
		    Degree of the fitting polynomial
		rcond : float, optional
		    Relative condition number of the fit. Singular values smaller than
		    this relative to the largest singular value will be ignored. The
		    default value is len(x)*eps, where eps is the relative precision of
		    the float type, about 2e-16 in most cases.
		full : bool, optional
		    Switch determining nature of return value. When it is False (the
		    default) just the coefficients are returned, when True diagnostic
		    information from the singular value decomposition is also returned.
		w : array_like, shape (M,), optional
		    Weights to apply to the y-coordinates of the sample points. For
		    gaussian uncertainties, use 1/sigma (not 1/sigma**2).
		cov : bool or str, optional
		    If given and not `False`, return not just the estimate but also its
		    covariance matrix. By default, the covariance are scaled by
		    chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable
		    except in a relative sense and everything is scaled such that the
		    reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,
		    as is relevant for the case that the weights are 1/sigma**2, with
		    sigma known to be a reliable estimate of the uncertainty.
		
		Returns
		-------
		p : ndarray, shape (deg + 1,) or (deg + 1, K)
		    Polynomial coefficients, highest power first.  If `y` was 2-D, the
		    coefficients for `k`-th data set are in ``p[:,k]``.
		
		residuals, rank, singular_values, rcond
		    Present only if `full` = True.  Residuals of the least-squares fit,
		    the effective rank of the scaled Vandermonde coefficient matrix,
		    its singular values, and the specified value of `rcond`. For more
		    details, see `linalg.lstsq`.
		
		V : ndarray, shape (M,M) or (M,M,K)
		    Present only if `full` = False and `cov`=True.  The covariance
		    matrix of the polynomial coefficient estimates.  The diagonal of
		    this matrix are the variance estimates for each coefficient.  If y
		    is a 2-D array, then the covariance matrix for the `k`-th data set
		    are in ``V[:,:,k]``
		
		
		Warns
		-----
		RankWarning
		    The rank of the coefficient matrix in the least-squares fit is
		    deficient. The warning is only raised if `full` = False.
		
		    The warnings can be turned off by
		
		    >>> import warnings
		    >>> warnings.simplefilter('ignore', np.RankWarning)
		
		See Also
		--------
		polyval : Compute polynomial values.
		linalg.lstsq : Computes a least-squares fit.
		scipy.interpolate.UnivariateSpline : Computes spline fits.
		
		Notes
		-----
		The solution minimizes the squared error
		
		.. math ::
		    E = \sum_{j=0}^k |p(x_j) - y_j|^2
		
		in the equations::
		
		    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
		    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
		    ...
		    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]
		
		The coefficient matrix of the coefficients `p` is a Vandermonde matrix.
		
		`polyfit` issues a `RankWarning` when the least-squares fit is badly
		conditioned. This implies that the best fit is not well-defined due
		to numerical error. The results may be improved by lowering the polynomial
		degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
		can also be set to a value smaller than its default, but the resulting
		fit may be spurious: including contributions from the small singular
		values can add numerical noise to the result.
		
		Note that fitting polynomial coefficients is inherently badly conditioned
		when the degree of the polynomial is large or the interval of sample points
		is badly centered. The quality of the fit should always be checked in these
		cases. When polynomial fits are not satisfactory, splines may be a good
		alternative.
		
		References
		----------
		.. [1] Wikipedia, "Curve fitting",
		       https://en.wikipedia.org/wiki/Curve_fitting
		.. [2] Wikipedia, "Polynomial interpolation",
		       https://en.wikipedia.org/wiki/Polynomial_interpolation
		
		Examples
		--------
		>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
		>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
		>>> z = np.polyfit(x, y, 3)
		>>> z
		array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])
		
		It is convenient to use `poly1d` objects for dealing with polynomials:
		
		>>> p = np.poly1d(z)
		>>> p(0.5)
		0.6143849206349179
		>>> p(3.5)
		-0.34732142857143039
		>>> p(10)
		22.579365079365115
		
		High-order polynomials may oscillate wildly:
		
		>>> p30 = np.poly1d(np.polyfit(x, y, 30))
		/... RankWarning: Polyfit may be poorly conditioned...
		>>> p30(4)
		-0.80000000000000204
		>>> p30(5)
		-0.99999999999999445
		>>> p30(4.5)
		-0.10547061179440398
		
		Illustration:
		
		>>> import matplotlib.pyplot as plt
		>>> xp = np.linspace(-2, 6, 100)
		>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
		>>> plt.ylim(-2,2)
		(-2, 2)
		>>> plt.show()
	**/
	static public function polyfit(x:Dynamic, y:Dynamic, deg:Dynamic, ?rcond:Dynamic, ?full:Dynamic, ?w:Dynamic, ?cov:Dynamic):Dynamic;
	/**
		Return an antiderivative (indefinite integral) of a polynomial.
		
		The returned order `m` antiderivative `P` of polynomial `p` satisfies
		:math:`\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`
		integration constants `k`. The constants determine the low-order
		polynomial part
		
		.. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}
		
		of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.
		
		Parameters
		----------
		p : array_like or poly1d
		    Polynomial to integrate.
		    A sequence is interpreted as polynomial coefficients, see `poly1d`.
		m : int, optional
		    Order of the antiderivative. (Default: 1)
		k : list of `m` scalars or scalar, optional
		    Integration constants. They are given in the order of integration:
		    those corresponding to highest-order terms come first.
		
		    If ``None`` (default), all constants are assumed to be zero.
		    If `m = 1`, a single scalar can be given instead of a list.
		
		See Also
		--------
		polyder : derivative of a polynomial
		poly1d.integ : equivalent method
		
		Examples
		--------
		The defining property of the antiderivative:
		
		>>> p = np.poly1d([1,1,1])
		>>> P = np.polyint(p)
		>>> P
		poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])
		>>> np.polyder(P) == p
		True
		
		The integration constants default to zero, but can be specified:
		
		>>> P = np.polyint(p, 3)
		>>> P(0)
		0.0
		>>> np.polyder(P)(0)
		0.0
		>>> np.polyder(P, 2)(0)
		0.0
		>>> P = np.polyint(p, 3, k=[6,5,3])
		>>> P
		poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])
		
		Note that 3 = 6 / 2!, and that the constants are given in the order of
		integrations. Constant of the highest-order polynomial term comes first:
		
		>>> np.polyder(P, 2)(0)
		6.0
		>>> np.polyder(P, 1)(0)
		5.0
		>>> P(0)
		3.0
	**/
	static public function polyint(p:Dynamic, ?m:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Find the product of two polynomials.
		
		Finds the polynomial resulting from the multiplication of the two input
		polynomials. Each input must be either a poly1d object or a 1D sequence
		of polynomial coefficients, from highest to lowest degree.
		
		Parameters
		----------
		a1, a2 : array_like or poly1d object
		    Input polynomials.
		
		Returns
		-------
		out : ndarray or poly1d object
		    The polynomial resulting from the multiplication of the inputs. If
		    either inputs is a poly1d object, then the output is also a poly1d
		    object. Otherwise, it is a 1D array of polynomial coefficients from
		    highest to lowest degree.
		
		See Also
		--------
		poly1d : A one-dimensional polynomial class.
		poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,
		polyval
		convolve : Array convolution. Same output as polymul, but has parameter
		           for overlap mode.
		
		Examples
		--------
		>>> np.polymul([1, 2, 3], [9, 5, 1])
		array([ 9, 23, 38, 17,  3])
		
		Using poly1d objects:
		
		>>> p1 = np.poly1d([1, 2, 3])
		>>> p2 = np.poly1d([9, 5, 1])
		>>> print(p1)
		   2
		1 x + 2 x + 3
		>>> print(p2)
		   2
		9 x + 5 x + 1
		>>> print(np.polymul(p1, p2))
		   4      3      2
		9 x + 23 x + 38 x + 17 x + 3
	**/
	static public function polymul(a1:Dynamic, a2:Dynamic):Dynamic;
	/**
		Difference (subtraction) of two polynomials.
		
		Given two polynomials `a1` and `a2`, returns ``a1 - a2``.
		`a1` and `a2` can be either array_like sequences of the polynomials'
		coefficients (including coefficients equal to zero), or `poly1d` objects.
		
		Parameters
		----------
		a1, a2 : array_like or poly1d
		    Minuend and subtrahend polynomials, respectively.
		
		Returns
		-------
		out : ndarray or poly1d
		    Array or `poly1d` object of the difference polynomial's coefficients.
		
		See Also
		--------
		polyval, polydiv, polymul, polyadd
		
		Examples
		--------
		.. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)
		
		>>> np.polysub([2, 10, -2], [3, 10, -4])
		array([-1,  0,  2])
	**/
	static public function polysub(a1:Dynamic, a2:Dynamic):Dynamic;
	/**
		Evaluate a polynomial at specific values.
		
		If `p` is of length N, this function returns the value:
		
		    ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``
		
		If `x` is a sequence, then `p(x)` is returned for each element of `x`.
		If `x` is another polynomial then the composite polynomial `p(x(t))`
		is returned.
		
		Parameters
		----------
		p : array_like or poly1d object
		   1D array of polynomial coefficients (including coefficients equal
		   to zero) from highest degree to the constant term, or an
		   instance of poly1d.
		x : array_like or poly1d object
		   A number, an array of numbers, or an instance of poly1d, at
		   which to evaluate `p`.
		
		Returns
		-------
		values : ndarray or poly1d
		   If `x` is a poly1d instance, the result is the composition of the two
		   polynomials, i.e., `x` is "substituted" in `p` and the simplified
		   result is returned. In addition, the type of `x` - array_like or
		   poly1d - governs the type of the output: `x` array_like => `values`
		   array_like, `x` a poly1d object => `values` is also.
		
		See Also
		--------
		poly1d: A polynomial class.
		
		Notes
		-----
		Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
		for polynomials of high degree the values may be inaccurate due to
		rounding errors. Use carefully.
		
		References
		----------
		.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
		   trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand
		   Reinhold Co., 1985, pg. 720.
		
		Examples
		--------
		>>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1
		76
		>>> np.polyval([3,0,1], np.poly1d(5))
		poly1d([ 76.])
		>>> np.polyval(np.poly1d([3,0,1]), 5)
		76
		>>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
		poly1d([ 76.])
	**/
	static public function polyval(p:Dynamic, x:Dynamic):Dynamic;
	/**
		positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Numerical positive, element-wise.
		
		.. versionadded:: 1.13.0
		
		Parameters
		----------
		x : array_like or scalar
		    Input array.
		
		Returns
		-------
		y : ndarray or scalar
		    Returned array or scalar: `y = +x`.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		Equivalent to `x.copy()`, but only defined for types that support
		arithmetic.
	**/
	static public function positive(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		power(a, size=None)
		
		Draws samples in [0, 1] from a power distribution with positive
		exponent a - 1.
		
		Also known as the power function distribution.
		
		Parameters
		----------
		a : float or array_like of floats
		    Parameter of the distribution. Should be greater than zero.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``a`` is a scalar.  Otherwise,
		    ``np.array(a).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized power distribution.
		
		Raises
		------
		ValueError
		    If a < 1.
		
		Notes
		-----
		The probability density function is
		
		.. math:: P(x; a) = ax^{a-1}, 0 \le x \le 1, a>0.
		
		The power function distribution is just the inverse of the Pareto
		distribution. It may also be seen as a special case of the Beta
		distribution.
		
		It is used, for example, in modeling the over-reporting of insurance
		claims.
		
		References
		----------
		.. [1] Christian Kleiber, Samuel Kotz, "Statistical size distributions
		       in economics and actuarial sciences", Wiley, 2003.
		.. [2] Heckert, N. A. and Filliben, James J. "NIST Handbook 148:
		       Dataplot Reference Manual, Volume 2: Let Subcommands and Library
		       Functions", National Institute of Standards and Technology
		       Handbook Series, June 2003.
		       https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> a = 5. # shape
		>>> samples = 1000
		>>> s = np.random.power(a, samples)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, bins=30)
		>>> x = np.linspace(0, 1, 100)
		>>> y = a*x**(a-1.)
		>>> normed_y = samples*np.diff(bins)[0]*y
		>>> plt.plot(x, normed_y)
		>>> plt.show()
		
		Compare the power function distribution to the inverse of the Pareto.
		
		>>> from scipy import stats
		>>> rvs = np.random.power(5, 1000000)
		>>> rvsp = np.random.pareto(5, 1000000)
		>>> xx = np.linspace(0,1,100)
		>>> powpdf = stats.powerlaw.pdf(xx,5)
		
		>>> plt.figure()
		>>> plt.hist(rvs, bins=50, density=True)
		>>> plt.plot(xx,powpdf,'r-')
		>>> plt.title('np.random.power(5)')
		
		>>> plt.figure()
		>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
		>>> plt.plot(xx,powpdf,'r-')
		>>> plt.title('inverse of 1 + np.random.pareto(5)')
		
		>>> plt.figure()
		>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
		>>> plt.plot(xx,powpdf,'r-')
		>>> plt.title('inverse of stats.pareto(5)')
	**/
	static public function power(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the payment against loan principal.
		
		Parameters
		----------
		rate : array_like
		    Rate of interest (per period)
		per : array_like, int
		    Amount paid against the loan changes.  The `per` is the period of
		    interest.
		nper : array_like
		    Number of compounding periods
		pv : array_like
		    Present value
		fv : array_like, optional
		    Future value
		when : {{'begin', 1}, {'end', 0}}, {string, int}
		    When payments are due ('begin' (1) or 'end' (0))
		
		See Also
		--------
		pmt, pv, ipmt
	**/
	static public function ppmt(rate:Dynamic, per:Dynamic, nper:Dynamic, pv:Dynamic, ?fv:Dynamic, ?when:Dynamic):Dynamic;
	static public var print_function : Dynamic;
	/**
		Context manager for setting print options.
		
		Set print options for the scope of the `with` block, and restore the old
		options at the end. See `set_printoptions` for the full description of
		available options.
		
		Examples
		--------
		
		>>> with np.printoptions(precision=2):
		...     print(np.array([2.0])) / 3
		[0.67]
		
		The `as`-clause of the `with`-statement gives the current print options:
		
		>>> with np.printoptions(precision=2) as opts:
		...      assert_equal(opts, np.get_printoptions())
		
		See Also
		--------
		set_printoptions, get_printoptions
	**/
	static public function printoptions(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the colormap to "prism".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function prism():Dynamic;
	/**
		Return the product of array elements over a given axis.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which a product is performed.  The default,
		    axis=None, will calculate the product of all the elements in the
		    input array. If axis is negative it counts from the last to the
		    first axis.
		
		    .. versionadded:: 1.7.0
		
		    If axis is a tuple of ints, a product is performed on all of the
		    axes specified in the tuple instead of a single axis or all the
		    axes as before.
		dtype : dtype, optional
		    The type of the returned array, as well as of the accumulator in
		    which the elements are multiplied.  The dtype of `a` is used by
		    default unless `a` has an integer dtype of less precision than the
		    default platform integer.  In that case, if `a` is signed then the
		    platform integer is used while if `a` is unsigned then an unsigned
		    integer of the same precision as the platform integer is used.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must have
		    the same shape as the expected output, but the type of the output
		    values will be cast if necessary.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left in the
		    result as dimensions with size one. With this option, the result
		    will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `prod` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		initial : scalar, optional
		    The starting value for this product. See `~numpy.ufunc.reduce` for details.
		
		    .. versionadded:: 1.15.0
		
		Returns
		-------
		product_along_axis : ndarray, see `dtype` parameter above.
		    An array shaped as `a` but with the specified axis removed.
		    Returns a reference to `out` if specified.
		
		See Also
		--------
		ndarray.prod : equivalent method
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		Arithmetic is modular when using integer types, and no error is
		raised on overflow.  That means that, on a 32-bit platform:
		
		>>> x = np.array([536870910, 536870910, 536870910, 536870910])
		>>> np.prod(x)  # random
		16
		
		The product of an empty array is the neutral element 1:
		
		>>> np.prod([])
		1.0
		
		Examples
		--------
		By default, calculate the product of all elements:
		
		>>> np.prod([1.,2.])
		2.0
		
		Even when the input array is two-dimensional:
		
		>>> np.prod([[1.,2.],[3.,4.]])
		24.0
		
		But we can also specify the axis over which to multiply:
		
		>>> np.prod([[1.,2.],[3.,4.]], axis=1)
		array([  2.,  12.])
		
		If the type of `x` is unsigned, then the output type is
		the unsigned platform integer:
		
		>>> x = np.array([1, 2, 3], dtype=np.uint8)
		>>> np.prod(x).dtype == np.uint
		True
		
		If `x` is of a signed integer type, then the output type
		is the default platform integer:
		
		>>> x = np.array([1, 2, 3], dtype=np.int8)
		>>> np.prod(x).dtype == int
		True
		
		You can also start the product with a value other than one:
		
		>>> np.prod([1, 2], initial=5)
		10
	**/
	static public function prod(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic, ?initial:Dynamic):Dynamic;
	/**
		Return the product of array elements over a given axis.
		
		See Also
		--------
		prod : equivalent function; see for details.
	**/
	static public function product(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		promote_types(type1, type2)
		
		Returns the data type with the smallest size and smallest scalar
		kind to which both ``type1`` and ``type2`` may be safely cast.
		The returned data type is always in native byte order.
		
		This function is symmetric, but rarely associative.
		
		Parameters
		----------
		type1 : dtype or dtype specifier
		    First data type.
		type2 : dtype or dtype specifier
		    Second data type.
		
		Returns
		-------
		out : dtype
		    The promoted data type.
		
		Notes
		-----
		.. versionadded:: 1.6.0
		
		Starting in NumPy 1.9, promote_types function now returns a valid string
		length when given an integer or float dtype as one argument and a string
		dtype as another argument. Previously it always returned the input string
		dtype, even if it wasn't long enough to store the max integer/float value
		converted to a string.
		
		See Also
		--------
		result_type, dtype, can_cast
		
		Examples
		--------
		>>> np.promote_types('f4', 'f8')
		dtype('float64')
		
		>>> np.promote_types('i8', 'f4')
		dtype('float64')
		
		>>> np.promote_types('>i8', '<c8')
		dtype('complex128')
		
		>>> np.promote_types('i4', 'S8')
		dtype('S11')
		
		An example of a non-associative case:
		
		>>> p = np.promote_types
		>>> p('S', p('i1', 'u1'))
		dtype('S6')
		>>> p(p('S', 'i1'), 'u1')
		dtype('S4')
	**/
	static public function promote_types(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Plot the power spectral density.
		
		The power spectral density :math:`P_{xx}` by Welch's average
		periodogram method.  The vector *x* is divided into *NFFT* length
		segments.  Each segment is detrended by function *detrend* and
		windowed by function *window*.  *noverlap* gives the length of
		the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
		of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
		with a scaling to correct for power loss due to windowing.
		
		If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
		
		Parameters
		----------
		x : 1-D array or sequence
		    Array or sequence containing the data
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  This can be different from *NFFT*, which
		    specifies the number of data points used.  While not increasing
		    the actual resolution of the spectrum (the minimum distance between
		    resolvable peaks), this can give more points in the plot,
		    allowing for more detail. This corresponds to the *n* parameter
		    in the call to fft(). The default is None, which sets *pad_to*
		    equal to *NFFT*
		
		NFFT : int
		    The number of data points used in each block for the FFT.
		    A power 2 is most efficient.  The default value is 256.
		    This should *NOT* be used to get zero padding, or the scaling of the
		    result will be incorrect. Use *pad_to* for this instead.
		
		detrend : {'none', 'mean', 'linear'} or callable, default 'none'
		    The function applied to each segment before fft-ing, designed to
		    remove the mean or linear trend.  Unlike in MATLAB, where the
		    *detrend* parameter is a vector, in Matplotlib is it a function.
		    The :mod:`~matplotlib.mlab` module defines `.detrend_none`,
		    `.detrend_mean`, and `.detrend_linear`, but you can use a custom
		    function as well.  You can also use a string to choose one of the
		    functions: 'none' calls `.detrend_none`. 'mean' calls `.detrend_mean`.
		    'linear' calls `.detrend_linear`.
		
		scale_by_freq : bool, optional
		    Specifies whether the resulting density values should be scaled
		    by the scaling frequency, which gives density in units of Hz^-1.
		    This allows for integration over the returned frequency values.
		    The default is True for MATLAB compatibility.
		
		noverlap : int
		    The number of points of overlap between segments.
		    The default value is 0 (no overlap).
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		return_line : bool
		    Whether to include the line object plotted in the returned values.
		    Default is False.
		
		Returns
		-------
		Pxx : 1-D array
		    The values for the power spectrum `P_{xx}` before scaling
		    (real valued).
		
		freqs : 1-D array
		    The frequencies corresponding to the elements in *Pxx*.
		
		line : a :class:`~matplotlib.lines.Line2D` instance
		    The line created by this function.
		    Only returned if *return_line* is True.
		
		Other Parameters
		----------------
		**kwargs
		    Keyword arguments control the :class:`~matplotlib.lines.Line2D`
		    properties:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
		
		See Also
		--------
		:func:`specgram`
		    :func:`specgram` differs in the default overlap; in not returning
		    the mean of the segment periodograms; in returning the times of the
		    segments; and in plotting a colormap instead of a line.
		
		:func:`magnitude_spectrum`
		    :func:`magnitude_spectrum` plots the magnitude spectrum.
		
		:func:`csd`
		    :func:`csd` plots the spectral density between two signals.
		
		Notes
		-----
		For plotting, the power is plotted as
		:math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
		is returned.
		
		References
		----------
		Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
		John Wiley & Sons (1986)
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function psd(x:Dynamic, ?NFFT:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?detrend:Dynamic, ?window:Dynamic, ?noverlap:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?scale_by_freq:Dynamic, ?return_line:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Range of values (maximum - minimum) along an axis.
		
		The name of the function comes from the acronym for 'peak to peak'.
		
		Parameters
		----------
		a : array_like
		    Input values.
		axis : None or int or tuple of ints, optional
		    Axis along which to find the peaks.  By default, flatten the
		    array.  `axis` may be negative, in
		    which case it counts from the last to the first axis.
		
		    .. versionadded:: 1.15.0
		
		    If this is a tuple of ints, a reduction is performed on multiple
		    axes, instead of a single axis or all the axes as before.
		out : array_like
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type of the output values will be cast if necessary.
		
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `ptp` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		ptp : ndarray
		    A new array holding the result, unless `out` was
		    specified, in which case a reference to `out` is returned.
		
		Examples
		--------
		>>> x = np.arange(4).reshape((2,2))
		>>> x
		array([[0, 1],
		       [2, 3]])
		
		>>> np.ptp(x, axis=0)
		array([2, 2])
		
		>>> np.ptp(x, axis=1)
		array([1, 1])
	**/
	static public function ptp(a:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Replaces specified elements of an array with given values.
		
		The indexing works on the flattened target array. `put` is roughly
		equivalent to:
		
		::
		
		    a.flat[ind] = v
		
		Parameters
		----------
		a : ndarray
		    Target array.
		ind : array_like
		    Target indices, interpreted as integers.
		v : array_like
		    Values to place in `a` at target indices. If `v` is shorter than
		    `ind` it will be repeated as necessary.
		mode : {'raise', 'wrap', 'clip'}, optional
		    Specifies how out-of-bounds indices will behave.
		
		    * 'raise' -- raise an error (default)
		    * 'wrap' -- wrap around
		    * 'clip' -- clip to the range
		
		    'clip' mode means that all indices that are too large are replaced
		    by the index that addresses the last element along that axis. Note
		    that this disables indexing with negative numbers.
		
		See Also
		--------
		putmask, place
		put_along_axis : Put elements by matching the array and the index arrays
		
		Examples
		--------
		>>> a = np.arange(5)
		>>> np.put(a, [0, 2], [-44, -55])
		>>> a
		array([-44,   1, -55,   3,   4])
		
		>>> a = np.arange(5)
		>>> np.put(a, 22, -5, mode='clip')
		>>> a
		array([ 0,  1,  2,  3, -5])
	**/
	static public function put(a:Dynamic, ind:Dynamic, v:Dynamic, ?mode:Dynamic):Dynamic;
	/**
		Put values into the destination array by matching 1d index and data slices.
		
		This iterates over matching 1d slices oriented along the specified axis in
		the index and data arrays, and uses the former to place values into the
		latter. These slices can be different lengths.
		
		Functions returning an index along an axis, like `argsort` and
		`argpartition`, produce suitable indices for this function.
		
		.. versionadded:: 1.15.0
		
		Parameters
		----------
		arr: ndarray (Ni..., M, Nk...)
		    Destination array.
		indices: ndarray (Ni..., J, Nk...)
		    Indices to change along each 1d slice of `arr`. This must match the
		    dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
		    against `arr`.
		values: array_like (Ni..., J, Nk...)
		    values to insert at those indices. Its shape and dimension are
		    broadcast to match that of `indices`.
		axis: int
		    The axis to take 1d slices along. If axis is None, the destination
		    array is treated as if a flattened 1d view had been created of it.
		
		Notes
		-----
		This is equivalent to (but faster than) the following use of `ndindex` and
		`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::
		
		    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
		    J = indices.shape[axis]  # Need not equal M
		
		    for ii in ndindex(Ni):
		        for kk in ndindex(Nk):
		            a_1d       = a      [ii + s_[:,] + kk]
		            indices_1d = indices[ii + s_[:,] + kk]
		            values_1d  = values [ii + s_[:,] + kk]
		            for j in range(J):
		                a_1d[indices_1d[j]] = values_1d[j]
		
		Equivalently, eliminating the inner loop, the last two lines would be::
		
		            a_1d[indices_1d] = values_1d
		
		See Also
		--------
		take_along_axis :
		    Take values from the input array by matching 1d index and data slices
		
		Examples
		--------
		
		For this sample array
		
		>>> a = np.array([[10, 30, 20], [60, 40, 50]])
		
		We can replace the maximum values with:
		
		>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
		>>> ai
		array([[1],
		       [0]], dtype=int64)
		>>> np.put_along_axis(a, ai, 99, axis=1)
		>>> a
		array([[10, 99, 20],
		       [99, 40, 50]])
	**/
	static public function put_along_axis(arr:Dynamic, indices:Dynamic, values:Dynamic, axis:Dynamic):Dynamic;
	/**
		putmask(a, mask, values)
		
		Changes elements of an array based on conditional and input values.
		
		Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.
		
		If `values` is not the same size as `a` and `mask` then it will repeat.
		This gives behavior different from ``a[mask] = values``.
		
		Parameters
		----------
		a : array_like
		    Target array.
		mask : array_like
		    Boolean mask array. It has to be the same shape as `a`.
		values : array_like
		    Values to put into `a` where `mask` is True. If `values` is smaller
		    than `a` it will be repeated.
		
		See Also
		--------
		place, put, take, copyto
		
		Examples
		--------
		>>> x = np.arange(6).reshape(2, 3)
		>>> np.putmask(x, x>2, x**2)
		>>> x
		array([[ 0,  1,  2],
		       [ 9, 16, 25]])
		
		If `values` is smaller than `a` it is repeated:
		
		>>> x = np.arange(5)
		>>> np.putmask(x, x>1, [-33, -44])
		>>> x
		array([  0,   1, -33, -44, -33])
	**/
	static public function putmask(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the present value.
		
		Given:
		 * a future value, `fv`
		 * an interest `rate` compounded once per period, of which
		   there are
		 * `nper` total
		 * a (fixed) payment, `pmt`, paid either
		 * at the beginning (`when` = {'begin', 1}) or the end
		   (`when` = {'end', 0}) of each period
		
		Return:
		   the value now
		
		Parameters
		----------
		rate : array_like
		    Rate of interest (per period)
		nper : array_like
		    Number of compounding periods
		pmt : array_like
		    Payment
		fv : array_like, optional
		    Future value
		when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
		    When payments are due ('begin' (1) or 'end' (0))
		
		Returns
		-------
		out : ndarray, float
		    Present value of a series of payments or investments.
		
		Notes
		-----
		The present value is computed by solving the equation::
		
		 fv +
		 pv*(1 + rate)**nper +
		 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0
		
		or, when ``rate = 0``::
		
		 fv + pv + pmt * nper = 0
		
		for `pv`, which is then returned.
		
		References
		----------
		.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
		   Open Document Format for Office Applications (OpenDocument)v1.2,
		   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
		   Pre-Draft 12. Organization for the Advancement of Structured Information
		   Standards (OASIS). Billerica, MA, USA. [ODT Document].
		   Available:
		   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
		   OpenDocument-formula-20090508.odt
		
		Examples
		--------
		What is the present value (e.g., the initial investment)
		of an investment that needs to total $15692.93
		after 10 years of saving $100 every month?  Assume the
		interest rate is 5% (annually) compounded monthly.
		
		>>> np.pv(0.05/12, 10*12, -100, 15692.93)
		-100.00067131625819
		
		By convention, the negative sign represents cash flow out
		(i.e., money not available today).  Thus, to end up with
		$15,692.93 in 10 years saving $100 a month at 5% annual
		interest, one's initial deposit should also be $100.
		
		If any input is array_like, ``pv`` returns an array of equal shape.
		Let's compare different interest rates in the example above:
		
		>>> a = np.array((0.05, 0.04, 0.03))/12
		>>> np.pv(a, 10*12, -100, 15692.93)
		array([ -100.00067132,  -649.26771385, -1273.78633713])
		
		So, to end up with the same $15692.93 under the same $100 per month
		"savings plan," for annual interest rates of 4% and 3%, one would
		need initial investments of $649.27 and $1273.79, respectively.
	**/
	static public function pv(rate:Dynamic, nper:Dynamic, pmt:Dynamic, ?fv:Dynamic, ?when:Dynamic):Dynamic;
	/**
		[*Deprecated*] Return new_figure_manager, draw_if_interactive and show for pyplot.
		
		This provides the backend-specific functions that are used by pyplot to
		abstract away the difference between backends.
		
		Parameters
		----------
		name : str, optional
		    The name of the backend to use.  If `None`, falls back to
		    ``matplotlib.get_backend()`` (which return :rc:`backend`).
		
		Returns
		-------
		backend_mod : module
		    The module which contains the backend of choice
		
		new_figure_manager : function
		    Create a new figure manager (roughly maps to GUI window)
		
		draw_if_interactive : function
		    Redraw the current figure if pyplot is interactive
		
		show : function
		    Show (and possibly block) any unshown figures.
		
		Notes
		-----
		.. deprecated:: 3.0
		   
	**/
	static public function pylab_setup(?name:Dynamic):Dynamic;
	/**
		Compute the qr factorization of a matrix.
		
		Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
		upper-triangular.
		
		Parameters
		----------
		a : array_like, shape (M, N)
		    Matrix to be factored.
		mode : {'reduced', 'complete', 'r', 'raw', 'full', 'economic'}, optional
		    If K = min(M, N), then
		
		    * 'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
		    * 'complete' : returns q, r with dimensions (M, M), (M, N)
		    * 'r'        : returns r only with dimensions (K, N)
		    * 'raw'      : returns h, tau with dimensions (N, M), (K,)
		    * 'full'     : alias of 'reduced', deprecated
		    * 'economic' : returns h from 'raw', deprecated.
		
		    The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
		    see the notes for more information. The default is 'reduced', and to
		    maintain backward compatibility with earlier versions of numpy both
		    it and the old default 'full' can be omitted. Note that array h
		    returned in 'raw' mode is transposed for calling Fortran. The
		    'economic' mode is deprecated.  The modes 'full' and 'economic' may
		    be passed using only the first letter for backwards compatibility,
		    but all others must be spelled out. See the Notes for more
		    explanation.
		
		
		Returns
		-------
		q : ndarray of float or complex, optional
		    A matrix with orthonormal columns. When mode = 'complete' the
		    result is an orthogonal/unitary matrix depending on whether or not
		    a is real/complex. The determinant may be either +/- 1 in that
		    case.
		r : ndarray of float or complex, optional
		    The upper-triangular matrix.
		(h, tau) : ndarrays of np.double or np.cdouble, optional
		    The array h contains the Householder reflectors that generate q
		    along with r. The tau array contains scaling factors for the
		    reflectors. In the deprecated  'economic' mode only h is returned.
		
		Raises
		------
		LinAlgError
		    If factoring fails.
		
		Notes
		-----
		This is an interface to the LAPACK routines dgeqrf, zgeqrf,
		dorgqr, and zungqr.
		
		For more information on the qr factorization, see for example:
		https://en.wikipedia.org/wiki/QR_factorization
		
		Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
		`a` is of type `matrix`, all the return values will be matrices too.
		
		New 'reduced', 'complete', and 'raw' options for mode were added in
		NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
		addition the options 'full' and 'economic' were deprecated.  Because
		'full' was the previous default and 'reduced' is the new default,
		backward compatibility can be maintained by letting `mode` default.
		The 'raw' option was added so that LAPACK routines that can multiply
		arrays by q using the Householder reflectors can be used. Note that in
		this case the returned arrays are of type np.double or np.cdouble and
		the h array is transposed to be FORTRAN compatible.  No routines using
		the 'raw' return are currently exposed by numpy, but some are available
		in lapack_lite and just await the necessary work.
		
		Examples
		--------
		>>> a = np.random.randn(9, 6)
		>>> q, r = np.linalg.qr(a)
		>>> np.allclose(a, np.dot(q, r))  # a does equal qr
		True
		>>> r2 = np.linalg.qr(a, mode='r')
		>>> r3 = np.linalg.qr(a, mode='economic')
		>>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
		True
		>>> # But only triu parts are guaranteed equal when mode='economic'
		>>> np.allclose(r, np.triu(r3[:6,:6], k=0))
		True
		
		Example illustrating a common use of `qr`: solving of least squares
		problems
		
		What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
		the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
		and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
		by solving the over-determined matrix equation ``Ax = b``, where::
		
		  A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
		  x = array([[y0], [m]])
		  b = array([[1], [0], [2], [1]])
		
		If A = qr such that q is orthonormal (which is always possible via
		Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
		however, we simply use `lstsq`.)
		
		>>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
		>>> A
		array([[0, 1],
		       [1, 1],
		       [1, 1],
		       [2, 1]])
		>>> b = np.array([1, 0, 2, 1])
		>>> q, r = LA.qr(A)
		>>> p = np.dot(q.T, b)
		>>> np.dot(LA.inv(r), p)
		array([  1.1e-16,   1.0e+00])
	**/
	static public function qr(a:Dynamic, ?mode:Dynamic):Dynamic;
	/**
		Compute the q-th quantile of the data along the specified axis.
		..versionadded:: 1.15.0
		
		Parameters
		----------
		a : array_like
		    Input array or object that can be converted to an array.
		q : array_like of float
		    Quantile or sequence of quantiles to compute, which must be between
		    0 and 1 inclusive.
		axis : {int, tuple of int, None}, optional
		    Axis or axes along which the quantiles are computed. The
		    default is to compute the quantile(s) along a flattened
		    version of the array.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must
		    have the same shape and buffer length as the expected output,
		    but the type (of the output) will be cast if necessary.
		overwrite_input : bool, optional
		    If True, then allow the input array `a` to be modified by intermediate
		    calculations, to save memory. In this case, the contents of the input
		    `a` after this function completes is undefined.
		interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
		    This optional parameter specifies the interpolation method to
		    use when the desired quantile lies between two data points
		    ``i < j``:
		
		        * linear: ``i + (j - i) * fraction``, where ``fraction``
		          is the fractional part of the index surrounded by ``i``
		          and ``j``.
		        * lower: ``i``.
		        * higher: ``j``.
		        * nearest: ``i`` or ``j``, whichever is nearest.
		        * midpoint: ``(i + j) / 2``.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left in
		    the result as dimensions with size one. With this option, the
		    result will broadcast correctly against the original array `a`.
		
		Returns
		-------
		quantile : scalar or ndarray
		    If `q` is a single quantile and `axis=None`, then the result
		    is a scalar. If multiple quantiles are given, first axis of
		    the result corresponds to the quantiles. The other axes are
		    the axes that remain after the reduction of `a`. If the input
		    contains integers or floats smaller than ``float64``, the output
		    data-type is ``float64``. Otherwise, the output data-type is the
		    same as that of the input. If `out` is specified, that array is
		    returned instead.
		
		See Also
		--------
		mean
		percentile : equivalent to quantile, but with q in the range [0, 100].
		median : equivalent to ``quantile(..., 0.5)``
		nanquantile
		
		Notes
		-----
		Given a vector ``V`` of length ``N``, the q-th quantile of
		``V`` is the value ``q`` of the way from the minimum to the
		maximum in a sorted copy of ``V``. The values and distances of
		the two nearest neighbors as well as the `interpolation` parameter
		will determine the quantile if the normalized ranking does not
		match the location of ``q`` exactly. This function is the same as
		the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and the
		same as the maximum if ``q=1.0``.
		
		Examples
		--------
		>>> a = np.array([[10, 7, 4], [3, 2, 1]])
		>>> a
		array([[10,  7,  4],
		       [ 3,  2,  1]])
		>>> np.quantile(a, 0.5)
		3.5
		>>> np.quantile(a, 0.5, axis=0)
		array([[ 6.5,  4.5,  2.5]])
		>>> np.quantile(a, 0.5, axis=1)
		array([ 7.,  2.])
		>>> np.quantile(a, 0.5, axis=1, keepdims=True)
		array([[ 7.],
		       [ 2.]])
		>>> m = np.quantile(a, 0.5, axis=0)
		>>> out = np.zeros_like(m)
		>>> np.quantile(a, 0.5, axis=0, out=out)
		array([[ 6.5,  4.5,  2.5]])
		>>> m
		array([[ 6.5,  4.5,  2.5]])
		>>> b = a.copy()
		>>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
		array([ 7.,  2.])
		>>> assert not np.all(a == b)
	**/
	static public function quantile(a:Dynamic, q:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?overwrite_input:Dynamic, ?interpolation:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Plot a 2D field of arrows.
		
		Call signature::
		
		  quiver([X, Y], U, V, [C], **kw)
		
		Where *X*, *Y* define the arrow locations, *U*, *V* define the arrow
		directions, and *C* optionally sets the color.
		
		**Arrow size**
		
		The default settings auto-scales the length of the arrows to a reasonable size.
		To change this behavior see the *scale* and *scale_units* parameters.
		
		**Arrow shape**
		
		The defaults give a slightly swept-back arrow; to make the head a
		triangle, make *headaxislength* the same as *headlength*. To make the
		arrow more pointed, reduce *headwidth* or increase *headlength* and
		*headaxislength*. To make the head smaller relative to the shaft,
		scale down all the head parameters. You will probably do best to leave
		minshaft alone.
		
		**Arrow outline**
		
		*linewidths* and *edgecolors* can be used to customize the arrow
		outlines.
		
		Parameters
		----------
		X, Y : 1D or 2D array-like, optional
		    The x and y coordinates of the arrow locations.
		
		    If not given, they will be generated as a uniform integer meshgrid based
		    on the dimensions of *U* and *V*.
		
		    If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D
		    using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)``
		    must match the column and row dimensions of *U* and *V*.
		
		U, V : 1D or 2D array-like
		    The x and y direction components of the arrow vectors.
		
		C : 1D or 2D array-like, optional
		    Numeric data that defines the arrow colors by colormapping via *norm* and
		    *cmap*.
		
		    This does not support explicit colors. If you want to set colors directly,
		    use *color* instead.
		
		units : {'width', 'height', 'dots', 'inches', 'x', 'y' 'xy'}, default: 'width'
		    The arrow dimensions (except for *length*) are measured in multiples of
		    this unit.
		
		    The following values are supported:
		
		    - 'width', 'height': The width or height of the axis.
		    - 'dots', 'inches': Pixels or inches based on the figure dpi.
		    - 'x', 'y', 'xy': *X*, *Y* or :math:`\sqrt{X^2 + Y^2}` in data units.
		
		    The arrows scale differently depending on the units.  For
		    'x' or 'y', the arrows get larger as one zooms in; for other
		    units, the arrow size is independent of the zoom state.  For
		    'width or 'height', the arrow size increases with the width and
		    height of the axes, respectively, when the window is resized;
		    for 'dots' or 'inches', resizing does not change the arrows.
		
		angles : {'uv', 'xy'} or array-like, optional, default: 'uv'
		    Method for determining the angle of the arrows.
		
		    - 'uv': The arrow axis aspect ratio is 1 so that
		      if *U* == *V* the orientation of the arrow on the plot is 45 degrees
		      counter-clockwise from the horizontal axis (positive to the right).
		
		      Use this if the arrows symbolize a quantity that is not based on
		      *X*, *Y* data coordinates.
		
		    - 'xy': Arrows point from (x,y) to (x+u, y+v).
		      Use this for plotting a gradient field, for example.
		
		    - Alternatively, arbitrary angles may be specified explicitly as an array
		      of values in degrees, counter-clockwise from the horizontal axis.
		
		      In this case *U*, *V* is only used to determine the length of the
		      arrows.
		
		    Note: inverting a data axis will correspondingly invert the
		    arrows only with ``angles='xy'``.
		
		scale : float, optional
		    Number of data units per arrow length unit, e.g., m/s per plot width; a
		    smaller scale parameter makes the arrow longer. Default is *None*.
		
		    If *None*, a simple autoscaling algorithm is used, based on the average
		    vector length and the number of vectors. The arrow length unit is given by
		    the *scale_units* parameter.
		
		scale_units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional
		    If the *scale* kwarg is *None*, the arrow length unit. Default is *None*.
		
		    e.g. *scale_units* is 'inches', *scale* is 2.0, and
		    ``(u,v) = (1,0)``, then the vector will be 0.5 inches long.
		
		    If *scale_units* is 'width' or 'height', then the vector will be half the
		    width/height of the axes.
		
		    If *scale_units* is 'x' then the vector will be 0.5 x-axis
		    units. To plot vectors in the x-y plane, with u and v having
		    the same units as x and y, use
		    ``angles='xy', scale_units='xy', scale=1``.
		
		width : float, optional
		    Shaft width in arrow units; default depends on choice of units,
		    above, and number of vectors; a typical starting value is about
		    0.005 times the width of the plot.
		
		headwidth : float, optional, default: 3
		    Head width as multiple of shaft width.
		
		headlength : float, optional, default: 5
		    Head length as multiple of shaft width.
		
		headaxislength : float, optional, default: 4.5
		    Head length at shaft intersection.
		
		minshaft : float, optional, default: 1
		    Length below which arrow scales, in units of head length. Do not
		    set this to less than 1, or small arrows will look terrible!
		
		minlength : float, optional, default: 1
		    Minimum length as a multiple of shaft width; if an arrow length
		    is less than this, plot a dot (hexagon) of this diameter instead.
		
		pivot : {'tail', 'mid', 'middle', 'tip'}, optional, default: 'tail'
		    The part of the arrow that is anchored to the *X*, *Y* grid. The arrow
		    rotates about this point.
		
		    'mid' is a synonym for 'middle'.
		
		color : color or color sequence, optional
		    Explicit color(s) for the arrows. If *C* has been set, *color* has no
		    effect.
		
		    This is a synonym for the `~.PolyCollection` *facecolor* parameter.
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.collections.PolyCollection` properties, optional
		    All other keyword arguments are passed on to `.PolyCollection`:
		
		      agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float or None
		  animated: bool
		  antialiased or aa or antialiaseds: bool or sequence of bools
		  array: ndarray
		  capstyle: {'butt', 'round', 'projecting'}
		  clim: a length 2 sequence of floats; may be overridden in methods that have ``vmin`` and ``vmax`` kwargs.
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  cmap: colormap or registered colormap name
		  color: color or sequence of rgba tuples
		  contains: callable
		  edgecolor or ec or edgecolors: color or sequence of colors or 'face'
		  facecolor or facecolors or fc: color or sequence of colors
		  figure: `.Figure`
		  gid: str
		  hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
		  in_layout: bool
		  joinstyle: {'miter', 'round', 'bevel'}
		  label: object
		  linestyle or dashes or linestyles or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or linewidths or lw: float or sequence of floats
		  norm: `.Normalize`
		  offset_position: {'screen', 'data'}
		  offsets: float or sequence of floats
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  pickradius: unknown
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  urls: List[str] or None
		  visible: bool
		  zorder: float
		
		See Also
		--------
		quiverkey : Add a key to a quiver plot.
	**/
	static public function quiver(?args:python.VarArgs<Dynamic>, ?data:Dynamic, ?kw:python.KwArgs<Dynamic>):Dynamic;
	/**
		Add a key to a quiver plot.
		
		Call signature::
		
		  quiverkey(Q, X, Y, U, label, **kw)
		
		Arguments:
		
		  *Q*:
		    The Quiver instance returned by a call to quiver.
		
		  *X*, *Y*:
		    The location of the key; additional explanation follows.
		
		  *U*:
		    The length of the key
		
		  *label*:
		    A string with the length and units of the key
		
		Keyword arguments:
		
		  *angle* = 0
		    The angle of the key arrow. Measured in degrees anti-clockwise from the
		    x-axis.
		
		  *coordinates* = [ 'axes' | 'figure' | 'data' | 'inches' ]
		    Coordinate system and units for *X*, *Y*: 'axes' and 'figure' are
		    normalized coordinate systems with 0,0 in the lower left and 1,1
		    in the upper right; 'data' are the axes data coordinates (used for
		    the locations of the vectors in the quiver plot itself); 'inches'
		    is position in the figure in inches, with 0,0 at the lower left
		    corner.
		
		  *color*:
		    overrides face and edge colors from *Q*.
		
		  *labelpos* = [ 'N' | 'S' | 'E' | 'W' ]
		    Position the label above, below, to the right, to the left of the
		    arrow, respectively.
		
		  *labelsep*:
		    Distance in inches between the arrow and the label.  Default is
		    0.1
		
		  *labelcolor*:
		    defaults to default :class:`~matplotlib.text.Text` color.
		
		  *fontproperties*:
		    A dictionary with keyword arguments accepted by the
		    :class:`~matplotlib.font_manager.FontProperties` initializer:
		    *family*, *style*, *variant*, *size*, *weight*
		
		Any additional keyword arguments are used to override vector
		properties taken from *Q*.
		
		The positioning of the key depends on *X*, *Y*, *coordinates*, and
		*labelpos*.  If *labelpos* is 'N' or 'S', *X*, *Y* give the position
		of the middle of the key arrow.  If *labelpos* is 'E', *X*, *Y*
		positions the head, and if *labelpos* is 'W', *X*, *Y* positions the
		tail; in either of these two cases, *X*, *Y* is somewhere in the
		middle of the arrow+label key object.
	**/
	static public function quiverkey(Q:Dynamic, X:Dynamic, Y:Dynamic, U:Dynamic, label:Dynamic, ?kw:python.KwArgs<Dynamic>):Dynamic;
	static public var r_ : Dynamic;
	/**
		rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Convert angles from radians to degrees.
		
		Parameters
		----------
		x : array_like
		    Angle in radians.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding angle in degrees.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		deg2rad : Convert angles from degrees to radians.
		unwrap : Remove large jumps in angle by wrapping.
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		rad2deg(x) is ``180 * x / pi``.
		
		Examples
		--------
		>>> np.rad2deg(np.pi/2)
		90.0
	**/
	static public function rad2deg(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Convert angles from degrees to radians.
		
		Parameters
		----------
		x : array_like
		    Input array in degrees.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding radian values.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		deg2rad : equivalent function
		
		Examples
		--------
		Convert a degree array to radians
		
		>>> deg = np.arange(12.) * 30.
		>>> np.radians(deg)
		array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
		        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
		        5.23598776,  5.75958653])
		
		>>> out = np.zeros((deg.shape))
		>>> ret = np.radians(deg, out)
		>>> ret is out
		True
	**/
	static public function radians(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		rand(d0, d1, ..., dn)
		
		Random values in a given shape.
		
		Create an array of the given shape and populate it with
		random samples from a uniform distribution
		over ``[0, 1)``.
		
		Parameters
		----------
		d0, d1, ..., dn : int, optional
		    The dimensions of the returned array, should all be positive.
		    If no argument is given a single Python float is returned.
		
		Returns
		-------
		out : ndarray, shape ``(d0, d1, ..., dn)``
		    Random values.
		
		See Also
		--------
		random
		
		Notes
		-----
		This is a convenience function. If you want an interface that
		takes a shape-tuple as the first argument, refer to
		np.random.random_sample .
		
		Examples
		--------
		>>> np.random.rand(3,2)
		array([[ 0.14022471,  0.96360618],  #random
		       [ 0.37601032,  0.25528411],  #random
		       [ 0.49313049,  0.94909878]]) #random
	**/
	static public function rand(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		randint(low, high=None, size=None, dtype='l')
		
		Return random integers from `low` (inclusive) to `high` (exclusive).
		
		Return random integers from the "discrete uniform" distribution of
		the specified dtype in the "half-open" interval [`low`, `high`). If
		`high` is None (the default), then results are from [0, `low`).
		
		Parameters
		----------
		low : int
		    Lowest (signed) integer to be drawn from the distribution (unless
		    ``high=None``, in which case this parameter is one above the
		    *highest* such integer).
		high : int, optional
		    If provided, one above the largest (signed) integer to be drawn
		    from the distribution (see above for behavior if ``high=None``).
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		dtype : dtype, optional
		    Desired dtype of the result. All dtypes are determined by their
		    name, i.e., 'int64', 'int', etc, so byteorder is not available
		    and a specific precision may have different C types depending
		    on the platform. The default value is 'np.int'.
		
		    .. versionadded:: 1.11.0
		
		Returns
		-------
		out : int or ndarray of ints
		    `size`-shaped array of random integers from the appropriate
		    distribution, or a single such random int if `size` not provided.
		
		See Also
		--------
		random.random_integers : similar to `randint`, only for the closed
		    interval [`low`, `high`], and 1 is the lowest value if `high` is
		    omitted. In particular, this other one is the one to use to generate
		    uniformly distributed discrete non-integers.
		
		Examples
		--------
		>>> np.random.randint(2, size=10)
		array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])
		>>> np.random.randint(1, size=10)
		array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
		
		Generate a 2 x 4 array of ints between 0 and 4, inclusive:
		
		>>> np.random.randint(5, size=(2, 4))
		array([[4, 0, 2, 1],
		       [3, 2, 2, 0]])
	**/
	static public function randint(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		randn(d0, d1, ..., dn)
		
		Return a sample (or samples) from the "standard normal" distribution.
		
		If positive, int_like or int-convertible arguments are provided,
		`randn` generates an array of shape ``(d0, d1, ..., dn)``, filled
		with random floats sampled from a univariate "normal" (Gaussian)
		distribution of mean 0 and variance 1 (if any of the :math:`d_i` are
		floats, they are first converted to integers by truncation). A single
		float randomly sampled from the distribution is returned if no
		argument is provided.
		
		This is a convenience function.  If you want an interface that takes a
		tuple as the first argument, use `numpy.random.standard_normal` instead.
		
		Parameters
		----------
		d0, d1, ..., dn : int, optional
		    The dimensions of the returned array, should be all positive.
		    If no argument is given a single Python float is returned.
		
		Returns
		-------
		Z : ndarray or float
		    A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
		    the standard normal distribution, or a single such float if
		    no parameters were supplied.
		
		See Also
		--------
		standard_normal : Similar, but takes a tuple as its argument.
		
		Notes
		-----
		For random samples from :math:`N(\mu, \sigma^2)`, use:
		
		``sigma * np.random.randn(...) + mu``
		
		Examples
		--------
		>>> np.random.randn()
		2.1923875335537315 #random
		
		Two-by-four array of samples from N(3, 6.25):
		
		>>> 2.5 * np.random.randn(2, 4) + 3
		array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random
		       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random
	**/
	static public function randn(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		random_sample(size=None)
		
		Return random floats in the half-open interval [0.0, 1.0).
		
		Results are from the "continuous uniform" distribution over the
		stated interval.  To sample :math:`Unif[a, b), b > a` multiply
		the output of `random_sample` by `(b-a)` and add `a`::
		
		  (b - a) * random_sample() + a
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray of floats
		    Array of random floats of shape `size` (unless ``size=None``, in which
		    case a single float is returned).
		
		Examples
		--------
		>>> np.random.random_sample()
		0.47108547995356098
		>>> type(np.random.random_sample())
		<type 'float'>
		>>> np.random.random_sample((5,))
		array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
		
		Three-by-two array of random numbers from [-5, 0):
		
		>>> 5 * np.random.random_sample((3, 2)) - 5
		array([[-3.99149989, -0.52338984],
		       [-2.99091858, -0.79479508],
		       [-1.23204345, -1.75224494]])
	**/
	static public function random(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		random_integers(low, high=None, size=None)
		
		Random integers of type np.int between `low` and `high`, inclusive.
		
		Return random integers of type np.int from the "discrete uniform"
		distribution in the closed interval [`low`, `high`].  If `high` is
		None (the default), then results are from [1, `low`]. The np.int
		type translates to the C long type used by Python 2 for "short"
		integers and its precision is platform dependent.
		
		This function has been deprecated. Use randint instead.
		
		.. deprecated:: 1.11.0
		
		Parameters
		----------
		low : int
		    Lowest (signed) integer to be drawn from the distribution (unless
		    ``high=None``, in which case this parameter is the *highest* such
		    integer).
		high : int, optional
		    If provided, the largest (signed) integer to be drawn from the
		    distribution (see above for behavior if ``high=None``).
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : int or ndarray of ints
		    `size`-shaped array of random integers from the appropriate
		    distribution, or a single such random int if `size` not provided.
		
		See Also
		--------
		randint : Similar to `random_integers`, only for the half-open
		    interval [`low`, `high`), and 0 is the lowest value if `high` is
		    omitted.
		
		Notes
		-----
		To sample from N evenly spaced floating-point numbers between a and b,
		use::
		
		  a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)
		
		Examples
		--------
		>>> np.random.random_integers(5)
		4
		>>> type(np.random.random_integers(5))
		<type 'int'>
		>>> np.random.random_integers(5, size=(3,2))
		array([[5, 4],
		       [3, 3],
		       [4, 5]])
		
		Choose five random numbers from the set of five evenly-spaced
		numbers between 0 and 2.5, inclusive (*i.e.*, from the set
		:math:`{0, 5/8, 10/8, 15/8, 20/8}`):
		
		>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
		array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ])
		
		Roll two six sided dice 1000 times and sum the results:
		
		>>> d1 = np.random.random_integers(1, 6, 1000)
		>>> d2 = np.random.random_integers(1, 6, 1000)
		>>> dsums = d1 + d2
		
		Display results as a histogram:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
		>>> plt.show()
	**/
	static public function random_integers(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		random_sample(size=None)
		
		Return random floats in the half-open interval [0.0, 1.0).
		
		Results are from the "continuous uniform" distribution over the
		stated interval.  To sample :math:`Unif[a, b), b > a` multiply
		the output of `random_sample` by `(b-a)` and add `a`::
		
		  (b - a) * random_sample() + a
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray of floats
		    Array of random floats of shape `size` (unless ``size=None``, in which
		    case a single float is returned).
		
		Examples
		--------
		>>> np.random.random_sample()
		0.47108547995356098
		>>> type(np.random.random_sample())
		<type 'float'>
		>>> np.random.random_sample((5,))
		array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
		
		Three-by-two array of random numbers from [-5, 0):
		
		>>> 5 * np.random.random_sample((3, 2)) - 5
		array([[-3.99149989, -0.52338984],
		       [-2.99091858, -0.79479508],
		       [-1.23204345, -1.75224494]])
	**/
	static public function random_sample(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		random_sample(size=None)
		
		Return random floats in the half-open interval [0.0, 1.0).
		
		Results are from the "continuous uniform" distribution over the
		stated interval.  To sample :math:`Unif[a, b), b > a` multiply
		the output of `random_sample` by `(b-a)` and add `a`::
		
		  (b - a) * random_sample() + a
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray of floats
		    Array of random floats of shape `size` (unless ``size=None``, in which
		    case a single float is returned).
		
		Examples
		--------
		>>> np.random.random_sample()
		0.47108547995356098
		>>> type(np.random.random_sample())
		<type 'float'>
		>>> np.random.random_sample((5,))
		array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
		
		Three-by-two array of random numbers from [-5, 0):
		
		>>> 5 * np.random.random_sample((3, 2)) - 5
		array([[-3.99149989, -0.52338984],
		       [-2.99091858, -0.79479508],
		       [-1.23204345, -1.75224494]])
	**/
	static public function ranf(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the number of dimensions of an array.
		
		.. note::
		    This function is deprecated in NumPy 1.9 to avoid confusion with
		    `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function
		    should be used instead.
		
		See Also
		--------
		ndim : equivalent non-deprecated function
		
		Notes
		-----
		In the old Numeric package, `rank` was the term used for the number of
		dimensions, but in NumPy `ndim` is used instead.
	**/
	static public function rank(a:Dynamic):Dynamic;
	/**
		Compute the rate of interest per period.
		
		Parameters
		----------
		nper : array_like
		    Number of compounding periods
		pmt : array_like
		    Payment
		pv : array_like
		    Present value
		fv : array_like
		    Future value
		when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
		    When payments are due ('begin' (1) or 'end' (0))
		guess : Number, optional
		    Starting guess for solving the rate of interest, default 0.1
		tol : Number, optional
		    Required tolerance for the solution, default 1e-6
		maxiter : int, optional
		    Maximum iterations in finding the solution
		
		Notes
		-----
		The rate of interest is computed by iteratively solving the
		(non-linear) equation::
		
		 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0
		
		for ``rate``.
		
		References
		----------
		Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document
		Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated
		Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12.
		Organization for the Advancement of Structured Information Standards
		(OASIS). Billerica, MA, USA. [ODT Document]. Available:
		http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
		OpenDocument-formula-20090508.odt
	**/
	static public function rate(nper:Dynamic, pmt:Dynamic, pv:Dynamic, fv:Dynamic, ?when:Dynamic, ?guess:Dynamic, ?tol:Dynamic, ?maxiter:Dynamic):Dynamic;
	/**
		Return a contiguous flattened array.
		
		A 1-D array, containing the elements of the input, is returned.  A copy is
		made only if needed.
		
		As of NumPy 1.10, the returned array will have the same type as the input
		array. (for example, a masked array will be returned for a masked array
		input)
		
		Parameters
		----------
		a : array_like
		    Input array.  The elements in `a` are read in the order specified by
		    `order`, and packed as a 1-D array.
		order : {'C','F', 'A', 'K'}, optional
		
		    The elements of `a` are read using this index order. 'C' means
		    to index the elements in row-major, C-style order,
		    with the last axis index changing fastest, back to the first
		    axis index changing slowest.  'F' means to index the elements
		    in column-major, Fortran-style order, with the
		    first index changing fastest, and the last index changing
		    slowest. Note that the 'C' and 'F' options take no account of
		    the memory layout of the underlying array, and only refer to
		    the order of axis indexing.  'A' means to read the elements in
		    Fortran-like index order if `a` is Fortran *contiguous* in
		    memory, C-like order otherwise.  'K' means to read the
		    elements in the order they occur in memory, except for
		    reversing the data when strides are negative.  By default, 'C'
		    index order is used.
		
		Returns
		-------
		y : array_like
		    y is an array of the same subtype as `a`, with shape ``(a.size,)``.
		    Note that matrices are special cased for backward compatibility, if `a`
		    is a matrix, then y is a 1-D ndarray.
		
		See Also
		--------
		ndarray.flat : 1-D iterator over an array.
		ndarray.flatten : 1-D array copy of the elements of an array
		                  in row-major order.
		ndarray.reshape : Change the shape of an array without changing its data.
		
		Notes
		-----
		In row-major, C-style order, in two dimensions, the row index
		varies the slowest, and the column index the quickest.  This can
		be generalized to multiple dimensions, where row-major order
		implies that the index along the first axis varies slowest, and
		the index along the last quickest.  The opposite holds for
		column-major, Fortran-style index ordering.
		
		When a view is desired in as many cases as possible, ``arr.reshape(-1)``
		may be preferable.
		
		Examples
		--------
		It is equivalent to ``reshape(-1, order=order)``.
		
		>>> x = np.array([[1, 2, 3], [4, 5, 6]])
		>>> print(np.ravel(x))
		[1 2 3 4 5 6]
		
		>>> print(x.reshape(-1))
		[1 2 3 4 5 6]
		
		>>> print(np.ravel(x, order='F'))
		[1 4 2 5 3 6]
		
		When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:
		
		>>> print(np.ravel(x.T))
		[1 4 2 5 3 6]
		>>> print(np.ravel(x.T, order='A'))
		[1 2 3 4 5 6]
		
		When ``order`` is 'K', it will preserve orderings that are neither 'C'
		nor 'F', but won't reverse axes:
		
		>>> a = np.arange(3)[::-1]; a
		array([2, 1, 0])
		>>> a.ravel(order='C')
		array([2, 1, 0])
		>>> a.ravel(order='K')
		array([2, 1, 0])
		
		>>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
		array([[[ 0,  2,  4],
		        [ 1,  3,  5]],
		       [[ 6,  8, 10],
		        [ 7,  9, 11]]])
		>>> a.ravel(order='C')
		array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
		>>> a.ravel(order='K')
		array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
	**/
	static public function ravel(a:Dynamic, ?order:Dynamic):Dynamic;
	/**
		ravel_multi_index(multi_index, dims, mode='raise', order='C')
		
		Converts a tuple of index arrays into an array of flat
		indices, applying boundary modes to the multi-index.
		
		Parameters
		----------
		multi_index : tuple of array_like
		    A tuple of integer arrays, one array for each dimension.
		dims : tuple of ints
		    The shape of array into which the indices from ``multi_index`` apply.
		mode : {'raise', 'wrap', 'clip'}, optional
		    Specifies how out-of-bounds indices are handled.  Can specify
		    either one mode or a tuple of modes, one mode per index.
		
		    * 'raise' -- raise an error (default)
		    * 'wrap' -- wrap around
		    * 'clip' -- clip to the range
		
		    In 'clip' mode, a negative index which would normally
		    wrap will clip to 0 instead.
		order : {'C', 'F'}, optional
		    Determines whether the multi-index should be viewed as
		    indexing in row-major (C-style) or column-major
		    (Fortran-style) order.
		
		Returns
		-------
		raveled_indices : ndarray
		    An array of indices into the flattened version of an array
		    of dimensions ``dims``.
		
		See Also
		--------
		unravel_index
		
		Notes
		-----
		.. versionadded:: 1.6.0
		
		Examples
		--------
		>>> arr = np.array([[3,6,6],[4,5,1]])
		>>> np.ravel_multi_index(arr, (7,6))
		array([22, 41, 37])
		>>> np.ravel_multi_index(arr, (7,6), order='F')
		array([31, 41, 13])
		>>> np.ravel_multi_index(arr, (4,6), mode='clip')
		array([22, 23, 19])
		>>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
		array([12, 13, 13])
		
		>>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
		1621
	**/
	static public function ravel_multi_index(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		rayleigh(scale=1.0, size=None)
		
		Draw samples from a Rayleigh distribution.
		
		The :math:`\chi` and Weibull distributions are generalizations of the
		Rayleigh.
		
		Parameters
		----------
		scale : float or array_like of floats, optional
		    Scale, also equals the mode. Should be >= 0. Default is 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``scale`` is a scalar.  Otherwise,
		    ``np.array(scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Rayleigh distribution.
		
		Notes
		-----
		The probability density function for the Rayleigh distribution is
		
		.. math:: P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}
		
		The Rayleigh distribution would arise, for example, if the East
		and North components of the wind velocity had identical zero-mean
		Gaussian distributions.  Then the wind speed would have a Rayleigh
		distribution.
		
		References
		----------
		.. [1] Brighton Webs Ltd., "Rayleigh Distribution,"
		       https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp
		.. [2] Wikipedia, "Rayleigh distribution"
		       https://en.wikipedia.org/wiki/Rayleigh_distribution
		
		Examples
		--------
		Draw values from the distribution and plot the histogram
		
		>>> from matplotlib.pyplot import hist
		>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)
		
		Wave heights tend to follow a Rayleigh distribution. If the mean wave
		height is 1 meter, what fraction of waves are likely to be larger than 3
		meters?
		
		>>> meanvalue = 1
		>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
		>>> s = np.random.rayleigh(modevalue, 1000000)
		
		The percentage of waves larger than 3 meters is:
		
		>>> 100.*sum(s>3)/1000000.
		0.087300000000000003
	**/
	static public function rayleigh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set the current rc params.  *group* is the grouping for the rc, e.g.,
		for ``lines.linewidth`` the group is ``lines``, for
		``axes.facecolor``, the group is ``axes``, and so on.  Group may
		also be a list or tuple of group names, e.g., (*xtick*, *ytick*).
		*kwargs* is a dictionary attribute name/value pairs, e.g.,::
		
		  rc('lines', linewidth=2, color='r')
		
		sets the current rc params and is equivalent to::
		
		  rcParams['lines.linewidth'] = 2
		  rcParams['lines.color'] = 'r'
		
		The following aliases are available to save typing for interactive
		users:
		
		=====   =================
		Alias   Property
		=====   =================
		'lw'    'linewidth'
		'ls'    'linestyle'
		'c'     'color'
		'fc'    'facecolor'
		'ec'    'edgecolor'
		'mew'   'markeredgewidth'
		'aa'    'antialiased'
		=====   =================
		
		Thus you could abbreviate the above rc command as::
		
		      rc('lines', lw=2, c='r')
		
		
		Note you can use python's kwargs dictionary facility to store
		dictionaries of default parameters.  e.g., you can customize the
		font rc as follows::
		
		  font = {'family' : 'monospace',
		          'weight' : 'bold',
		          'size'   : 'larger'}
		
		  rc('font', **font)  # pass in the font dict as kwargs
		
		This enables you to easily switch between several configurations.  Use
		``matplotlib.style.use('default')`` or :func:`~matplotlib.rcdefaults` to
		restore the default rc params after changes.
	**/
	static public function rc(group:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	static public var rcParams : Dynamic;
	static public var rcParamsDefault : Dynamic;
	static public var rcParamsOrig : Dynamic;
	/**
		Return a context manager for managing rc settings.
		
		This allows one to do::
		
		    with mpl.rc_context(fname='screen.rc'):
		        plt.plot(x, a)
		        with mpl.rc_context(fname='print.rc'):
		            plt.plot(x, b)
		        plt.plot(x, c)
		
		The 'a' vs 'x' and 'c' vs 'x' plots would have settings from
		'screen.rc', while the 'b' vs 'x' plot would have settings from
		'print.rc'.
		
		A dictionary can also be passed to the context manager::
		
		    with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):
		        plt.plot(x, a)
		
		The 'rc' dictionary takes precedence over the settings loaded from
		'fname'.  Passing a dictionary only is also valid. For example a
		common usage is::
		
		    with mpl.rc_context(rc={'interactive': False}):
		        fig, ax = plt.subplots()
		        ax.plot(range(3), range(3))
		        fig.savefig('A.png', format='png')
		        plt.close(fig)
	**/
	static public function rc_context(?rc:Dynamic, ?fname:Dynamic):Dynamic;
	/**
		Restore the rc params from Matplotlib's internal default style.
		
		Style-blacklisted rc params (defined in
		`matplotlib.style.core.STYLE_BLACKLIST`) are not updated.
		
		See Also
		--------
		rc_file_defaults
		    Restore the rc params from the rc file originally loaded by Matplotlib.
		matplotlib.style.use :
		    Use a specific style file.  Call ``style.use('default')`` to restore
		    the default style.
	**/
	static public function rcdefaults():Dynamic;
	/**
		Return the real part of the complex argument.
		
		Parameters
		----------
		val : array_like
		    Input array.
		
		Returns
		-------
		out : ndarray or scalar
		    The real component of the complex argument. If `val` is real, the type
		    of `val` is used for the output.  If `val` has complex elements, the
		    returned type is float.
		
		See Also
		--------
		real_if_close, imag, angle
		
		Examples
		--------
		>>> a = np.array([1+2j, 3+4j, 5+6j])
		>>> a.real
		array([ 1.,  3.,  5.])
		>>> a.real = 9
		>>> a
		array([ 9.+2.j,  9.+4.j,  9.+6.j])
		>>> a.real = np.array([9, 8, 7])
		>>> a
		array([ 9.+2.j,  8.+4.j,  7.+6.j])
		>>> np.real(1 + 1j)
		1.0
	**/
	static public function real(val:Dynamic):Dynamic;
	/**
		If complex input returns a real array if complex parts are close to zero.
		
		"Close to zero" is defined as `tol` * (machine epsilon of the type for
		`a`).
		
		Parameters
		----------
		a : array_like
		    Input array.
		tol : float
		    Tolerance in machine epsilons for the complex part of the elements
		    in the array.
		
		Returns
		-------
		out : ndarray
		    If `a` is real, the type of `a` is used for the output.  If `a`
		    has complex elements, the returned type is float.
		
		See Also
		--------
		real, imag, angle
		
		Notes
		-----
		Machine epsilon varies from machine to machine and between data types
		but Python floats on most platforms have a machine epsilon equal to
		2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print
		out the machine epsilon for floats.
		
		Examples
		--------
		>>> np.finfo(float).eps
		2.2204460492503131e-16
		
		>>> np.real_if_close([2.1 + 4e-14j], tol=1000)
		array([ 2.1])
		>>> np.real_if_close([2.1 + 4e-13j], tol=1000)
		array([ 2.1 +4.00000000e-13j])
	**/
	static public function real_if_close(a:Dynamic, ?tol:Dynamic):Dynamic;
	/**
		Load ASCII data stored in a comma-separated file.
		
		The returned array is a record array (if ``usemask=False``, see
		`recarray`) or a masked record array (if ``usemask=True``,
		see `ma.mrecords.MaskedRecords`).
		
		Parameters
		----------
		fname, kwargs : For a description of input parameters, see `genfromtxt`.
		
		See Also
		--------
		numpy.genfromtxt : generic function to load ASCII data.
		
		Notes
		-----
		By default, `dtype` is None, which means that the data-type of the output
		array will be determined from the data.
	**/
	static public function recfromcsv(fname:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Load ASCII data from a file and return it in a record array.
		
		If ``usemask=False`` a standard `recarray` is returned,
		if ``usemask=True`` a MaskedRecords array is returned.
		
		Parameters
		----------
		fname, kwargs : For a description of input parameters, see `genfromtxt`.
		
		See Also
		--------
		numpy.genfromtxt : generic function
		
		Notes
		-----
		By default, `dtype` is None, which means that the data-type of the output
		array will be determined from the data.
	**/
	static public function recfromtxt(fname:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the reciprocal of the argument, element-wise.
		
		Calculates ``1/x``.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    Return array.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		.. note::
		    This function is not designed to work with integers.
		
		For integer arguments with absolute value larger than 1 the result is
		always zero because of the way Python handles integer division.  For
		integer zero the result is an overflow.
		
		Examples
		--------
		>>> np.reciprocal(2.)
		0.5
		>>> np.reciprocal([1, 2., 3.33])
		array([ 1.       ,  0.5      ,  0.3003003])
	**/
	static public function reciprocal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Add a colormap to the set recognized by :func:`get_cmap`.
		
		It can be used in two ways::
		
		    register_cmap(name='swirly', cmap=swirly_cmap)
		
		    register_cmap(name='choppy', data=choppydata, lut=128)
		
		In the first case, *cmap* must be a :class:`matplotlib.colors.Colormap`
		instance.  The *name* is optional; if absent, the name will
		be the :attr:`~matplotlib.colors.Colormap.name` attribute of the *cmap*.
		
		In the second case, the three arguments are passed to
		the :class:`~matplotlib.colors.LinearSegmentedColormap` initializer,
		and the resulting colormap is registered.
	**/
	static public function register_cmap(?name:Dynamic, ?cmap:Dynamic, ?data:Dynamic, ?lut:Dynamic):Dynamic;
	/**
		remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return element-wise remainder of division.
		
		Computes the remainder complementary to the `floor_divide` function.  It is
		equivalent to the Python modulus operator``x1 % x2`` and has the same sign
		as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
		is ``mod``.
		
		.. warning::
		
		    This should not be confused with:
		
		    * Python 3.7's `math.remainder` and C's ``remainder``, which
		      computes the IEEE remainder, which are the complement to
		      ``round(x1 / x2)``.
		    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
		      complement to ``int(x1 / x2)``.
		
		Parameters
		----------
		x1 : array_like
		    Dividend array.
		x2 : array_like
		    Divisor array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		floor_divide : Equivalent of Python ``//`` operator.
		divmod : Simultaneous floor division and remainder.
		fmod : Equivalent of the MATLAB ``rem`` function.
		divide, floor
		
		Notes
		-----
		Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
		integers.
		
		Examples
		--------
		>>> np.remainder([4, 7], [2, 3])
		array([0, 1])
		>>> np.remainder(np.arange(7), 5)
		array([0, 1, 2, 3, 4, 0, 1])
	**/
	static public function remainder(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Repeat elements of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.
		repeats : int or array of ints
		    The number of repetitions for each element.  `repeats` is broadcasted
		    to fit the shape of the given axis.
		axis : int, optional
		    The axis along which to repeat values.  By default, use the
		    flattened input array, and return a flat output array.
		
		Returns
		-------
		repeated_array : ndarray
		    Output array which has the same shape as `a`, except along
		    the given axis.
		
		See Also
		--------
		tile : Tile an array.
		
		Examples
		--------
		>>> np.repeat(3, 4)
		array([3, 3, 3, 3])
		>>> x = np.array([[1,2],[3,4]])
		>>> np.repeat(x, 2)
		array([1, 1, 2, 2, 3, 3, 4, 4])
		>>> np.repeat(x, 3, axis=1)
		array([[1, 1, 1, 2, 2, 2],
		       [3, 3, 3, 4, 4, 4]])
		>>> np.repeat(x, [1, 2], axis=0)
		array([[1, 2],
		       [3, 4],
		       [3, 4]])
	**/
	static public function repeat(a:Dynamic, repeats:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Return an ndarray of the provided type that satisfies requirements.
		
		This function is useful to be sure that an array with the correct flags
		is returned for passing to compiled code (perhaps through ctypes).
		
		Parameters
		----------
		a : array_like
		   The object to be converted to a type-and-requirement-satisfying array.
		dtype : data-type
		   The required data-type. If None preserve the current dtype. If your
		   application requires the data to be in native byteorder, include
		   a byteorder specification as a part of the dtype specification.
		requirements : str or list of str
		   The requirements list can be any of the following
		
		   * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
		   * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
		   * 'ALIGNED' ('A')      - ensure a data-type aligned array
		   * 'WRITEABLE' ('W')    - ensure a writable array
		   * 'OWNDATA' ('O')      - ensure an array that owns its own data
		   * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass
		
		See Also
		--------
		asarray : Convert input to an ndarray.
		asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
		ascontiguousarray : Convert input to a contiguous array.
		asfortranarray : Convert input to an ndarray with column-major
		                 memory order.
		ndarray.flags : Information about the memory layout of the array.
		
		Notes
		-----
		The returned array will be guaranteed to have the listed requirements
		by making a copy if needed.
		
		Examples
		--------
		>>> x = np.arange(6).reshape(2,3)
		>>> x.flags
		  C_CONTIGUOUS : True
		  F_CONTIGUOUS : False
		  OWNDATA : False
		  WRITEABLE : True
		  ALIGNED : True
		  WRITEBACKIFCOPY : False
		  UPDATEIFCOPY : False
		
		>>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
		>>> y.flags
		  C_CONTIGUOUS : False
		  F_CONTIGUOUS : True
		  OWNDATA : True
		  WRITEABLE : True
		  ALIGNED : True
		  WRITEBACKIFCOPY : False
		  UPDATEIFCOPY : False
	**/
	static public function require(a:Dynamic, ?dtype:Dynamic, ?requirements:Dynamic):Dynamic;
	/**
		Gives a new shape to an array without changing its data.
		
		Parameters
		----------
		a : array_like
		    Array to be reshaped.
		newshape : int or tuple of ints
		    The new shape should be compatible with the original shape. If
		    an integer, then the result will be a 1-D array of that length.
		    One shape dimension can be -1. In this case, the value is
		    inferred from the length of the array and remaining dimensions.
		order : {'C', 'F', 'A'}, optional
		    Read the elements of `a` using this index order, and place the
		    elements into the reshaped array using this index order.  'C'
		    means to read / write the elements using C-like index order,
		    with the last axis index changing fastest, back to the first
		    axis index changing slowest. 'F' means to read / write the
		    elements using Fortran-like index order, with the first index
		    changing fastest, and the last index changing slowest. Note that
		    the 'C' and 'F' options take no account of the memory layout of
		    the underlying array, and only refer to the order of indexing.
		    'A' means to read / write the elements in Fortran-like index
		    order if `a` is Fortran *contiguous* in memory, C-like order
		    otherwise.
		
		Returns
		-------
		reshaped_array : ndarray
		    This will be a new view object if possible; otherwise, it will
		    be a copy.  Note there is no guarantee of the *memory layout* (C- or
		    Fortran- contiguous) of the returned array.
		
		See Also
		--------
		ndarray.reshape : Equivalent method.
		
		Notes
		-----
		It is not always possible to change the shape of an array without
		copying the data. If you want an error to be raised when the data is copied,
		you should assign the new shape to the shape attribute of the array::
		
		 >>> a = np.zeros((10, 2))
		 # A transpose makes the array non-contiguous
		 >>> b = a.T
		 # Taking a view makes it possible to modify the shape without modifying
		 # the initial object.
		 >>> c = b.view()
		 >>> c.shape = (20)
		 AttributeError: incompatible shape for a non-contiguous array
		
		The `order` keyword gives the index ordering both for *fetching* the values
		from `a`, and then *placing* the values into the output array.
		For example, let's say you have an array:
		
		>>> a = np.arange(6).reshape((3, 2))
		>>> a
		array([[0, 1],
		       [2, 3],
		       [4, 5]])
		
		You can think of reshaping as first raveling the array (using the given
		index order), then inserting the elements from the raveled array into the
		new array using the same kind of index ordering as was used for the
		raveling.
		
		>>> np.reshape(a, (2, 3)) # C-like index ordering
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
		array([[0, 4, 3],
		       [2, 1, 5]])
		>>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
		array([[0, 4, 3],
		       [2, 1, 5]])
		
		Examples
		--------
		>>> a = np.array([[1,2,3], [4,5,6]])
		>>> np.reshape(a, 6)
		array([1, 2, 3, 4, 5, 6])
		>>> np.reshape(a, 6, order='F')
		array([1, 4, 2, 5, 3, 6])
		
		>>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
		array([[1, 2],
		       [3, 4],
		       [5, 6]])
	**/
	static public function reshape(a:Dynamic, newshape:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Return a new array with the specified shape.
		
		If the new array is larger than the original array, then the new
		array is filled with repeated copies of `a`.  Note that this behavior
		is different from a.resize(new_shape) which fills with zeros instead
		of repeated copies of `a`.
		
		Parameters
		----------
		a : array_like
		    Array to be resized.
		
		new_shape : int or tuple of int
		    Shape of resized array.
		
		Returns
		-------
		reshaped_array : ndarray
		    The new array is formed from the data in the old array, repeated
		    if necessary to fill out the required number of elements.  The
		    data are repeated in the order that they are stored in memory.
		
		See Also
		--------
		ndarray.resize : resize an array in-place.
		
		Notes
		-----
		Warning: This functionality does **not** consider axes separately,
		i.e. it does not apply interpolation/extrapolation.
		It fills the return array with the required number of elements, taken
		from `a` as they are laid out in memory, disregarding strides and axes.
		(This is in case the new shape is smaller. For larger, see above.)
		This functionality is therefore not suitable to resize images,
		or data where each axis represents a separate and distinct entity.
		
		Examples
		--------
		>>> a=np.array([[0,1],[2,3]])
		>>> np.resize(a,(2,3))
		array([[0, 1, 2],
		       [3, 0, 1]])
		>>> np.resize(a,(1,4))
		array([[0, 1, 2, 3]])
		>>> np.resize(a,(2,4))
		array([[0, 1, 2, 3],
		       [0, 1, 2, 3]])
	**/
	static public function resize(a:Dynamic, new_shape:Dynamic):Dynamic;
	/**
		result_type(*arrays_and_dtypes)
		
		Returns the type that results from applying the NumPy
		type promotion rules to the arguments.
		
		Type promotion in NumPy works similarly to the rules in languages
		like C++, with some slight differences.  When both scalars and
		arrays are used, the array's type takes precedence and the actual value
		of the scalar is taken into account.
		
		For example, calculating 3*a, where a is an array of 32-bit floats,
		intuitively should result in a 32-bit float output.  If the 3 is a
		32-bit integer, the NumPy rules indicate it can't convert losslessly
		into a 32-bit float, so a 64-bit float should be the result type.
		By examining the value of the constant, '3', we see that it fits in
		an 8-bit integer, which can be cast losslessly into the 32-bit float.
		
		Parameters
		----------
		arrays_and_dtypes : list of arrays and dtypes
		    The operands of some operation whose result type is needed.
		
		Returns
		-------
		out : dtype
		    The result type.
		
		See also
		--------
		dtype, promote_types, min_scalar_type, can_cast
		
		Notes
		-----
		.. versionadded:: 1.6.0
		
		The specific algorithm used is as follows.
		
		Categories are determined by first checking which of boolean,
		integer (int/uint), or floating point (float/complex) the maximum
		kind of all the arrays and the scalars are.
		
		If there are only scalars or the maximum category of the scalars
		is higher than the maximum category of the arrays,
		the data types are combined with :func:`promote_types`
		to produce the return value.
		
		Otherwise, `min_scalar_type` is called on each array, and
		the resulting data types are all combined with :func:`promote_types`
		to produce the return value.
		
		The set of int values is not a subset of the uint values for types
		with the same number of bits, something not reflected in
		:func:`min_scalar_type`, but handled as a special case in `result_type`.
		
		Examples
		--------
		>>> np.result_type(3, np.arange(7, dtype='i1'))
		dtype('int8')
		
		>>> np.result_type('i4', 'c8')
		dtype('complex128')
		
		>>> np.result_type(3.0, -2)
		dtype('float64')
	**/
	static public function result_type(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the one-dimensional discrete Fourier Transform for real input.
		
		This function computes the one-dimensional *n*-point discrete Fourier
		Transform (DFT) of a real-valued array by means of an efficient algorithm
		called the Fast Fourier Transform (FFT).
		
		Parameters
		----------
		a : array_like
		    Input array
		n : int, optional
		    Number of points along transformation axis in the input to use.
		    If `n` is smaller than the length of the input, the input is cropped.
		    If it is larger, the input is padded with zeros. If `n` is not given,
		    the length of the input along the axis specified by `axis` is used.
		axis : int, optional
		    Axis over which to compute the FFT. If not given, the last axis is
		    used.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axis
		    indicated by `axis`, or the last one if `axis` is not specified.
		    If `n` is even, the length of the transformed axis is ``(n/2)+1``.
		    If `n` is odd, the length is ``(n+1)/2``.
		
		Raises
		------
		IndexError
		    If `axis` is larger than the last axis of `a`.
		
		See Also
		--------
		numpy.fft : For definition of the DFT and conventions used.
		irfft : The inverse of `rfft`.
		fft : The one-dimensional FFT of general (complex) input.
		fftn : The *n*-dimensional FFT.
		rfftn : The *n*-dimensional FFT of real input.
		
		Notes
		-----
		When the DFT is computed for purely real input, the output is
		Hermitian-symmetric, i.e. the negative frequency terms are just the complex
		conjugates of the corresponding positive-frequency terms, and the
		negative-frequency terms are therefore redundant.  This function does not
		compute the negative frequency terms, and the length of the transformed
		axis of the output is therefore ``n//2 + 1``.
		
		When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
		the zero-frequency term 0*fs, which is real due to Hermitian symmetry.
		
		If `n` is even, ``A[-1]`` contains the term representing both positive
		and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
		real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
		the largest positive frequency (fs/2*(n-1)/n), and is complex in the
		general case.
		
		If the input `a` contains an imaginary part, it is silently discarded.
		
		Examples
		--------
		>>> np.fft.fft([0, 1, 0, 0])
		array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])
		>>> np.fft.rfft([0, 1, 0, 0])
		array([ 1.+0.j,  0.-1.j, -1.+0.j])
		
		Notice how the final element of the `fft` output is the complex conjugate
		of the second element, for real input. For `rfft`, this symmetry is
		exploited to compute only the non-negative frequency terms.
	**/
	static public function rfft(a:Dynamic, ?n:Dynamic, ?axis:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Compute the 2-dimensional FFT of a real array.
		
		Parameters
		----------
		a : array
		    Input array, taken to be real.
		s : sequence of ints, optional
		    Shape of the FFT.
		axes : sequence of ints, optional
		    Axes over which to compute the FFT.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : ndarray
		    The result of the real 2-D FFT.
		
		See Also
		--------
		rfftn : Compute the N-dimensional discrete Fourier Transform for real
		        input.
		
		Notes
		-----
		This is really just `rfftn` with different default behavior.
		For more details see `rfftn`.
	**/
	static public function rfft2(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Return the Discrete Fourier Transform sample frequencies
		(for usage with rfft, irfft).
		
		The returned float array `f` contains the frequency bin centers in cycles
		per unit of the sample spacing (with zero at the start).  For instance, if
		the sample spacing is in seconds, then the frequency unit is cycles/second.
		
		Given a window length `n` and a sample spacing `d`::
		
		  f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even
		  f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd
		
		Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`)
		the Nyquist frequency component is considered to be positive.
		
		Parameters
		----------
		n : int
		    Window length.
		d : scalar, optional
		    Sample spacing (inverse of the sampling rate). Defaults to 1.
		
		Returns
		-------
		f : ndarray
		    Array of length ``n//2 + 1`` containing the sample frequencies.
		
		Examples
		--------
		>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
		>>> fourier = np.fft.rfft(signal)
		>>> n = signal.size
		>>> sample_rate = 100
		>>> freq = np.fft.fftfreq(n, d=1./sample_rate)
		>>> freq
		array([  0.,  10.,  20.,  30.,  40., -50., -40., -30., -20., -10.])
		>>> freq = np.fft.rfftfreq(n, d=1./sample_rate)
		>>> freq
		array([  0.,  10.,  20.,  30.,  40.,  50.])
	**/
	static public function rfftfreq(n:Dynamic, ?d:Dynamic):Dynamic;
	/**
		Compute the N-dimensional discrete Fourier Transform for real input.
		
		This function computes the N-dimensional discrete Fourier Transform over
		any number of axes in an M-dimensional real array by means of the Fast
		Fourier Transform (FFT).  By default, all axes are transformed, with the
		real transform performed over the last axis, while the remaining
		transforms are complex.
		
		Parameters
		----------
		a : array_like
		    Input array, taken to be real.
		s : sequence of ints, optional
		    Shape (length along each transformed axis) to use from the input.
		    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
		    The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
		    for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
		    Along any axis, if the given shape is smaller than that of the input,
		    the input is cropped.  If it is larger, the input is padded with zeros.
		    if `s` is not given, the shape of the input along the axes specified
		    by `axes` is used.
		axes : sequence of ints, optional
		    Axes over which to compute the FFT.  If not given, the last ``len(s)``
		    axes are used, or all axes if `s` is also not specified.
		norm : {None, "ortho"}, optional
		    .. versionadded:: 1.10.0
		
		    Normalization mode (see `numpy.fft`). Default is None.
		
		Returns
		-------
		out : complex ndarray
		    The truncated or zero-padded input, transformed along the axes
		    indicated by `axes`, or by a combination of `s` and `a`,
		    as explained in the parameters section above.
		    The length of the last axis transformed will be ``s[-1]//2+1``,
		    while the remaining transformed axes will have lengths according to
		    `s`, or unchanged from the input.
		
		Raises
		------
		ValueError
		    If `s` and `axes` have different length.
		IndexError
		    If an element of `axes` is larger than than the number of axes of `a`.
		
		See Also
		--------
		irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT
		     of real input.
		fft : The one-dimensional FFT, with definitions and conventions used.
		rfft : The one-dimensional FFT of real input.
		fftn : The n-dimensional FFT.
		rfft2 : The two-dimensional FFT of real input.
		
		Notes
		-----
		The transform for real input is performed over the last transformation
		axis, as by `rfft`, then the transform over the remaining axes is
		performed as by `fftn`.  The order of the output is as for `rfft` for the
		final transformation axis, and as for `fftn` for the remaining
		transformation axes.
		
		See `fft` for details, definitions and conventions used.
		
		Examples
		--------
		>>> a = np.ones((2, 2, 2))
		>>> np.fft.rfftn(a)
		array([[[ 8.+0.j,  0.+0.j],
		        [ 0.+0.j,  0.+0.j]],
		       [[ 0.+0.j,  0.+0.j],
		        [ 0.+0.j,  0.+0.j]]])
		
		>>> np.fft.rfftn(a, axes=(2, 0))
		array([[[ 4.+0.j,  0.+0.j],
		        [ 4.+0.j,  0.+0.j]],
		       [[ 0.+0.j,  0.+0.j],
		        [ 0.+0.j,  0.+0.j]]])
	**/
	static public function rfftn(a:Dynamic, ?s:Dynamic, ?axes:Dynamic, ?norm:Dynamic):Dynamic;
	/**
		Get or set the radial gridlines on the current polar plot.
		
		Call signatures::
		
		 lines, labels = rgrids()
		 lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
		
		When called with no arguments, `.rgrids` simply returns the tuple
		(*lines*, *labels*). When called with arguments, the labels will
		appear at the specified radial distances and angle.
		
		Parameters
		----------
		radii : tuple with floats
		    The radii for the radial gridlines
		
		labels : tuple with strings or None
		    The labels to use at each radial gridline. The
		    `matplotlib.ticker.ScalarFormatter` will be used if None.
		
		angle : float
		    The angular position of the radius labels in degrees.
		
		fmt : str or None
		    Format string used in `matplotlib.ticker.FormatStrFormatter`.
		    For example '%f'.
		
		Returns
		-------
		lines, labels : list of `.lines.Line2D`, list of `.text.Text`
		    *lines* are the radial gridlines and *labels* are the tick labels.
		
		Other Parameters
		----------------
		**kwargs
		    *kwargs* are optional `~.Text` properties for the labels.
		
		Examples
		--------
		::
		
		  # set the locations of the radial gridlines
		  lines, labels = rgrids( (0.25, 0.5, 1.0) )
		
		  # set the locations and labels of the radial gridlines
		  lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
		
		See Also
		--------
		.pyplot.thetagrids
		.projections.polar.PolarAxes.set_rgrids
		.Axis.get_gridlines
		.Axis.get_ticklabels
	**/
	static public function rgrids(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Shift the bits of an integer to the right.
		
		Bits are shifted to the right `x2`.  Because the internal
		representation of numbers is in binary format, this operation is
		equivalent to dividing `x1` by ``2**x2``.
		
		Parameters
		----------
		x1 : array_like, int
		    Input values.
		x2 : array_like, int
		    Number of bits to remove at the right of `x1`.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray, int
		    Return `x1` with bits shifted `x2` times to the right.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		See Also
		--------
		left_shift : Shift the bits of an integer to the left.
		binary_repr : Return the binary representation of the input number
		    as a string.
		
		Examples
		--------
		>>> np.binary_repr(10)
		'1010'
		>>> np.right_shift(10, 1)
		5
		>>> np.binary_repr(5)
		'101'
		
		>>> np.right_shift(10, [1,2,3])
		array([5, 2, 1])
	**/
	static public function right_shift(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Round elements of the array to the nearest integer.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Output array is same shape and type as `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		ceil, floor, trunc
		
		Examples
		--------
		>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
		>>> np.rint(a)
		array([-2., -2., -0.,  0.,  2.,  2.,  2.])
	**/
	static public function rint(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Roll array elements along a given axis.
		
		Elements that roll beyond the last position are re-introduced at
		the first.
		
		Parameters
		----------
		a : array_like
		    Input array.
		shift : int or tuple of ints
		    The number of places by which elements are shifted.  If a tuple,
		    then `axis` must be a tuple of the same size, and each of the
		    given axes is shifted by the corresponding number.  If an int
		    while `axis` is a tuple of ints, then the same value is used for
		    all given axes.
		axis : int or tuple of ints, optional
		    Axis or axes along which elements are shifted.  By default, the
		    array is flattened before shifting, after which the original
		    shape is restored.
		
		Returns
		-------
		res : ndarray
		    Output array, with the same shape as `a`.
		
		See Also
		--------
		rollaxis : Roll the specified axis backwards, until it lies in a
		           given position.
		
		Notes
		-----
		.. versionadded:: 1.12.0
		
		Supports rolling over multiple dimensions simultaneously.
		
		Examples
		--------
		>>> x = np.arange(10)
		>>> np.roll(x, 2)
		array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
		
		>>> x2 = np.reshape(x, (2,5))
		>>> x2
		array([[0, 1, 2, 3, 4],
		       [5, 6, 7, 8, 9]])
		>>> np.roll(x2, 1)
		array([[9, 0, 1, 2, 3],
		       [4, 5, 6, 7, 8]])
		>>> np.roll(x2, 1, axis=0)
		array([[5, 6, 7, 8, 9],
		       [0, 1, 2, 3, 4]])
		>>> np.roll(x2, 1, axis=1)
		array([[4, 0, 1, 2, 3],
		       [9, 5, 6, 7, 8]])
	**/
	static public function roll(a:Dynamic, shift:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Roll the specified axis backwards, until it lies in a given position.
		
		This function continues to be supported for backward compatibility, but you
		should prefer `moveaxis`. The `moveaxis` function was added in NumPy
		1.11.
		
		Parameters
		----------
		a : ndarray
		    Input array.
		axis : int
		    The axis to roll backwards.  The positions of the other axes do not
		    change relative to one another.
		start : int, optional
		    The axis is rolled until it lies before this position.  The default,
		    0, results in a "complete" roll.
		
		Returns
		-------
		res : ndarray
		    For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
		    NumPy versions a view of `a` is returned only if the order of the
		    axes is changed, otherwise the input array is returned.
		
		See Also
		--------
		moveaxis : Move array axes to new positions.
		roll : Roll the elements of an array by a number of positions along a
		    given axis.
		
		Examples
		--------
		>>> a = np.ones((3,4,5,6))
		>>> np.rollaxis(a, 3, 1).shape
		(3, 6, 4, 5)
		>>> np.rollaxis(a, 2).shape
		(5, 3, 4, 6)
		>>> np.rollaxis(a, 1, 4).shape
		(3, 5, 6, 4)
	**/
	static public function rollaxis(a:Dynamic, axis:Dynamic, ?start:Dynamic):Dynamic;
	/**
		Return the roots of a polynomial with coefficients given in p.
		
		The values in the rank-1 array `p` are coefficients of a polynomial.
		If the length of `p` is n+1 then the polynomial is described by::
		
		  p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]
		
		Parameters
		----------
		p : array_like
		    Rank-1 array of polynomial coefficients.
		
		Returns
		-------
		out : ndarray
		    An array containing the roots of the polynomial.
		
		Raises
		------
		ValueError
		    When `p` cannot be converted to a rank-1 array.
		
		See also
		--------
		poly : Find the coefficients of a polynomial with a given sequence
		       of roots.
		polyval : Compute polynomial values.
		polyfit : Least squares polynomial fit.
		poly1d : A one-dimensional polynomial class.
		
		Notes
		-----
		The algorithm relies on computing the eigenvalues of the
		companion matrix [1]_.
		
		References
		----------
		.. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
		    Cambridge University Press, 1999, pp. 146-7.
		
		Examples
		--------
		>>> coeff = [3.2, 2, 1]
		>>> np.roots(coeff)
		array([-0.3125+0.46351241j, -0.3125-0.46351241j])
	**/
	static public function roots(p:Dynamic):Dynamic;
	/**
		Rotate an array by 90 degrees in the plane specified by axes.
		
		Rotation direction is from the first towards the second axis.
		
		Parameters
		----------
		m : array_like
		    Array of two or more dimensions.
		k : integer
		    Number of times the array is rotated by 90 degrees.
		axes: (2,) array_like
		    The array is rotated in the plane defined by the axes.
		    Axes must be different.
		
		    .. versionadded:: 1.12.0
		
		Returns
		-------
		y : ndarray
		    A rotated view of `m`.
		
		See Also
		--------
		flip : Reverse the order of elements in an array along the given axis.
		fliplr : Flip an array horizontally.
		flipud : Flip an array vertically.
		
		Notes
		-----
		rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
		rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))
		
		Examples
		--------
		>>> m = np.array([[1,2],[3,4]], int)
		>>> m
		array([[1, 2],
		       [3, 4]])
		>>> np.rot90(m)
		array([[2, 4],
		       [1, 3]])
		>>> np.rot90(m, 2)
		array([[4, 3],
		       [2, 1]])
		>>> m = np.arange(8).reshape((2,2,2))
		>>> np.rot90(m, 1, (1,2))
		array([[[1, 3],
		        [0, 2]],
		       [[5, 7],
		        [4, 6]]])
	**/
	static public function rot90(m:Dynamic, ?k:Dynamic, ?axes:Dynamic):Dynamic;
	/**
		Round an array to the given number of decimals.
		
		See Also
		--------
		around : equivalent function; see for details.
	**/
	static public function round_(a:Dynamic, ?decimals:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Stack arrays in sequence vertically (row wise).
		
		This is equivalent to concatenation along the first axis after 1-D arrays
		of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
		`vsplit`.
		
		This function makes most sense for arrays with up to 3 dimensions. For
		instance, for pixel-data with a height (first axis), width (second axis),
		and r/g/b channels (third axis). The functions `concatenate`, `stack` and
		`block` provide more general stacking and concatenation operations.
		
		Parameters
		----------
		tup : sequence of ndarrays
		    The arrays must have the same shape along all but the first axis.
		    1-D arrays must have the same length.
		
		Returns
		-------
		stacked : ndarray
		    The array formed by stacking the given arrays, will be at least 2-D.
		
		See Also
		--------
		stack : Join a sequence of arrays along a new axis.
		hstack : Stack arrays in sequence horizontally (column wise).
		dstack : Stack arrays in sequence depth wise (along third dimension).
		concatenate : Join a sequence of arrays along an existing axis.
		vsplit : Split array into a list of multiple sub-arrays vertically.
		block : Assemble arrays from blocks.
		
		Examples
		--------
		>>> a = np.array([1, 2, 3])
		>>> b = np.array([2, 3, 4])
		>>> np.vstack((a,b))
		array([[1, 2, 3],
		       [2, 3, 4]])
		
		>>> a = np.array([[1], [2], [3]])
		>>> b = np.array([[2], [3], [4]])
		>>> np.vstack((a,b))
		array([[1],
		       [2],
		       [3],
		       [2],
		       [3],
		       [4]])
	**/
	static public function row_stack(tup:Dynamic):Dynamic;
	static public var s_ : Dynamic;
	/**
		Protected string evaluation.
		
		Evaluate a string containing a Python literal expression without
		allowing the execution of arbitrary non-literal code.
		
		Parameters
		----------
		source : str
		    The string to evaluate.
		
		Returns
		-------
		obj : object
		   The result of evaluating `source`.
		
		Raises
		------
		SyntaxError
		    If the code has invalid Python syntax, or if it contains
		    non-literal code.
		
		Examples
		--------
		>>> np.safe_eval('1')
		1
		>>> np.safe_eval('[1, 2, 3]')
		[1, 2, 3]
		>>> np.safe_eval('{"foo": ("bar", 10.0)}')
		{'foo': ('bar', 10.0)}
		
		>>> np.safe_eval('import os')
		Traceback (most recent call last):
		  ...
		SyntaxError: invalid syntax
		
		>>> np.safe_eval('open("/home/user/.ssh/id_dsa").read()')
		Traceback (most recent call last):
		  ...
		SyntaxError: Unsupported source construct: compiler.ast.CallFunc
	**/
	static public function safe_eval(source:Dynamic):Dynamic;
	/**
		random_sample(size=None)
		
		Return random floats in the half-open interval [0.0, 1.0).
		
		Results are from the "continuous uniform" distribution over the
		stated interval.  To sample :math:`Unif[a, b), b > a` multiply
		the output of `random_sample` by `(b-a)` and add `a`::
		
		  (b - a) * random_sample() + a
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray of floats
		    Array of random floats of shape `size` (unless ``size=None``, in which
		    case a single float is returned).
		
		Examples
		--------
		>>> np.random.random_sample()
		0.47108547995356098
		>>> type(np.random.random_sample())
		<type 'float'>
		>>> np.random.random_sample((5,))
		array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
		
		Three-by-two array of random numbers from [-5, 0):
		
		>>> 5 * np.random.random_sample((3, 2)) - 5
		array([[-3.99149989, -0.52338984],
		       [-2.99091858, -0.79479508],
		       [-1.23204345, -1.75224494]])
	**/
	static public function sample(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Save an array to a binary file in NumPy ``.npy`` format.
		
		Parameters
		----------
		file : file, str, or pathlib.Path
		    File or filename to which the data is saved.  If file is a file-object,
		    then the filename is unchanged.  If file is a string or Path, a ``.npy``
		    extension will be appended to the file name if it does not already
		    have one.
		arr : array_like
		    Array data to be saved.
		allow_pickle : bool, optional
		    Allow saving object arrays using Python pickles. Reasons for disallowing
		    pickles include security (loading pickled data can execute arbitrary
		    code) and portability (pickled objects may not be loadable on different
		    Python installations, for example if the stored objects require libraries
		    that are not available, and not all pickled data is compatible between
		    Python 2 and Python 3).
		    Default: True
		fix_imports : bool, optional
		    Only useful in forcing objects in object arrays on Python 3 to be
		    pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
		    will try to map the new Python 3 names to the old module names used in
		    Python 2, so that the pickle data stream is readable with Python 2.
		
		See Also
		--------
		savez : Save several arrays into a ``.npz`` archive
		savetxt, load
		
		Notes
		-----
		For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.
		
		Examples
		--------
		>>> from tempfile import TemporaryFile
		>>> outfile = TemporaryFile()
		
		>>> x = np.arange(10)
		>>> np.save(outfile, x)
		
		>>> outfile.seek(0) # Only needed here to simulate closing & reopening file
		>>> np.load(outfile)
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
	**/
	static public function save(file:Dynamic, arr:Dynamic, ?allow_pickle:Dynamic, ?fix_imports:Dynamic):Dynamic;
	/**
		Save the current figure.
		
		Call signature::
		
		  savefig(fname, dpi=None, facecolor='w', edgecolor='w',
		          orientation='portrait', papertype=None, format=None,
		          transparent=False, bbox_inches=None, pad_inches=0.1,
		          frameon=None, metadata=None)
		
		The output formats available depend on the backend being used.
		
		Parameters
		----------
		
		fname : str or PathLike or file-like object
		    A path, or a Python file-like object, or
		    possibly some backend-dependent object such as
		    `matplotlib.backends.backend_pdf.PdfPages`.
		
		    If *format* is not set, then the output format is inferred from
		    the extension of *fname*, if any, and from :rc:`savefig.format`
		    otherwise.  If *format* is set, it determines the output format.
		
		    Hence, if *fname* is not a path or has no extension, remember to
		    specify *format* to ensure that the correct backend is used.
		
		Other Parameters
		----------------
		
		dpi : [ *None* | scalar > 0 | 'figure' ]
		    The resolution in dots per inch.  If *None*, defaults to
		    :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
		
		quality : [ *None* | 1 <= scalar <= 100 ]
		    The image quality, on a scale from 1 (worst) to 95 (best).
		    Applicable only if *format* is jpg or jpeg, ignored otherwise.
		    If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
		    Values above 95 should be avoided; 100 completely disables the
		    JPEG quantization stage.
		
		optimize : bool
		    If *True*, indicates that the JPEG encoder should make an extra
		    pass over the image in order to select optimal encoder settings.
		    Applicable only if *format* is jpg or jpeg, ignored otherwise.
		    Is *False* by default.
		
		progressive : bool
		    If *True*, indicates that this image should be stored as a
		    progressive JPEG file. Applicable only if *format* is jpg or
		    jpeg, ignored otherwise. Is *False* by default.
		
		facecolor : color spec or None, optional
		    The facecolor of the figure; if *None*, defaults to
		    :rc:`savefig.facecolor`.
		
		edgecolor : color spec or None, optional
		    The edgecolor of the figure; if *None*, defaults to
		    :rc:`savefig.edgecolor`
		
		orientation : {'landscape', 'portrait'}
		    Currently only supported by the postscript backend.
		
		papertype : str
		    One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
		    'a10', 'b0' through 'b10'. Only supported for postscript
		    output.
		
		format : str
		    The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
		    this is unset is documented under *fname*.
		
		transparent : bool
		    If *True*, the axes patches will all be transparent; the
		    figure patch will also be transparent unless facecolor
		    and/or edgecolor are specified via kwargs.
		    This is useful, for example, for displaying
		    a plot on top of a colored background on a web page.  The
		    transparency of these patches will be restored to their
		    original values upon exit of this function.
		
		bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
		    Bbox in inches. Only the given portion of the figure is
		    saved. If 'tight', try to figure out the tight bbox of
		    the figure. If None, use savefig.bbox
		
		pad_inches : scalar, optional
		    Amount of padding around the figure when bbox_inches is
		    'tight'. If None, use savefig.pad_inches
		
		bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
		    A list of extra artists that will be considered when the
		    tight bbox is calculated.
		
		metadata : dict, optional
		    Key/value pairs to store in the image metadata. The supported keys
		    and defaults depend on the image format and backend:
		
		    - 'png' with Agg backend: See the parameter ``metadata`` of
		      `~.FigureCanvasAgg.print_png`.
		    - 'pdf' with pdf backend: See the parameter ``metadata`` of
		      `~.backend_pdf.PdfPages`.
		    - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
		
		pil_kwargs : dict, optional
		    Additional keyword arguments that are passed to `PIL.Image.save`
		    when saving the figure.  Only applicable for formats that are saved
		    using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
		    non-None value) PNG.
	**/
	static public function savefig(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Save an array to a text file.
		
		Parameters
		----------
		fname : filename or file handle
		    If the filename ends in ``.gz``, the file is automatically saved in
		    compressed gzip format.  `loadtxt` understands gzipped files
		    transparently.
		X : 1D or 2D array_like
		    Data to be saved to a text file.
		fmt : str or sequence of strs, optional
		    A single format (%10.5f), a sequence of formats, or a
		    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
		    case `delimiter` is ignored. For complex `X`, the legal options
		    for `fmt` are:
		
		    * a single specifier, `fmt='%.4e'`, resulting in numbers formatted
		      like `' (%s+%sj)' % (fmt, fmt)`
		    * a full string specifying every real and imaginary part, e.g.
		      `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns
		    * a list of specifiers, one per column - in this case, the real
		      and imaginary part must have separate specifiers,
		      e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns
		delimiter : str, optional
		    String or character separating columns.
		newline : str, optional
		    String or character separating lines.
		
		    .. versionadded:: 1.5.0
		header : str, optional
		    String that will be written at the beginning of the file.
		
		    .. versionadded:: 1.7.0
		footer : str, optional
		    String that will be written at the end of the file.
		
		    .. versionadded:: 1.7.0
		comments : str, optional
		    String that will be prepended to the ``header`` and ``footer`` strings,
		    to mark them as comments. Default: '# ',  as expected by e.g.
		    ``numpy.loadtxt``.
		
		    .. versionadded:: 1.7.0
		encoding : {None, str}, optional
		    Encoding used to encode the outputfile. Does not apply to output
		    streams. If the encoding is something other than 'bytes' or 'latin1'
		    you will not be able to load the file in NumPy versions < 1.14. Default
		    is 'latin1'.
		
		    .. versionadded:: 1.14.0
		
		
		See Also
		--------
		save : Save an array to a binary file in NumPy ``.npy`` format
		savez : Save several arrays into an uncompressed ``.npz`` archive
		savez_compressed : Save several arrays into a compressed ``.npz`` archive
		
		Notes
		-----
		Further explanation of the `fmt` parameter
		(``%[flag]width[.precision]specifier``):
		
		flags:
		    ``-`` : left justify
		
		    ``+`` : Forces to precede result with + or -.
		
		    ``0`` : Left pad the number with zeros instead of space (see width).
		
		width:
		    Minimum number of characters to be printed. The value is not truncated
		    if it has more characters.
		
		precision:
		    - For integer specifiers (eg. ``d,i,o,x``), the minimum number of
		      digits.
		    - For ``e, E`` and ``f`` specifiers, the number of digits to print
		      after the decimal point.
		    - For ``g`` and ``G``, the maximum number of significant digits.
		    - For ``s``, the maximum number of characters.
		
		specifiers:
		    ``c`` : character
		
		    ``d`` or ``i`` : signed decimal integer
		
		    ``e`` or ``E`` : scientific notation with ``e`` or ``E``.
		
		    ``f`` : decimal floating point
		
		    ``g,G`` : use the shorter of ``e,E`` or ``f``
		
		    ``o`` : signed octal
		
		    ``s`` : string of characters
		
		    ``u`` : unsigned decimal integer
		
		    ``x,X`` : unsigned hexadecimal integer
		
		This explanation of ``fmt`` is not complete, for an exhaustive
		specification see [1]_.
		
		References
		----------
		.. [1] `Format Specification Mini-Language
		       <https://docs.python.org/library/string.html#format-specification-mini-language>`_,
		       Python Documentation.
		
		Examples
		--------
		>>> x = y = z = np.arange(0.0,5.0,1.0)
		>>> np.savetxt('test.out', x, delimiter=',')   # X is an array
		>>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays
		>>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation
	**/
	static public function savetxt(fname:Dynamic, X:Dynamic, ?fmt:Dynamic, ?delimiter:Dynamic, ?newline:Dynamic, ?header:Dynamic, ?footer:Dynamic, ?comments:Dynamic, ?encoding:Dynamic):Dynamic;
	/**
		Save several arrays into a single file in uncompressed ``.npz`` format.
		
		If arguments are passed in with no keywords, the corresponding variable
		names, in the ``.npz`` file, are 'arr_0', 'arr_1', etc. If keyword
		arguments are given, the corresponding variable names, in the ``.npz``
		file will match the keyword names.
		
		Parameters
		----------
		file : str or file
		    Either the file name (string) or an open file (file-like object)
		    where the data will be saved. If file is a string or a Path, the
		    ``.npz`` extension will be appended to the file name if it is not
		    already there.
		args : Arguments, optional
		    Arrays to save to the file. Since it is not possible for Python to
		    know the names of the arrays outside `savez`, the arrays will be saved
		    with names "arr_0", "arr_1", and so on. These arguments can be any
		    expression.
		kwds : Keyword arguments, optional
		    Arrays to save to the file. Arrays will be saved in the file with the
		    keyword names.
		
		Returns
		-------
		None
		
		See Also
		--------
		save : Save a single array to a binary file in NumPy format.
		savetxt : Save an array to a file as plain text.
		savez_compressed : Save several arrays into a compressed ``.npz`` archive
		
		Notes
		-----
		The ``.npz`` file format is a zipped archive of files named after the
		variables they contain.  The archive is not compressed and each file
		in the archive contains one variable in ``.npy`` format. For a
		description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.
		
		When opening the saved ``.npz`` file with `load` a `NpzFile` object is
		returned. This is a dictionary-like object which can be queried for
		its list of arrays (with the ``.files`` attribute), and for the arrays
		themselves.
		
		Examples
		--------
		>>> from tempfile import TemporaryFile
		>>> outfile = TemporaryFile()
		>>> x = np.arange(10)
		>>> y = np.sin(x)
		
		Using `savez` with \*args, the arrays are saved with default names.
		
		>>> np.savez(outfile, x, y)
		>>> outfile.seek(0) # Only needed here to simulate closing & reopening file
		>>> npzfile = np.load(outfile)
		>>> npzfile.files
		['arr_1', 'arr_0']
		>>> npzfile['arr_0']
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
		
		Using `savez` with \**kwds, the arrays are saved with the keyword names.
		
		>>> outfile = TemporaryFile()
		>>> np.savez(outfile, x=x, y=y)
		>>> outfile.seek(0)
		>>> npzfile = np.load(outfile)
		>>> npzfile.files
		['y', 'x']
		>>> npzfile['x']
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
	**/
	static public function savez(file:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwds:python.KwArgs<Dynamic>):Dynamic;
	/**
		Save several arrays into a single file in compressed ``.npz`` format.
		
		If keyword arguments are given, then filenames are taken from the keywords.
		If arguments are passed in with no keywords, then stored file names are
		arr_0, arr_1, etc.
		
		Parameters
		----------
		file : str or file
		    Either the file name (string) or an open file (file-like object)
		    where the data will be saved. If file is a string or a Path, the
		    ``.npz`` extension will be appended to the file name if it is not
		    already there.
		args : Arguments, optional
		    Arrays to save to the file. Since it is not possible for Python to
		    know the names of the arrays outside `savez`, the arrays will be saved
		    with names "arr_0", "arr_1", and so on. These arguments can be any
		    expression.
		kwds : Keyword arguments, optional
		    Arrays to save to the file. Arrays will be saved in the file with the
		    keyword names.
		
		Returns
		-------
		None
		
		See Also
		--------
		numpy.save : Save a single array to a binary file in NumPy format.
		numpy.savetxt : Save an array to a file as plain text.
		numpy.savez : Save several arrays into an uncompressed ``.npz`` file format
		numpy.load : Load the files created by savez_compressed.
		
		Notes
		-----
		The ``.npz`` file format is a zipped archive of files named after the
		variables they contain.  The archive is compressed with
		``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable
		in ``.npy`` format. For a description of the ``.npy`` format, see 
		:py:mod:`numpy.lib.format`.
		
		
		When opening the saved ``.npz`` file with `load` a `NpzFile` object is
		returned. This is a dictionary-like object which can be queried for
		its list of arrays (with the ``.files`` attribute), and for the arrays
		themselves.
		
		Examples
		--------
		>>> test_array = np.random.rand(3, 2)
		>>> test_vector = np.random.rand(4)
		>>> np.savez_compressed('/tmp/123', a=test_array, b=test_vector)
		>>> loaded = np.load('/tmp/123.npz')
		>>> print(np.array_equal(test_array, loaded['a']))
		True
		>>> print(np.array_equal(test_vector, loaded['b']))
		True
	**/
	static public function savez_compressed(file:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwds:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the current Axes instance to *ax*.
		
		The current Figure is updated to the parent of *ax*.
	**/
	static public function sca(ax:Dynamic):Dynamic;
	/**
		A scatter plot of *y* vs *x* with varying marker size and/or color.
		
		Parameters
		----------
		x, y : array_like, shape (n, )
		    The data positions.
		
		s : scalar or array_like, shape (n, ), optional
		    The marker size in points**2.
		    Default is ``rcParams['lines.markersize'] ** 2``.
		
		c : color, sequence, or sequence of color, optional
		    The marker color. Possible values:
		
		    - A single color format string.
		    - A sequence of color specifications of length n.
		    - A sequence of n numbers to be mapped to colors using *cmap* and
		      *norm*.
		    - A 2-D array in which the rows are RGB or RGBA.
		
		    Note that *c* should not be a single numeric RGB or RGBA sequence
		    because that is indistinguishable from an array of values to be
		    colormapped. If you want to specify the same RGB or RGBA value for
		    all points, use a 2-D array with a single row.  Otherwise, value-
		    matching will have precedence in case of a size matching with *x*
		    and *y*.
		
		    Defaults to ``None``. In that case the marker color is determined
		    by the value of ``color``, ``facecolor`` or ``facecolors``. In case
		    those are not specified or ``None``, the marker color is determined
		    by the next color of the ``Axes``' current "shape and fill" color
		    cycle. This cycle defaults to :rc:`axes.prop_cycle`.
		
		marker : `~matplotlib.markers.MarkerStyle`, optional
		    The marker style. *marker* can be either an instance of the class
		    or the text shorthand for a particular marker.
		    Defaults to ``None``, in which case it takes the value of
		    :rc:`scatter.marker` = 'o'.
		    See `~matplotlib.markers` for more information about marker styles.
		
		cmap : `~matplotlib.colors.Colormap`, optional, default: None
		    A `.Colormap` instance or registered colormap name. *cmap* is only
		    used if *c* is an array of floats. If ``None``, defaults to rc
		    ``image.cmap``.
		
		norm : `~matplotlib.colors.Normalize`, optional, default: None
		    A `.Normalize` instance is used to scale luminance data to 0, 1.
		    *norm* is only used if *c* is an array of floats. If *None*, use
		    the default `.colors.Normalize`.
		
		vmin, vmax : scalar, optional, default: None
		    *vmin* and *vmax* are used in conjunction with *norm* to normalize
		    luminance data. If None, the respective min and max of the color
		    array is used. *vmin* and *vmax* are ignored if you pass a *norm*
		    instance.
		
		alpha : scalar, optional, default: None
		    The alpha blending value, between 0 (transparent) and 1 (opaque).
		
		linewidths : scalar or array_like, optional, default: None
		    The linewidth of the marker edges. Note: The default *edgecolors*
		    is 'face'. You may want to change this as well.
		    If *None*, defaults to rcParams ``lines.linewidth``.
		
		edgecolors : {'face', 'none', *None*} or color or sequence of color, optional.
		    The edge color of the marker. Possible values:
		
		    - 'face': The edge color will always be the same as the face color.
		    - 'none': No patch boundary will be drawn.
		    - A Matplotlib color or sequence of color.
		
		    Defaults to ``None``, in which case it takes the value of
		    :rc:`scatter.edgecolors` = 'face'.
		
		    For non-filled markers, the *edgecolors* kwarg is ignored and
		    forced to 'face' internally.
		
		plotnonfinite : boolean, optional, default: False
		    Set to plot points with nonfinite *c*, in conjunction with
		    `~matplotlib.colors.Colormap.set_bad`.
		
		Returns
		-------
		paths : `~matplotlib.collections.PathCollection`
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.collections.Collection` properties
		
		See Also
		--------
		plot : To plot scatter plots when markers are identical in size and
		    color.
		
		Notes
		-----
		
		* The `.plot` function will be faster for scatterplots where markers
		  don't vary in size or color.
		
		* Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
		  case all masks will be combined and only unmasked points will be
		  plotted.
		
		* Fundamentally, scatter works with 1-D arrays; *x*, *y*, *s*, and *c*
		  may be input as 2-D arrays, but within scatter they will be
		  flattened. The exception is *c*, which will be flattened only if its
		  size matches the size of *x* and *y*.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'c', 'color', 'edgecolors', 'facecolor', 'facecolors', 'linewidths', 's', 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function scatter(x:Dynamic, y:Dynamic, ?s:Dynamic, ?c:Dynamic, ?marker:Dynamic, ?cmap:Dynamic, ?norm:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?alpha:Dynamic, ?linewidths:Dynamic, ?verts:Dynamic, ?edgecolors:Dynamic, ?plotnonfinite:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the current image.
		
		This image will be the target of colormap functions like
		`~.pyplot.viridis`, and other functions such as `~.pyplot.clim`.  The
		current image is an attribute of the current axes.
	**/
	static public function sci(im:Dynamic):Dynamic;
	/**
		Return the string representation of a scalar dtype.
		
		Parameters
		----------
		sctype : scalar dtype or object
		    If a scalar dtype, the corresponding string character is
		    returned. If an object, `sctype2char` tries to infer its scalar type
		    and then return the corresponding string character.
		
		Returns
		-------
		typechar : str
		    The string character corresponding to the scalar type.
		
		Raises
		------
		ValueError
		    If `sctype` is an object for which the type can not be inferred.
		
		See Also
		--------
		obj2sctype, issctype, issubsctype, mintypecode
		
		Examples
		--------
		>>> for sctype in [np.int32, float, complex, np.string_, np.ndarray]:
		...     print(np.sctype2char(sctype))
		l
		d
		D
		S
		O
		
		>>> x = np.array([1., 2-1.j])
		>>> np.sctype2char(x)
		'D'
		>>> np.sctype2char(list)
		'O'
	**/
	static public function sctype2char(sctype:Dynamic):String;
	static public var sctypeDict : Dynamic;
	static public var sctypeNA : Dynamic;
	static public var sctypes : Dynamic;
	/**
		Find indices where elements should be inserted to maintain order.
		
		Find the indices into a sorted array `a` such that, if the
		corresponding elements in `v` were inserted before the indices, the
		order of `a` would be preserved.
		
		Assuming that `a` is sorted:
		
		======  ============================
		`side`  returned index `i` satisfies
		======  ============================
		left    ``a[i-1] < v <= a[i]``
		right   ``a[i-1] <= v < a[i]``
		======  ============================
		
		Parameters
		----------
		a : 1-D array_like
		    Input array. If `sorter` is None, then it must be sorted in
		    ascending order, otherwise `sorter` must be an array of indices
		    that sort it.
		v : array_like
		    Values to insert into `a`.
		side : {'left', 'right'}, optional
		    If 'left', the index of the first suitable location found is given.
		    If 'right', return the last such index.  If there is no suitable
		    index, return either 0 or N (where N is the length of `a`).
		sorter : 1-D array_like, optional
		    Optional array of integer indices that sort array a into ascending
		    order. They are typically the result of argsort.
		
		    .. versionadded:: 1.7.0
		
		Returns
		-------
		indices : array of ints
		    Array of insertion points with the same shape as `v`.
		
		See Also
		--------
		sort : Return a sorted copy of an array.
		histogram : Produce histogram from 1-D data.
		
		Notes
		-----
		Binary search is used to find the required insertion points.
		
		As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
		`nan` values. The enhanced sort order is documented in `sort`.
		
		This function is a faster version of the builtin python `bisect.bisect_left`
		(``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
		which is also vectorized in the `v` argument.
		
		Examples
		--------
		>>> np.searchsorted([1,2,3,4,5], 3)
		2
		>>> np.searchsorted([1,2,3,4,5], 3, side='right')
		3
		>>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
		array([0, 5, 1, 2])
	**/
	static public function searchsorted(a:Dynamic, v:Dynamic, ?side:Dynamic, ?sorter:Dynamic):Dynamic;
	/**
		seed(seed=None)
		
		Seed the generator.
		
		This method is called when `RandomState` is initialized. It can be
		called again to re-seed the generator. For details, see `RandomState`.
		
		Parameters
		----------
		seed : int or 1-d array_like, optional
		    Seed for `RandomState`.
		    Must be convertible to 32 bit unsigned integers.
		
		See Also
		--------
		RandomState
	**/
	static public function seed(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return an array drawn from elements in choicelist, depending on conditions.
		
		Parameters
		----------
		condlist : list of bool ndarrays
		    The list of conditions which determine from which array in `choicelist`
		    the output elements are taken. When multiple conditions are satisfied,
		    the first one encountered in `condlist` is used.
		choicelist : list of ndarrays
		    The list of arrays from which the output elements are taken. It has
		    to be of the same length as `condlist`.
		default : scalar, optional
		    The element inserted in `output` when all conditions evaluate to False.
		
		Returns
		-------
		output : ndarray
		    The output at position m is the m-th element of the array in
		    `choicelist` where the m-th element of the corresponding array in
		    `condlist` is True.
		
		See Also
		--------
		where : Return elements from one of two arrays depending on condition.
		take, choose, compress, diag, diagonal
		
		Examples
		--------
		>>> x = np.arange(10)
		>>> condlist = [x<3, x>5]
		>>> choicelist = [x, x**2]
		>>> np.select(condlist, choicelist)
		array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])
	**/
	static public function select(condlist:Dynamic, choicelist:Dynamic, ?_default:Dynamic):Dynamic;
	/**
		Make a plot with log scaling on the x axis.
		
		Call signatures::
		
		    semilogx([x], y, [fmt], data=None, **kwargs)
		    semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
		
		This is just a thin wrapper around `.plot` which additionally changes
		the x-axis to log scaling. All of the concepts and parameters of plot
		can be used here as well.
		
		The additional parameters *basex*, *subsx* and *nonposx* control the
		x-axis properties. They are just forwarded to `.Axes.set_xscale`.
		
		Parameters
		----------
		basex : scalar, optional, default 10
		    Base of the x logarithm.
		
		subsx : array_like, optional
		    The location of the minor xticks. If *None*, reasonable locations
		    are automatically chosen depending on the number of decades in the
		    plot. See `.Axes.set_xscale` for details.
		
		nonposx : {'mask', 'clip'}, optional, default 'mask'
		    Non-positive values in x can be masked as invalid, or clipped to a
		    very small positive number.
		
		Returns
		-------
		lines
		    A list of `~.Line2D` objects representing the plotted data.
		
		Other Parameters
		----------------
		**kwargs
		    All parameters supported by `.plot`.
	**/
	static public function semilogx(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Make a plot with log scaling on the y axis.
		
		Call signatures::
		
		    semilogy([x], y, [fmt], data=None, **kwargs)
		    semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
		
		This is just a thin wrapper around `.plot` which additionally changes
		the y-axis to log scaling. All of the concepts and parameters of plot
		can be used here as well.
		
		The additional parameters *basey*, *subsy* and *nonposy* control the
		y-axis properties. They are just forwarded to `.Axes.set_yscale`.
		
		Parameters
		----------
		basey : scalar, optional, default 10
		    Base of the y logarithm.
		
		subsy : array_like, optional
		    The location of the minor yticks. If *None*, reasonable locations
		    are automatically chosen depending on the number of decades in the
		    plot. See `.Axes.set_yscale` for details.
		
		nonposy : {'mask', 'clip'}, optional, default 'mask'
		    Non-positive values in y can be masked as invalid, or clipped to a
		    very small positive number.
		
		Returns
		-------
		lines
		    A list of `~.Line2D` objects representing the plotted data.
		
		Other Parameters
		----------------
		**kwargs
		    All parameters supported by `.plot`.
	**/
	static public function semilogy(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the default colormap.  Applies to the current image if any.
		See help(colormaps) for more information.
		
		*cmap* must be a :class:`~matplotlib.colors.Colormap` instance, or
		the name of a registered colormap.
		
		See :func:`matplotlib.cm.register_cmap` and
		:func:`matplotlib.cm.get_cmap`.
	**/
	static public function set_cmap(cmap:Dynamic):Dynamic;
	/**
		Sets the Matplotlib's root logger and root logger handler level, creating
		the handler if it does not exist yet.
		
		Typically, one should call ``set_loglevel("info")`` or
		``set_loglevel("debug")`` to get additional debugging information.
		
		Parameters
		----------
		level : {"notset", "debug", "info", "warning", "error", "critical"}
		    The log level of the handler.
		
		Notes
		-----
		The first time this function is called, an additional handler is attached
		to Matplotlib's root handler; this handler is reused every time and this
		function simply manipulates the logger and handler's level.
	**/
	static public function set_loglevel(level:Dynamic):Dynamic;
	/**
		set_numeric_ops(op1=func1, op2=func2, ...)
		
		Set numerical operators for array objects.
		
		.. deprecated:: 1.16
		
		    For the general case, use :c:func:`PyUFunc_ReplaceLoopBySignature`.
		    For ndarray subclasses, define the ``__array_ufunc__`` method and
		    override the relevant ufunc.
		
		Parameters
		----------
		op1, op2, ... : callable
		    Each ``op = func`` pair describes an operator to be replaced.
		    For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace
		    addition by modulus 5 addition.
		
		Returns
		-------
		saved_ops : list of callables
		    A list of all operators, stored before making replacements.
		
		Notes
		-----
		.. WARNING::
		   Use with care!  Incorrect usage may lead to memory errors.
		
		A function replacing an operator cannot make use of that operator.
		For example, when replacing add, you may not use ``+``.  Instead,
		directly call ufuncs.
		
		Examples
		--------
		>>> def add_mod5(x, y):
		...     return np.add(x, y) % 5
		...
		>>> old_funcs = np.set_numeric_ops(add=add_mod5)
		
		>>> x = np.arange(12).reshape((3, 4))
		>>> x + x
		array([[0, 2, 4, 1],
		       [3, 0, 2, 4],
		       [1, 3, 0, 2]])
		
		>>> ignore = np.set_numeric_ops(**old_funcs) # restore operators
	**/
	static public function set_numeric_ops(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set printing options.
		
		These options determine the way floating point numbers, arrays and
		other NumPy objects are displayed.
		
		Parameters
		----------
		precision : int or None, optional
		    Number of digits of precision for floating point output (default 8).
		    May be `None` if `floatmode` is not `fixed`, to print as many digits as
		    necessary to uniquely specify the value.
		threshold : int, optional
		    Total number of array elements which trigger summarization
		    rather than full repr (default 1000).
		edgeitems : int, optional
		    Number of array items in summary at beginning and end of
		    each dimension (default 3).
		linewidth : int, optional
		    The number of characters per line for the purpose of inserting
		    line breaks (default 75).
		suppress : bool, optional
		    If True, always print floating point numbers using fixed point
		    notation, in which case numbers equal to zero in the current precision
		    will print as zero.  If False, then scientific notation is used when
		    absolute value of the smallest number is < 1e-4 or the ratio of the
		    maximum absolute value to the minimum is > 1e3. The default is False.
		nanstr : str, optional
		    String representation of floating point not-a-number (default nan).
		infstr : str, optional
		    String representation of floating point infinity (default inf).
		sign : string, either '-', '+', or ' ', optional
		    Controls printing of the sign of floating-point types. If '+', always
		    print the sign of positive values. If ' ', always prints a space
		    (whitespace character) in the sign position of positive values.  If
		    '-', omit the sign character of positive values. (default '-')
		formatter : dict of callables, optional
		    If not None, the keys should indicate the type(s) that the respective
		    formatting function applies to.  Callables should return a string.
		    Types that are not specified (by their corresponding keys) are handled
		    by the default formatters.  Individual types for which a formatter
		    can be set are:
		
		    - 'bool'
		    - 'int'
		    - 'timedelta' : a `numpy.timedelta64`
		    - 'datetime' : a `numpy.datetime64`
		    - 'float'
		    - 'longfloat' : 128-bit floats
		    - 'complexfloat'
		    - 'longcomplexfloat' : composed of two 128-bit floats
		    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
		    - 'object' : `np.object_` arrays
		    - 'str' : all other strings
		
		    Other keys that can be used to set a group of types at once are:
		
		    - 'all' : sets all types
		    - 'int_kind' : sets 'int'
		    - 'float_kind' : sets 'float' and 'longfloat'
		    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
		    - 'str_kind' : sets 'str' and 'numpystr'
		floatmode : str, optional
		    Controls the interpretation of the `precision` option for
		    floating-point types. Can take the following values:
		
		    * 'fixed': Always print exactly `precision` fractional digits,
		            even if this would print more or fewer digits than
		            necessary to specify the value uniquely.
		    * 'unique': Print the minimum number of fractional digits necessary
		            to represent each value uniquely. Different elements may
		            have a different number of digits. The value of the
		            `precision` option is ignored.
		    * 'maxprec': Print at most `precision` fractional digits, but if
		            an element can be uniquely represented with fewer digits
		            only print it with that many.
		    * 'maxprec_equal': Print at most `precision` fractional digits,
		            but if every element in the array can be uniquely
		            represented with an equal number of fewer digits, use that
		            many digits for all elements.
		legacy : string or `False`, optional
		    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
		    approximates numpy 1.13 print output by including a space in the sign
		    position of floats and different behavior for 0d arrays. If set to
		    `False`, disables legacy mode. Unrecognized strings will be ignored
		    with a warning for forward compatibility.
		
		    .. versionadded:: 1.14.0
		
		See Also
		--------
		get_printoptions, set_string_function, array2string
		
		Notes
		-----
		`formatter` is always reset with a call to `set_printoptions`.
		
		Examples
		--------
		Floating point precision can be set:
		
		>>> np.set_printoptions(precision=4)
		>>> print(np.array([1.123456789]))
		[ 1.1235]
		
		Long arrays can be summarised:
		
		>>> np.set_printoptions(threshold=5)
		>>> print(np.arange(10))
		[0 1 2 ..., 7 8 9]
		
		Small results can be suppressed:
		
		>>> eps = np.finfo(float).eps
		>>> x = np.arange(4.)
		>>> x**2 - (x + eps)**2
		array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])
		>>> np.set_printoptions(suppress=True)
		>>> x**2 - (x + eps)**2
		array([-0., -0.,  0.,  0.])
		
		A custom formatter can be used to display array elements as desired:
		
		>>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})
		>>> x = np.arange(3)
		>>> x
		array([int: 0, int: -1, int: -2])
		>>> np.set_printoptions()  # formatter gets reset
		>>> x
		array([0, 1, 2])
		
		To put back the default options, you can use:
		
		>>> np.set_printoptions(edgeitems=3,infstr='inf',
		... linewidth=75, nanstr='nan', precision=8,
		... suppress=False, threshold=1000, formatter=None)
	**/
	static public function set_printoptions(?precision:Dynamic, ?threshold:Dynamic, ?edgeitems:Dynamic, ?linewidth:Dynamic, ?suppress:Dynamic, ?nanstr:Dynamic, ?infstr:Dynamic, ?formatter:Dynamic, ?sign:Dynamic, ?floatmode:Dynamic, ?kwarg:python.KwArgs<Dynamic>):Dynamic;
	/**
		set_state(state)
		
		Set the internal state of the generator from a tuple.
		
		For use if one has reason to manually (re-)set the internal state of the
		"Mersenne Twister"[1]_ pseudo-random number generating algorithm.
		
		Parameters
		----------
		state : tuple(str, ndarray of 624 uints, int, int, float)
		    The `state` tuple has the following items:
		
		    1. the string 'MT19937', specifying the Mersenne Twister algorithm.
		    2. a 1-D array of 624 unsigned integers ``keys``.
		    3. an integer ``pos``.
		    4. an integer ``has_gauss``.
		    5. a float ``cached_gaussian``.
		
		Returns
		-------
		out : None
		    Returns 'None' on success.
		
		See Also
		--------
		get_state
		
		Notes
		-----
		`set_state` and `get_state` are not needed to work with any of the
		random distributions in NumPy. If the internal state is manually altered,
		the user should know exactly what he/she is doing.
		
		For backwards compatibility, the form (str, array of 624 uints, int) is
		also accepted although it is missing some information about the cached
		Gaussian value: ``state = ('MT19937', keys, pos)``.
		
		References
		----------
		.. [1] M. Matsumoto and T. Nishimura, "Mersenne Twister: A
		   623-dimensionally equidistributed uniform pseudorandom number
		   generator," *ACM Trans. on Modeling and Computer Simulation*,
		   Vol. 8, No. 1, pp. 3-30, Jan. 1998.
	**/
	static public function set_state(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set a Python function to be used when pretty printing arrays.
		
		Parameters
		----------
		f : function or None
		    Function to be used to pretty print arrays. The function should expect
		    a single array argument and return a string of the representation of
		    the array. If None, the function is reset to the default NumPy function
		    to print arrays.
		repr : bool, optional
		    If True (default), the function for pretty printing (``__repr__``)
		    is set, if False the function that returns the default string
		    representation (``__str__``) is set.
		
		See Also
		--------
		set_printoptions, get_printoptions
		
		Examples
		--------
		>>> def pprint(arr):
		...     return 'HA! - What are you going to do now?'
		...
		>>> np.set_string_function(pprint)
		>>> a = np.arange(10)
		>>> a
		HA! - What are you going to do now?
		>>> print(a)
		[0 1 2 3 4 5 6 7 8 9]
		
		We can reset the function to the default:
		
		>>> np.set_string_function(None)
		>>> a
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
		
		`repr` affects either pretty printing or normal string representation.
		Note that ``__repr__`` is still affected by setting ``__str__``
		because the width of each array element in the returned string becomes
		equal to the length of the result of ``__str__()``.
		
		>>> x = np.arange(4)
		>>> np.set_string_function(lambda x:'random', repr=False)
		>>> x.__str__()
		'random'
		>>> x.__repr__()
		'array([     0,      1,      2,      3])'
	**/
	static public function set_string_function(f:Dynamic, ?repr:Dynamic):Dynamic;
	/**
		Set the size of the buffer used in ufuncs.
		
		Parameters
		----------
		size : int
		    Size of buffer.
	**/
	static public function setbufsize(size:Dynamic):Dynamic;
	/**
		Find the set difference of two arrays.
		
		Return the unique values in `ar1` that are not in `ar2`.
		
		Parameters
		----------
		ar1 : array_like
		    Input array.
		ar2 : array_like
		    Input comparison array.
		assume_unique : bool
		    If True, the input arrays are both assumed to be unique, which
		    can speed up the calculation.  Default is False.
		
		Returns
		-------
		setdiff1d : ndarray
		    1D array of values in `ar1` that are not in `ar2`. The result
		    is sorted when `assume_unique=False`, but otherwise only sorted
		    if the input is sorted.
		
		See Also
		--------
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Examples
		--------
		>>> a = np.array([1, 2, 3, 2, 4, 1])
		>>> b = np.array([3, 4, 5, 6])
		>>> np.setdiff1d(a, b)
		array([1, 2])
	**/
	static public function setdiff1d(ar1:Dynamic, ar2:Dynamic, ?assume_unique:Dynamic):Dynamic;
	/**
		Set how floating-point errors are handled.
		
		Note that operations on integer scalar types (such as `int16`) are
		handled like floating point, and are affected by these settings.
		
		Parameters
		----------
		all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
		    Set treatment for all types of floating-point errors at once:
		
		    - ignore: Take no action when the exception occurs.
		    - warn: Print a `RuntimeWarning` (via the Python `warnings` module).
		    - raise: Raise a `FloatingPointError`.
		    - call: Call a function specified using the `seterrcall` function.
		    - print: Print a warning directly to ``stdout``.
		    - log: Record error in a Log object specified by `seterrcall`.
		
		    The default is not to change the current behavior.
		divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
		    Treatment for division by zero.
		over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
		    Treatment for floating-point overflow.
		under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
		    Treatment for floating-point underflow.
		invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
		    Treatment for invalid floating-point operation.
		
		Returns
		-------
		old_settings : dict
		    Dictionary containing the old settings.
		
		See also
		--------
		seterrcall : Set a callback function for the 'call' mode.
		geterr, geterrcall, errstate
		
		Notes
		-----
		The floating-point exceptions are defined in the IEEE 754 standard [1]_:
		
		- Division by zero: infinite result obtained from finite numbers.
		- Overflow: result too large to be expressed.
		- Underflow: result so close to zero that some precision
		  was lost.
		- Invalid operation: result is not an expressible number, typically
		  indicates that a NaN was produced.
		
		.. [1] https://en.wikipedia.org/wiki/IEEE_754
		
		Examples
		--------
		>>> old_settings = np.seterr(all='ignore')  #seterr to known value
		>>> np.seterr(over='raise')
		{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',
		 'under': 'ignore'}
		>>> np.seterr(**old_settings)  # reset to default
		{'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore',
		 'under': 'ignore'}
		
		>>> np.int16(32000) * np.int16(3)
		30464
		>>> old_settings = np.seterr(all='warn', over='raise')
		>>> np.int16(32000) * np.int16(3)
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		FloatingPointError: overflow encountered in short_scalars
		
		>>> old_settings = np.seterr(all='print')
		>>> np.geterr()
		{'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}
		>>> np.int16(32000) * np.int16(3)
		Warning: overflow encountered in short_scalars
		30464
	**/
	static public function seterr(?all:Dynamic, ?divide:Dynamic, ?over:Dynamic, ?under:Dynamic, ?invalid:Dynamic):python.Dict<Dynamic, Dynamic>;
	/**
		Set the floating-point error callback function or log object.
		
		There are two ways to capture floating-point error messages.  The first
		is to set the error-handler to 'call', using `seterr`.  Then, set
		the function to call using this function.
		
		The second is to set the error-handler to 'log', using `seterr`.
		Floating-point errors then trigger a call to the 'write' method of
		the provided object.
		
		Parameters
		----------
		func : callable f(err, flag) or object with write method
		    Function to call upon floating-point errors ('call'-mode) or
		    object whose 'write' method is used to log such message ('log'-mode).
		
		    The call function takes two arguments. The first is a string describing
		    the type of error (such as "divide by zero", "overflow", "underflow",
		    or "invalid value"), and the second is the status flag.  The flag is a
		    byte, whose four least-significant bits indicate the type of error, one
		    of "divide", "over", "under", "invalid"::
		
		      [0 0 0 0 divide over under invalid]
		
		    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.
		
		    If an object is provided, its write method should take one argument,
		    a string.
		
		Returns
		-------
		h : callable, log instance or None
		    The old error handler.
		
		See Also
		--------
		seterr, geterr, geterrcall
		
		Examples
		--------
		Callback upon error:
		
		>>> def err_handler(type, flag):
		...     print("Floating point error (%s), with flag %s" % (type, flag))
		...
		
		>>> saved_handler = np.seterrcall(err_handler)
		>>> save_err = np.seterr(all='call')
		
		>>> np.array([1, 2, 3]) / 0.0
		Floating point error (divide by zero), with flag 1
		array([ Inf,  Inf,  Inf])
		
		>>> np.seterrcall(saved_handler)
		<function err_handler at 0x...>
		>>> np.seterr(**save_err)
		{'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}
		
		Log error message:
		
		>>> class Log(object):
		...     def write(self, msg):
		...         print("LOG: %s" % msg)
		...
		
		>>> log = Log()
		>>> saved_handler = np.seterrcall(log)
		>>> save_err = np.seterr(all='log')
		
		>>> np.array([1, 2, 3]) / 0.0
		LOG: Warning: divide by zero encountered in divide
		<BLANKLINE>
		array([ Inf,  Inf,  Inf])
		
		>>> np.seterrcall(saved_handler)
		<__main__.Log object at 0x...>
		>>> np.seterr(**save_err)
		{'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}
	**/
	static public function seterrcall(func:Dynamic):Dynamic;
	/**
		seterrobj(errobj)
		
		Set the object that defines floating-point error handling.
		
		The error object contains all information that defines the error handling
		behavior in NumPy. `seterrobj` is used internally by the other
		functions that set error handling behavior (`seterr`, `seterrcall`).
		
		Parameters
		----------
		errobj : list
		    The error object, a list containing three elements:
		    [internal numpy buffer size, error mask, error callback function].
		
		    The error mask is a single integer that holds the treatment information
		    on all four floating point errors. The information for each error type
		    is contained in three bits of the integer. If we print it in base 8, we
		    can see what treatment is set for "invalid", "under", "over", and
		    "divide" (in that order). The printed string can be interpreted with
		
		    * 0 : 'ignore'
		    * 1 : 'warn'
		    * 2 : 'raise'
		    * 3 : 'call'
		    * 4 : 'print'
		    * 5 : 'log'
		
		See Also
		--------
		geterrobj, seterr, geterr, seterrcall, geterrcall
		getbufsize, setbufsize
		
		Notes
		-----
		For complete documentation of the types of floating-point exceptions and
		treatment options, see `seterr`.
		
		Examples
		--------
		>>> old_errobj = np.geterrobj()  # first get the defaults
		>>> old_errobj
		[10000, 0, None]
		
		>>> def err_handler(type, flag):
		...     print("Floating point error (%s), with flag %s" % (type, flag))
		...
		>>> new_errobj = [20000, 12, err_handler]
		>>> np.seterrobj(new_errobj)
		>>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')
		'14'
		>>> np.geterr()
		{'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}
		>>> np.geterrcall() is err_handler
		True
	**/
	static public function seterrobj(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Set a property on an artist object.
		
		matplotlib supports the use of :func:`setp` ("set property") and
		:func:`getp` to set and get object properties, as well as to do
		introspection on the object.  For example, to set the linestyle of a
		line to be dashed, you can do::
		
		  >>> line, = plot([1,2,3])
		  >>> setp(line, linestyle='--')
		
		If you want to know the valid types of arguments, you can provide
		the name of the property you want to set without a value::
		
		  >>> setp(line, 'linestyle')
		      linestyle: [ '-' | '--' | '-.' | ':' | 'steps' | 'None' ]
		
		If you want to see all the properties that can be set, and their
		possible values, you can do::
		
		  >>> setp(line)
		      ... long output listing omitted
		
		You may specify another output file to `setp` if `sys.stdout` is not
		acceptable for some reason using the `file` keyword-only argument::
		
		  >>> with fopen('output.log') as f:
		  >>>     setp(line, file=f)
		
		:func:`setp` operates on a single instance or a iterable of
		instances. If you are in query mode introspecting the possible
		values, only the first instance in the sequence is used. When
		actually setting values, all the instances will be set.  e.g.,
		suppose you have a list of two lines, the following will make both
		lines thicker and red::
		
		  >>> x = arange(0,1.0,0.01)
		  >>> y1 = sin(2*pi*x)
		  >>> y2 = sin(4*pi*x)
		  >>> lines = plot(x, y1, x, y2)
		  >>> setp(lines, linewidth=2, color='r')
		
		:func:`setp` works with the MATLAB style string/value pairs or
		with python kwargs.  For example, the following are equivalent::
		
		  >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style
		  >>> setp(lines, linewidth=2, color='r')        # python style
	**/
	static public function setp(obj:Dynamic, ?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Find the set exclusive-or of two arrays.
		
		Return the sorted, unique values that are in only one (not both) of the
		input arrays.
		
		Parameters
		----------
		ar1, ar2 : array_like
		    Input arrays.
		assume_unique : bool
		    If True, the input arrays are both assumed to be unique, which
		    can speed up the calculation.  Default is False.
		
		Returns
		-------
		setxor1d : ndarray
		    Sorted 1D array of unique values that are in only one of the input
		    arrays.
		
		Examples
		--------
		>>> a = np.array([1, 2, 3, 2, 4])
		>>> b = np.array([2, 3, 5, 7, 5])
		>>> np.setxor1d(a,b)
		array([1, 4, 5, 7])
	**/
	static public function setxor1d(ar1:Dynamic, ar2:Dynamic, ?assume_unique:Dynamic):Dynamic;
	/**
		Return the shape of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.
		
		Returns
		-------
		shape : tuple of ints
		    The elements of the shape tuple give the lengths of the
		    corresponding array dimensions.
		
		See Also
		--------
		alen
		ndarray.shape : Equivalent array method.
		
		Examples
		--------
		>>> np.shape(np.eye(3))
		(3, 3)
		>>> np.shape([[1, 2]])
		(1, 2)
		>>> np.shape([0])
		(1,)
		>>> np.shape(0)
		()
		
		>>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
		>>> np.shape(a)
		(2,)
		>>> a.shape
		(2,)
	**/
	static public function shape(a:Dynamic):Dynamic;
	/**
		shares_memory(a, b, max_work=None)
		
		Determine if two arrays share memory
		
		Parameters
		----------
		a, b : ndarray
		    Input arrays
		max_work : int, optional
		    Effort to spend on solving the overlap problem (maximum number
		    of candidate solutions to consider). The following special
		    values are recognized:
		
		    max_work=MAY_SHARE_EXACT  (default)
		        The problem is solved exactly. In this case, the function returns
		        True only if there is an element shared between the arrays.
		    max_work=MAY_SHARE_BOUNDS
		        Only the memory bounds of a and b are checked.
		
		Raises
		------
		numpy.TooHardError
		    Exceeded max_work.
		
		Returns
		-------
		out : bool
		
		See Also
		--------
		may_share_memory
		
		Examples
		--------
		>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
		False
	**/
	static public function shares_memory(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Display a figure.
		
		When running in ipython with its pylab mode, display all
		figures and return to the ipython prompt.
		
		In non-interactive mode, display all figures and block until
		the figures have been closed; in interactive mode it has no
		effect unless figures were created prior to a change from
		non-interactive to interactive mode (not recommended).  In
		that case it displays the figures but does not block.
		
		A single experimental keyword argument, *block*, may be
		set to True or False to override the blocking behavior
		described above.
	**/
	static public function show(?args:python.VarArgs<Dynamic>, ?kw:python.KwArgs<Dynamic>):Dynamic;
	static public function show_config():Dynamic;
	/**
		shuffle(x)
		
		Modify a sequence in-place by shuffling its contents.
		
		This function only shuffles the array along the first axis of a
		multi-dimensional array. The order of sub-arrays is changed but
		their contents remains the same.
		
		Parameters
		----------
		x : array_like
		    The array or list to be shuffled.
		
		Returns
		-------
		None
		
		Examples
		--------
		>>> arr = np.arange(10)
		>>> np.random.shuffle(arr)
		>>> arr
		[1 7 5 2 9 4 3 6 0 8]
		
		Multi-dimensional arrays are only shuffled along the first axis:
		
		>>> arr = np.arange(9).reshape((3, 3))
		>>> np.random.shuffle(arr)
		>>> arr
		array([[3, 4, 5],
		       [6, 7, 8],
		       [0, 1, 2]])
	**/
	static public function shuffle(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns an element-wise indication of the sign of a number.
		
		The `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.  nan
		is returned for nan inputs.
		
		For complex inputs, the `sign` function returns
		``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.
		
		complex(nan, 0) is returned for complex nan inputs.
		
		Parameters
		----------
		x : array_like
		    Input values.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The sign of `x`.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		There is more than one definition of sign in common use for complex
		numbers.  The definition used here is equivalent to :math:`x/\sqrt{x*x}`
		which is different from a common alternative, :math:`x/|x|`.
		
		Examples
		--------
		>>> np.sign([-5., 4.5])
		array([-1.,  1.])
		>>> np.sign(0)
		0
		>>> np.sign(5-2j)
		(1+0j)
	**/
	static public function sign(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns element-wise True where signbit is set (less than zero).
		
		Parameters
		----------
		x : array_like
		    The input value(s).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		result : ndarray of bool
		    Output array, or reference to `out` if that was supplied.
		    This is a scalar if `x` is a scalar.
		
		Examples
		--------
		>>> np.signbit(-1.2)
		True
		>>> np.signbit(np.array([1, -2.3, 2.1]))
		array([False,  True, False])
	**/
	static public function signbit(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Trigonometric sine, element-wise.
		
		Parameters
		----------
		x : array_like
		    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : array_like
		    The sine of each element of x.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		arcsin, sinh, cos
		
		Notes
		-----
		The sine is one of the fundamental functions of trigonometry (the
		mathematical study of triangles).  Consider a circle of radius 1
		centered on the origin.  A ray comes in from the :math:`+x` axis, makes
		an angle at the origin (measured counter-clockwise from that axis), and
		departs from the origin.  The :math:`y` coordinate of the outgoing
		ray's intersection with the unit circle is the sine of that angle.  It
		ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The
		function has zeroes where the angle is a multiple of :math:`\pi`.
		Sines of angles between :math:`\pi` and :math:`2\pi` are negative.
		The numerous properties of the sine and related functions are included
		in any standard trigonometry text.
		
		Examples
		--------
		Print sine of one angle:
		
		>>> np.sin(np.pi/2.)
		1.0
		
		Print sines of an array of angles given in degrees:
		
		>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
		array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])
		
		Plot the sine function:
		
		>>> import matplotlib.pylab as plt
		>>> x = np.linspace(-np.pi, np.pi, 201)
		>>> plt.plot(x, np.sin(x))
		>>> plt.xlabel('Angle [rad]')
		>>> plt.ylabel('sin(x)')
		>>> plt.axis('tight')
		>>> plt.show()
	**/
	static public function sin(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the sinc function.
		
		The sinc function is :math:`\sin(\pi x)/(\pi x)`.
		
		Parameters
		----------
		x : ndarray
		    Array (possibly multi-dimensional) of values for which to to
		    calculate ``sinc(x)``.
		
		Returns
		-------
		out : ndarray
		    ``sinc(x)``, which has the same shape as the input.
		
		Notes
		-----
		``sinc(0)`` is the limit value 1.
		
		The name sinc is short for "sine cardinal" or "sinus cardinalis".
		
		The sinc function is used in various signal processing applications,
		including in anti-aliasing, in the construction of a Lanczos resampling
		filter, and in interpolation.
		
		For bandlimited interpolation of discrete-time signals, the ideal
		interpolation kernel is proportional to the sinc function.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
		       Resource. http://mathworld.wolfram.com/SincFunction.html
		.. [2] Wikipedia, "Sinc function",
		       https://en.wikipedia.org/wiki/Sinc_function
		
		Examples
		--------
		>>> import matplotlib.pyplot as plt
		>>> x = np.linspace(-4, 4, 41)
		>>> np.sinc(x)
		array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
		        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
		         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
		         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
		        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
		         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
		         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
		         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
		         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
		        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
		        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
		         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
		        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
		        -4.92362781e-02,  -3.89804309e-17])
		
		>>> plt.plot(x, np.sinc(x))
		[<matplotlib.lines.Line2D object at 0x...>]
		>>> plt.title("Sinc Function")
		<matplotlib.text.Text object at 0x...>
		>>> plt.ylabel("Amplitude")
		<matplotlib.text.Text object at 0x...>
		>>> plt.xlabel("X")
		<matplotlib.text.Text object at 0x...>
		>>> plt.show()
		
		It works in 2-D as well:
		
		>>> x = np.linspace(-4, 4, 401)
		>>> xx = np.outer(x, x)
		>>> plt.imshow(np.sinc(xx))
		<matplotlib.image.AxesImage object at 0x...>
	**/
	static public function sinc(x:Dynamic):Dynamic;
	/**
		sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Hyperbolic sine, element-wise.
		
		Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
		``-1j * np.sin(1j*x)``.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding hyperbolic sine values.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		If `out` is provided, the function writes the result into it,
		and returns a reference to `out`.  (See Examples)
		
		References
		----------
		M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
		New York, NY: Dover, 1972, pg. 83.
		
		Examples
		--------
		>>> np.sinh(0)
		0.0
		>>> np.sinh(np.pi*1j/2)
		1j
		>>> np.sinh(np.pi*1j) # (exact value is 0)
		1.2246063538223773e-016j
		>>> # Discrepancy due to vagaries of floating point arithmetic.
		
		>>> # Example of providing the optional output parameter
		>>> out2 = np.sinh([0.1], out1)
		>>> out2 is out1
		True
		
		>>> # Example of ValueError due to provision of shape mis-matched `out`
		>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
	**/
	static public function sinh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return the number of elements along a given axis.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : int, optional
		    Axis along which the elements are counted.  By default, give
		    the total number of elements.
		
		Returns
		-------
		element_count : int
		    Number of elements along the specified axis.
		
		See Also
		--------
		shape : dimensions of array
		ndarray.shape : dimensions of array
		ndarray.size : number of elements in array
		
		Examples
		--------
		>>> a = np.array([[1,2,3],[4,5,6]])
		>>> np.size(a)
		6
		>>> np.size(a,1)
		3
		>>> np.size(a,0)
		2
	**/
	static public function size(a:Dynamic, ?axis:Dynamic):Int;
	/**
		Compute the sign and (natural) logarithm of the determinant of an array.
		
		If an array has a very small or very large determinant, then a call to
		`det` may overflow or underflow. This routine is more robust against such
		issues, because it computes the logarithm of the determinant rather than
		the determinant itself.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Input array, has to be a square 2-D array.
		
		Returns
		-------
		sign : (...) array_like
		    A number representing the sign of the determinant. For a real matrix,
		    this is 1, 0, or -1. For a complex matrix, this is a complex number
		    with absolute value 1 (i.e., it is on the unit circle), or else 0.
		logdet : (...) array_like
		    The natural log of the absolute value of the determinant.
		
		If the determinant is zero, then `sign` will be 0 and `logdet` will be
		-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.
		
		See Also
		--------
		det
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		.. versionadded:: 1.6.0
		
		The determinant is computed via LU factorization using the LAPACK
		routine z/dgetrf.
		
		
		Examples
		--------
		The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:
		
		>>> a = np.array([[1, 2], [3, 4]])
		>>> (sign, logdet) = np.linalg.slogdet(a)
		>>> (sign, logdet)
		(-1, 0.69314718055994529)
		>>> sign * np.exp(logdet)
		-2.0
		
		Computing log-determinants for a stack of matrices:
		
		>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
		>>> a.shape
		(3, 2, 2)
		>>> sign, logdet = np.linalg.slogdet(a)
		>>> (sign, logdet)
		(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
		>>> sign * np.exp(logdet)
		array([-2., -3., -8.])
		
		This routine succeeds where ordinary `det` does not:
		
		>>> np.linalg.det(np.eye(500) * 0.1)
		0.0
		>>> np.linalg.slogdet(np.eye(500) * 0.1)
		(1, -1151.2925464970228)
	**/
	static public function slogdet(a:Dynamic):Dynamic;
	/**
		Solve a linear matrix equation, or system of linear scalar equations.
		
		Computes the "exact" solution, `x`, of the well-determined, i.e., full
		rank, linear matrix equation `ax = b`.
		
		Parameters
		----------
		a : (..., M, M) array_like
		    Coefficient matrix.
		b : {(..., M,), (..., M, K)}, array_like
		    Ordinate or "dependent variable" values.
		
		Returns
		-------
		x : {(..., M,), (..., M, K)} ndarray
		    Solution to the system a x = b.  Returned shape is identical to `b`.
		
		Raises
		------
		LinAlgError
		    If `a` is singular or not square.
		
		Notes
		-----
		
		.. versionadded:: 1.8.0
		
		Broadcasting rules apply, see the `numpy.linalg` documentation for
		details.
		
		The solutions are computed using LAPACK routine _gesv
		
		`a` must be square and of full-rank, i.e., all rows (or, equivalently,
		columns) must be linearly independent; if either is not true, use
		`lstsq` for the least-squares best "solution" of the
		system/equation.
		
		References
		----------
		.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
		       FL, Academic Press, Inc., 1980, pg. 22.
		
		Examples
		--------
		Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:
		
		>>> a = np.array([[3,1], [1,2]])
		>>> b = np.array([9,8])
		>>> x = np.linalg.solve(a, b)
		>>> x
		array([ 2.,  3.])
		
		Check that the solution is correct:
		
		>>> np.allclose(np.dot(a, x), b)
		True
	**/
	static public function solve(a:Dynamic, b:Dynamic):Dynamic;
	/**
		Check whether some values are true.
		
		Refer to `any` for full documentation.
		
		See Also
		--------
		any : equivalent function; see for details.
	**/
	static public function sometrue(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return a sorted copy of an array.
		
		Parameters
		----------
		a : array_like
		    Array to be sorted.
		axis : int or None, optional
		    Axis along which to sort. If None, the array is flattened before
		    sorting. The default is -1, which sorts along the last axis.
		kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
		    Sorting algorithm. Default is 'quicksort'.
		order : str or list of str, optional
		    When `a` is an array with fields defined, this argument specifies
		    which fields to compare first, second, etc.  A single field can
		    be specified as a string, and not all fields need be specified,
		    but unspecified fields will still be used, in the order in which
		    they come up in the dtype, to break ties.
		
		Returns
		-------
		sorted_array : ndarray
		    Array of the same type and shape as `a`.
		
		See Also
		--------
		ndarray.sort : Method to sort an array in-place.
		argsort : Indirect sort.
		lexsort : Indirect stable sort on multiple keys.
		searchsorted : Find elements in a sorted array.
		partition : Partial sort.
		
		Notes
		-----
		The various sorting algorithms are characterized by their average speed,
		worst case performance, work space size, and whether they are stable. A
		stable sort keeps items with the same key in the same relative
		order. The three available algorithms have the following
		properties:
		
		=========== ======= ============= ============ ========
		   kind      speed   worst case    work space   stable
		=========== ======= ============= ============ ========
		'quicksort'    1     O(n^2)            0          no
		'mergesort'    2     O(n*log(n))      ~n/2        yes
		'heapsort'     3     O(n*log(n))       0          no
		=========== ======= ============= ============ ========
		
		All the sort algorithms make temporary copies of the data when
		sorting along any but the last axis.  Consequently, sorting along
		the last axis is faster and uses less space than sorting along
		any other axis.
		
		The sort order for complex numbers is lexicographic. If both the real
		and imaginary parts are non-nan then the order is determined by the
		real parts except when they are equal, in which case the order is
		determined by the imaginary parts.
		
		Previous to numpy 1.4.0 sorting real and complex arrays containing nan
		values led to undefined behaviour. In numpy versions >= 1.4.0 nan
		values are sorted to the end. The extended sort order is:
		
		  * Real: [R, nan]
		  * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
		
		where R is a non-nan real value. Complex values with the same nan
		placements are sorted according to the non-nan part if it exists.
		Non-nan values are sorted as before.
		
		.. versionadded:: 1.12.0
		
		quicksort has been changed to an introsort which will switch
		heapsort when it does not make enough progress. This makes its
		worst case O(n*log(n)).
		
		'stable' automatically choses the best stable sorting algorithm
		for the data type being sorted. It is currently mapped to
		merge sort.
		
		Examples
		--------
		>>> a = np.array([[1,4],[3,1]])
		>>> np.sort(a)                # sort along the last axis
		array([[1, 4],
		       [1, 3]])
		>>> np.sort(a, axis=None)     # sort the flattened array
		array([1, 1, 3, 4])
		>>> np.sort(a, axis=0)        # sort along the first axis
		array([[1, 1],
		       [3, 4]])
		
		Use the `order` keyword to specify a field to use when sorting a
		structured array:
		
		>>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
		>>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
		...           ('Galahad', 1.7, 38)]
		>>> a = np.array(values, dtype=dtype)       # create a structured array
		>>> np.sort(a, order='height')                        # doctest: +SKIP
		array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
		       ('Lancelot', 1.8999999999999999, 38)],
		      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
		
		Sort by age, then height if ages are equal:
		
		>>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
		array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
		       ('Arthur', 1.8, 41)],
		      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
	**/
	static public function sort(a:Dynamic, ?axis:Dynamic, ?kind:Dynamic, ?order:Dynamic):Dynamic;
	/**
		Sort a complex array using the real part first, then the imaginary part.
		
		Parameters
		----------
		a : array_like
		    Input array
		
		Returns
		-------
		out : complex ndarray
		    Always returns a sorted complex array.
		
		Examples
		--------
		>>> np.sort_complex([5, 3, 6, 2, 1])
		array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])
		
		>>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
		array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])
	**/
	static public function sort_complex(a:Dynamic):Dynamic;
	/**
		Print or write to a file the source code for a NumPy object.
		
		The source code is only returned for objects written in Python. Many
		functions and classes are defined in C and will therefore not return
		useful information.
		
		Parameters
		----------
		object : numpy object
		    Input object. This can be any object (function, class, module,
		    ...).
		output : file object, optional
		    If `output` not supplied then source code is printed to screen
		    (sys.stdout).  File object must be created with either write 'w' or
		    append 'a' modes.
		
		See Also
		--------
		lookfor, info
		
		Examples
		--------
		>>> np.source(np.interp)                        #doctest: +SKIP
		In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
		def interp(x, xp, fp, left=None, right=None):
		    """.... (full docstring printed)"""
		    if isinstance(x, (float, int, number)):
		        return compiled_interp([x], xp, fp, left, right).item()
		    else:
		        return compiled_interp(x, xp, fp, left, right)
		
		The source code is only returned for objects written in Python.
		
		>>> np.source(np.array)                         #doctest: +SKIP
		Not available for this object.
	**/
	static public function source(object:Dynamic, ?output:Dynamic):Dynamic;
	/**
		spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the distance between x and the nearest adjacent number.
		
		Parameters
		----------
		x : array_like
		    Values to find the spacing of.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    The spacing of values of `x`.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		It can be considered as a generalization of EPS:
		``spacing(np.float64(1)) == np.finfo(np.float64).eps``, and there
		should not be any representable number between ``x + spacing(x)`` and
		x for any finite x.
		
		Spacing of +- inf and NaN is NaN.
		
		Examples
		--------
		>>> np.spacing(1) == np.finfo(np.float64).eps
		True
	**/
	static public function spacing(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Plot a spectrogram.
		
		Compute and plot a spectrogram of data in *x*.  Data are split into
		*NFFT* length segments and the spectrum of each section is
		computed.  The windowing function *window* is applied to each
		segment, and the amount of overlap of each segment is
		specified with *noverlap*. The spectrogram is plotted as a colormap
		(using imshow).
		
		Parameters
		----------
		x : 1-D array or sequence
		    Array or sequence containing the data.
		
		Fs : scalar
		    The sampling frequency (samples per time unit).  It is used
		    to calculate the Fourier frequencies, freqs, in cycles per time
		    unit. The default value is 2.
		
		window : callable or ndarray
		    A function or a vector of length *NFFT*.  To create window vectors see
		    `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,
		    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The
		    default is `window_hanning`.  If a function is passed as the argument,
		    it must take a data segment as an argument and return the windowed
		    version of the segment.
		
		sides : {'default', 'onesided', 'twosided'}
		    Specifies which sides of the spectrum to return.  Default gives the
		    default behavior, which returns one-sided for real data and both
		    for complex data.  'onesided' forces the return of a one-sided
		    spectrum, while 'twosided' forces two-sided.
		
		pad_to : int
		    The number of points to which the data segment is padded when
		    performing the FFT.  This can be different from *NFFT*, which
		    specifies the number of data points used.  While not increasing
		    the actual resolution of the spectrum (the minimum distance between
		    resolvable peaks), this can give more points in the plot,
		    allowing for more detail. This corresponds to the *n* parameter
		    in the call to fft(). The default is None, which sets *pad_to*
		    equal to *NFFT*
		
		NFFT : int
		    The number of data points used in each block for the FFT.
		    A power 2 is most efficient.  The default value is 256.
		    This should *NOT* be used to get zero padding, or the scaling of the
		    result will be incorrect. Use *pad_to* for this instead.
		
		detrend : {'none', 'mean', 'linear'} or callable, default 'none'
		    The function applied to each segment before fft-ing, designed to
		    remove the mean or linear trend.  Unlike in MATLAB, where the
		    *detrend* parameter is a vector, in Matplotlib is it a function.
		    The :mod:`~matplotlib.mlab` module defines `.detrend_none`,
		    `.detrend_mean`, and `.detrend_linear`, but you can use a custom
		    function as well.  You can also use a string to choose one of the
		    functions: 'none' calls `.detrend_none`. 'mean' calls `.detrend_mean`.
		    'linear' calls `.detrend_linear`.
		
		scale_by_freq : bool, optional
		    Specifies whether the resulting density values should be scaled
		    by the scaling frequency, which gives density in units of Hz^-1.
		    This allows for integration over the returned frequency values.
		    The default is True for MATLAB compatibility.
		
		mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
		    What sort of spectrum to use.  Default is 'psd', which takes the
		    power spectral density.  'magnitude' returns the magnitude
		    spectrum.  'angle' returns the phase spectrum without unwrapping.
		    'phase' returns the phase spectrum with unwrapping.
		
		noverlap : int
		    The number of points of overlap between blocks.  The
		    default value is 128.
		
		scale : {'default', 'linear', 'dB'}
		    The scaling of the values in the *spec*.  'linear' is no scaling.
		    'dB' returns the values in dB scale.  When *mode* is 'psd',
		    this is dB power (10 * log10).  Otherwise this is dB amplitude
		    (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
		    'magnitude' and 'linear' otherwise.  This must be 'linear'
		    if *mode* is 'angle' or 'phase'.
		
		Fc : int
		    The center frequency of *x* (defaults to 0), which offsets
		    the x extents of the plot to reflect the frequency range used
		    when a signal is acquired and then filtered and downsampled to
		    baseband.
		
		cmap
		    A :class:`matplotlib.colors.Colormap` instance; if *None*, use
		    default determined by rc
		
		xextent : *None* or (xmin, xmax)
		    The image extent along the x-axis. The default sets *xmin* to the
		    left border of the first bin (*spectrum* column) and *xmax* to the
		    right border of the last bin. Note that for *noverlap>0* the width
		    of the bins is smaller than those of the segments.
		
		**kwargs
		    Additional kwargs are passed on to imshow which makes the
		    specgram image.
		
		Returns
		-------
		spectrum : 2-D array
		    Columns are the periodograms of successive segments.
		
		freqs : 1-D array
		    The frequencies corresponding to the rows in *spectrum*.
		
		t : 1-D array
		    The times corresponding to midpoints of segments (i.e., the columns
		    in *spectrum*).
		
		im : instance of class :class:`~matplotlib.image.AxesImage`
		    The image created by imshow containing the spectrogram
		
		See Also
		--------
		:func:`psd`
		    :func:`psd` differs in the default overlap; in returning the mean
		    of the segment periodograms; in not returning times; and in
		    generating a line plot instead of colormap.
		
		:func:`magnitude_spectrum`
		    A single spectrum, similar to having a single segment when *mode*
		    is 'magnitude'. Plots a line instead of a colormap.
		
		:func:`angle_spectrum`
		    A single spectrum, similar to having a single segment when *mode*
		    is 'angle'. Plots a line instead of a colormap.
		
		:func:`phase_spectrum`
		    A single spectrum, similar to having a single segment when *mode*
		    is 'phase'. Plots a line instead of a colormap.
		
		Notes
		-----
		The parameters *detrend* and *scale_by_freq* do only apply when *mode*
		is set to 'psd'.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function specgram(x:Dynamic, ?NFFT:Dynamic, ?Fs:Dynamic, ?Fc:Dynamic, ?detrend:Dynamic, ?window:Dynamic, ?noverlap:Dynamic, ?cmap:Dynamic, ?xextent:Dynamic, ?pad_to:Dynamic, ?sides:Dynamic, ?scale_by_freq:Dynamic, ?mode:Dynamic, ?scale:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Split an array into multiple sub-arrays.
		
		Parameters
		----------
		ary : ndarray
		    Array to be divided into sub-arrays.
		indices_or_sections : int or 1-D array
		    If `indices_or_sections` is an integer, N, the array will be divided
		    into N equal arrays along `axis`.  If such a split is not possible,
		    an error is raised.
		
		    If `indices_or_sections` is a 1-D array of sorted integers, the entries
		    indicate where along `axis` the array is split.  For example,
		    ``[2, 3]`` would, for ``axis=0``, result in
		
		      - ary[:2]
		      - ary[2:3]
		      - ary[3:]
		
		    If an index exceeds the dimension of the array along `axis`,
		    an empty sub-array is returned correspondingly.
		axis : int, optional
		    The axis along which to split, default is 0.
		
		Returns
		-------
		sub-arrays : list of ndarrays
		    A list of sub-arrays.
		
		Raises
		------
		ValueError
		    If `indices_or_sections` is given as an integer, but
		    a split does not result in equal division.
		
		See Also
		--------
		array_split : Split an array into multiple sub-arrays of equal or
		              near-equal size.  Does not raise an exception if
		              an equal division cannot be made.
		hsplit : Split array into multiple sub-arrays horizontally (column-wise).
		vsplit : Split array into multiple sub-arrays vertically (row wise).
		dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
		concatenate : Join a sequence of arrays along an existing axis.
		stack : Join a sequence of arrays along a new axis.
		hstack : Stack arrays in sequence horizontally (column wise).
		vstack : Stack arrays in sequence vertically (row wise).
		dstack : Stack arrays in sequence depth wise (along third dimension).
		
		Examples
		--------
		>>> x = np.arange(9.0)
		>>> np.split(x, 3)
		[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]
		
		>>> x = np.arange(8.0)
		>>> np.split(x, [3, 5, 6, 10])
		[array([ 0.,  1.,  2.]),
		 array([ 3.,  4.]),
		 array([ 5.]),
		 array([ 6.,  7.]),
		 array([], dtype=float64)]
	**/
	static public function split(ary:Dynamic, indices_or_sections:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Set the colormap to "spring".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function spring():Dynamic;
	/**
		Plot the sparsity pattern of a 2D array.
		
		This visualizes the non-zero values of the array.
		
		Two plotting styles are available: image and marker. Both
		are available for full arrays, but only the marker style
		works for `scipy.sparse.spmatrix` instances.
		
		**Image style**
		
		If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
		extra remaining kwargs are passed to this method.
		
		**Marker style**
		
		If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
		*None*, a `~matplotlib.lines.Line2D` object will be returned with
		the value of marker determining the marker type, and any
		remaining kwargs passed to `~.Axes.plot`.
		
		Parameters
		----------
		Z : array-like (M, N)
		    The array to be plotted.
		
		precision : float or 'present', optional, default: 0
		    If *precision* is 0, any non-zero value will be plotted. Otherwise,
		    values of :math:`|Z| > precision` will be plotted.
		
		    For :class:`scipy.sparse.spmatrix` instances, you can also
		    pass 'present'. In this case any value present in the array
		    will be plotted, even if it is identically zero.
		
		origin : {'upper', 'lower'}, optional
		    Place the [0,0] index of the array in the upper left or lower left
		    corner of the axes. The convention 'upper' is typically used for
		    matrices and images.
		    If not given, :rc:`image.origin` is used, defaulting to 'upper'.
		
		
		aspect : {'equal', 'auto', None} or float, optional
		    Controls the aspect ratio of the axes. The aspect is of particular
		    relevance for images since it may distort the image, i.e. pixel
		    will not be square.
		
		    This parameter is a shortcut for explicitly calling
		    `.Axes.set_aspect`. See there for further details.
		
		    - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
		    - 'auto': The axes is kept fixed and the aspect is adjusted so
		      that the data fit in the axes. In general, this will result in
		      non-square pixels.
		    - *None*: Use :rc:`image.aspect` (default: 'equal').
		
		    Default: 'equal'
		
		Returns
		-------
		ret : `~matplotlib.image.AxesImage` or `.Line2D`
		    The return type depends on the plotting style (see above).
		
		Other Parameters
		----------------
		**kwargs
		    The supported additional parameters depend on the plotting style.
		
		    For the image style, you can pass the following additional
		    parameters of `~.Axes.imshow`:
		
		    - *cmap*
		    - *alpha*
		    - *url*
		    - any `.Artist` properties (passed on to the `.AxesImage`)
		
		    For the marker style, you can pass any `.Line2D` property except
		    for *linestyle*:
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  antialiased or aa: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  color or c: color
		  contains: callable
		  dash_capstyle: {'butt', 'round', 'projecting'}
		  dash_joinstyle: {'miter', 'round', 'bevel'}
		  dashes: sequence of floats (on/off ink in points) or (None, None)
		  drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
		  figure: `.Figure`
		  fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
		  gid: str
		  in_layout: bool
		  label: object
		  linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
		  linewidth or lw: float
		  marker: marker style
		  markeredgecolor or mec: color
		  markeredgewidth or mew: float
		  markerfacecolor or mfc: color
		  markerfacecoloralt or mfcalt: color
		  markersize or ms: float
		  markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
		  path_effects: `.AbstractPathEffect`
		  picker: float or callable[[Artist, Event], Tuple[bool, dict]]
		  pickradius: float
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  solid_capstyle: {'butt', 'round', 'projecting'}
		  solid_joinstyle: {'miter', 'round', 'bevel'}
		  transform: `matplotlib.transforms.Transform`
		  url: str
		  visible: bool
		  xdata: 1D array
		  ydata: 1D array
		  zorder: float
	**/
	static public function spy(Z:Dynamic, ?precision:Dynamic, ?marker:Dynamic, ?markersize:Dynamic, ?aspect:Dynamic, ?origin:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the non-negative square-root of an array, element-wise.
		
		Parameters
		----------
		x : array_like
		    The values whose square-roots are required.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    An array of the same shape as `x`, containing the positive
		    square-root of each element in `x`.  If any element in `x` is
		    complex, a complex array is returned (and the square-roots of
		    negative reals are calculated).  If all of the elements in `x`
		    are real, so is `y`, with negative elements returning ``nan``.
		    If `out` was provided, `y` is a reference to it.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		lib.scimath.sqrt
		    A version which returns complex numbers when given negative reals.
		
		Notes
		-----
		*sqrt* has--consistent with common convention--as its branch cut the
		real "interval" [`-inf`, 0), and is continuous from above on it.
		A branch cut is a curve in the complex plane across which a given
		complex function fails to be continuous.
		
		Examples
		--------
		>>> np.sqrt([1,4,9])
		array([ 1.,  2.,  3.])
		
		>>> np.sqrt([4, -1, -3+4J])
		array([ 2.+0.j,  0.+1.j,  1.+2.j])
		
		>>> np.sqrt([4, -1, numpy.inf])
		array([  2.,  NaN,  Inf])
	**/
	static public function sqrt(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the element-wise square of the input.
		
		Parameters
		----------
		x : array_like
		    Input data.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    Element-wise `x*x`, of the same shape and dtype as `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		numpy.linalg.matrix_power
		sqrt
		power
		
		Examples
		--------
		>>> np.square([-1j, 1])
		array([-1.-0.j,  1.+0.j])
	**/
	static public function square(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Remove single-dimensional entries from the shape of an array.
		
		Parameters
		----------
		a : array_like
		    Input data.
		axis : None or int or tuple of ints, optional
		    .. versionadded:: 1.7.0
		
		    Selects a subset of the single-dimensional entries in the
		    shape. If an axis is selected with shape entry greater than
		    one, an error is raised.
		
		Returns
		-------
		squeezed : ndarray
		    The input array, but with all or a subset of the
		    dimensions of length 1 removed. This is always `a` itself
		    or a view into `a`.
		
		Raises
		------
		ValueError
		    If `axis` is not `None`, and an axis being squeezed is not of length 1
		
		See Also
		--------
		expand_dims : The inverse operation, adding singleton dimensions
		reshape : Insert, remove, and combine dimensions, and resize existing ones
		
		Examples
		--------
		>>> x = np.array([[[0], [1], [2]]])
		>>> x.shape
		(1, 3, 1)
		>>> np.squeeze(x).shape
		(3,)
		>>> np.squeeze(x, axis=0).shape
		(3, 1)
		>>> np.squeeze(x, axis=1).shape
		Traceback (most recent call last):
		...
		ValueError: cannot select an axis to squeeze out which has size not equal to one
		>>> np.squeeze(x, axis=2).shape
		(1, 3)
	**/
	static public function squeeze(a:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Join a sequence of arrays along a new axis.
		
		The `axis` parameter specifies the index of the new axis in the dimensions
		of the result. For example, if ``axis=0`` it will be the first dimension
		and if ``axis=-1`` it will be the last dimension.
		
		.. versionadded:: 1.10.0
		
		Parameters
		----------
		arrays : sequence of array_like
		    Each array must have the same shape.
		axis : int, optional
		    The axis in the result array along which the input arrays are stacked.
		out : ndarray, optional
		    If provided, the destination to place the result. The shape must be
		    correct, matching that of what stack would have returned if no
		    out argument were specified.
		
		Returns
		-------
		stacked : ndarray
		    The stacked array has one more dimension than the input arrays.
		
		See Also
		--------
		concatenate : Join a sequence of arrays along an existing axis.
		split : Split array into a list of multiple sub-arrays of equal size.
		block : Assemble arrays from blocks.
		
		Examples
		--------
		>>> arrays = [np.random.randn(3, 4) for _ in range(10)]
		>>> np.stack(arrays, axis=0).shape
		(10, 3, 4)
		
		>>> np.stack(arrays, axis=1).shape
		(3, 10, 4)
		
		>>> np.stack(arrays, axis=2).shape
		(3, 4, 10)
		
		>>> a = np.array([1, 2, 3])
		>>> b = np.array([2, 3, 4])
		>>> np.stack((a, b))
		array([[1, 2, 3],
		       [2, 3, 4]])
		
		>>> np.stack((a, b), axis=-1)
		array([[1, 2],
		       [2, 3],
		       [3, 4]])
	**/
	static public function stack(arrays:Dynamic, ?axis:Dynamic, ?out:Dynamic):Dynamic;
	/**
		Draw a stacked area plot.
		
		Parameters
		----------
		x : 1d array of dimension N
		
		y : 2d array (dimension MxN), or sequence of 1d arrays (each dimension 1xN)
		
		    The data is assumed to be unstacked. Each of the following
		    calls is legal::
		
		        stackplot(x, y)               # where y is MxN
		        stackplot(x, y1, y2, y3, y4)  # where y1, y2, y3, y4, are all 1xNm
		
		baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}
		    Method used to calculate the baseline:
		
		    - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.
		    - ``'sym'``:  Symmetric around zero and is sometimes called
		      'ThemeRiver'.
		    - ``'wiggle'``: Minimizes the sum of the squared slopes.
		    - ``'weighted_wiggle'``: Does the same but weights to account for
		      size of each layer. It is also called 'Streamgraph'-layout. More
		      details can be found at http://leebyron.com/streamgraph/.
		
		labels : Length N sequence of strings
		    Labels to assign to each data series.
		
		colors : Length N sequence of colors
		    A list or tuple of colors. These will be cycled through and used to
		    colour the stacked areas.
		
		**kwargs
		    All other keyword arguments are passed to `Axes.fill_between()`.
		
		
		Returns
		-------
		list : list of `.PolyCollection`
		    A list of `.PolyCollection` instances, one for each element in the
		    stacked area plot.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function stackplot(x:Dynamic, ?args:python.VarArgs<Dynamic>, ?labels:Dynamic, ?colors:Dynamic, ?baseline:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		standard_cauchy(size=None)
		
		Draw samples from a standard Cauchy distribution with mode = 0.
		
		Also known as the Lorentz distribution.
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		samples : ndarray or scalar
		    The drawn samples.
		
		Notes
		-----
		The probability density function for the full Cauchy distribution is
		
		.. math:: P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
		          (\frac{x-x_0}{\gamma})^2 \bigr] }
		
		and the Standard Cauchy distribution just sets :math:`x_0=0` and
		:math:`\gamma=1`
		
		The Cauchy distribution arises in the solution to the driven harmonic
		oscillator problem, and also describes spectral line broadening. It
		also describes the distribution of values at which a line tilted at
		a random angle will cut the x axis.
		
		When studying hypothesis tests that assume normality, seeing how the
		tests perform on data from a Cauchy distribution is a good indicator of
		their sensitivity to a heavy-tailed distribution, since the Cauchy looks
		very much like a Gaussian distribution, but with heavier tails.
		
		References
		----------
		.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, "Cauchy
		      Distribution",
		      https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm
		.. [2] Weisstein, Eric W. "Cauchy Distribution." From MathWorld--A
		      Wolfram Web Resource.
		      http://mathworld.wolfram.com/CauchyDistribution.html
		.. [3] Wikipedia, "Cauchy distribution"
		      https://en.wikipedia.org/wiki/Cauchy_distribution
		
		Examples
		--------
		Draw samples and plot the distribution:
		
		>>> import matplotlib.pyplot as plt
		>>> s = np.random.standard_cauchy(1000000)
		>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
		>>> plt.hist(s, bins=100)
		>>> plt.show()
	**/
	static public function standard_cauchy(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		standard_exponential(size=None)
		
		Draw samples from the standard exponential distribution.
		
		`standard_exponential` is identical to the exponential distribution
		with a scale parameter of 1.
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray
		    Drawn samples.
		
		Examples
		--------
		Output a 3x8000 array:
		
		>>> n = np.random.standard_exponential((3, 8000))
	**/
	static public function standard_exponential(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		standard_gamma(shape, size=None)
		
		Draw samples from a standard Gamma distribution.
		
		Samples are drawn from a Gamma distribution with specified parameters,
		shape (sometimes designated "k") and scale=1.
		
		Parameters
		----------
		shape : float or array_like of floats
		    Parameter, should be > 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``shape`` is a scalar.  Otherwise,
		    ``np.array(shape).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized standard gamma distribution.
		
		See Also
		--------
		scipy.stats.gamma : probability density function, distribution or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Gamma distribution is
		
		.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},
		
		where :math:`k` is the shape and :math:`\theta` the scale,
		and :math:`\Gamma` is the Gamma function.
		
		The Gamma distribution is often used to model the times to failure of
		electronic components, and arises naturally in processes for which the
		waiting times between Poisson distributed events are relevant.
		
		References
		----------
		.. [1] Weisstein, Eric W. "Gamma Distribution." From MathWorld--A
		       Wolfram Web Resource.
		       http://mathworld.wolfram.com/GammaDistribution.html
		.. [2] Wikipedia, "Gamma distribution",
		       https://en.wikipedia.org/wiki/Gamma_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> shape, scale = 2., 1. # mean and width
		>>> s = np.random.standard_gamma(shape, 1000000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> import scipy.special as sps
		>>> count, bins, ignored = plt.hist(s, 50, density=True)
		>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/ \
		...                       (sps.gamma(shape) * scale**shape))
		>>> plt.plot(bins, y, linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function standard_gamma(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		standard_normal(size=None)
		
		Draw samples from a standard Normal distribution (mean=0, stdev=1).
		
		Parameters
		----------
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  Default is None, in which case a
		    single value is returned.
		
		Returns
		-------
		out : float or ndarray
		    Drawn samples.
		
		Examples
		--------
		>>> s = np.random.standard_normal(8000)
		>>> s
		array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random
		       -0.38672696, -0.4685006 ])                               #random
		>>> s.shape
		(8000,)
		>>> s = np.random.standard_normal(size=(3, 4, 2))
		>>> s.shape
		(3, 4, 2)
	**/
	static public function standard_normal(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		standard_t(df, size=None)
		
		Draw samples from a standard Student's t distribution with `df` degrees
		of freedom.
		
		A special case of the hyperbolic distribution.  As `df` gets
		large, the result resembles that of the standard normal
		distribution (`standard_normal`).
		
		Parameters
		----------
		df : float or array_like of floats
		    Degrees of freedom, should be > 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``df`` is a scalar.  Otherwise,
		    ``np.array(df).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized standard Student's t distribution.
		
		Notes
		-----
		The probability density function for the t distribution is
		
		.. math:: P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
		          \Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}
		
		The t test is based on an assumption that the data come from a
		Normal distribution. The t test provides a way to test whether
		the sample mean (that is the mean calculated from the data) is
		a good estimate of the true mean.
		
		The derivation of the t-distribution was first published in
		1908 by William Gosset while working for the Guinness Brewery
		in Dublin. Due to proprietary issues, he had to publish under
		a pseudonym, and so he used the name Student.
		
		References
		----------
		.. [1] Dalgaard, Peter, "Introductory Statistics With R",
		       Springer, 2002.
		.. [2] Wikipedia, "Student's t-distribution"
		       https://en.wikipedia.org/wiki/Student's_t-distribution
		
		Examples
		--------
		From Dalgaard page 83 [1]_, suppose the daily energy intake for 11
		women in kilojoules (kJ) is:
		
		>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
		...                    7515, 8230, 8770])
		
		Does their energy intake deviate systematically from the recommended
		value of 7725 kJ?
		
		We have 10 degrees of freedom, so is the sample mean within 95% of the
		recommended value?
		
		>>> s = np.random.standard_t(10, size=100000)
		>>> np.mean(intake)
		6753.636363636364
		>>> intake.std(ddof=1)
		1142.1232221373727
		
		Calculate the t statistic, setting the ddof parameter to the unbiased
		value so the divisor in the standard deviation will be degrees of
		freedom, N-1.
		
		>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
		>>> import matplotlib.pyplot as plt
		>>> h = plt.hist(s, bins=100, density=True)
		
		For a one-sided t-test, how far out in the distribution does the t
		statistic appear?
		
		>>> np.sum(s<t) / float(len(s))
		0.0090699999999999999  #random
		
		So the p-value is about 0.009, which says the null hypothesis has a
		probability of about 99% of being true.
	**/
	static public function standard_t(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute the standard deviation along the specified axis.
		
		Returns the standard deviation, a measure of the spread of a distribution,
		of the array elements. The standard deviation is computed for the
		flattened array by default, otherwise over the specified axis.
		
		Parameters
		----------
		a : array_like
		    Calculate the standard deviation of these values.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which the standard deviation is computed. The
		    default is to compute the standard deviation of the flattened array.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, a standard deviation is performed over
		    multiple axes, instead of a single axis or all the axes as before.
		dtype : dtype, optional
		    Type to use in computing the standard deviation. For arrays of
		    integer type the default is float64, for arrays of float types it is
		    the same as the array type.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must have
		    the same shape as the expected output but the type (of the calculated
		    values) will be cast if necessary.
		ddof : int, optional
		    Means Delta Degrees of Freedom.  The divisor used in calculations
		    is ``N - ddof``, where ``N`` represents the number of elements.
		    By default `ddof` is zero.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `std` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		standard_deviation : ndarray, see dtype parameter above.
		    If `out` is None, return a new array containing the standard deviation,
		    otherwise return a reference to the output array.
		
		See Also
		--------
		var, mean, nanmean, nanstd, nanvar
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		The standard deviation is the square root of the average of the squared
		deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.
		
		The average squared deviation is normally calculated as
		``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
		the divisor ``N - ddof`` is used instead. In standard statistical
		practice, ``ddof=1`` provides an unbiased estimator of the variance
		of the infinite population. ``ddof=0`` provides a maximum likelihood
		estimate of the variance for normally distributed variables. The
		standard deviation computed in this function is the square root of
		the estimated variance, so even with ``ddof=1``, it will not be an
		unbiased estimate of the standard deviation per se.
		
		Note that, for complex numbers, `std` takes the absolute
		value before squaring, so that the result is always real and nonnegative.
		
		For floating-point input, the *std* is computed using the same
		precision the input has. Depending on the input data, this can cause
		the results to be inaccurate, especially for float32 (see example below).
		Specifying a higher-accuracy accumulator using the `dtype` keyword can
		alleviate this issue.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, 4]])
		>>> np.std(a)
		1.1180339887498949
		>>> np.std(a, axis=0)
		array([ 1.,  1.])
		>>> np.std(a, axis=1)
		array([ 0.5,  0.5])
		
		In single precision, std() can be inaccurate:
		
		>>> a = np.zeros((2, 512*512), dtype=np.float32)
		>>> a[0, :] = 1.0
		>>> a[1, :] = 0.1
		>>> np.std(a)
		0.45000005
		
		Computing the standard deviation in float64 is more accurate:
		
		>>> np.std(a, dtype=np.float64)
		0.44999999925494177
	**/
	static public function std(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?ddof:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		Create a stem plot.
		
		A stem plot plots vertical lines at each *x* location from the baseline
		to *y*, and places a marker there.
		
		Call signature::
		
		  stem([x,] y, linefmt=None, markerfmt=None, basefmt=None)
		
		The x-positions are optional. The formats may be provided either as
		positional or as keyword-arguments.
		
		Parameters
		----------
		x : array-like, optional
		    The x-positions of the stems. Default: (0, 1, ..., len(y) - 1).
		
		y : array-like
		    The y-values of the stem heads.
		
		linefmt : str, optional
		    A string defining the properties of the vertical lines. Usually,
		    this will be a color or a color and a linestyle:
		
		    =========  =============
		    Character  Line Style
		    =========  =============
		    ``'-'``    solid line
		    ``'--'``   dashed line
		    ``'-.'``   dash-dot line
		    ``':'``    dotted line
		    =========  =============
		
		    Default: 'C0-', i.e. solid line with the first color of the color
		    cycle.
		
		    Note: While it is technically possible to specify valid formats
		    other than color or color and linestyle (e.g. 'rx' or '-.'), this
		    is beyond the intention of the method and will most likely not
		    result in a reasonable reasonable plot.
		
		markerfmt : str, optional
		    A string defining the properties of the markers at the stem heads.
		    Default: 'C0o', i.e. filled circles with the first color of the
		    color cycle.
		
		basefmt : str, optional
		    A format string defining the properties of the baseline.
		
		    Default: 'C3-' ('C2-' in classic mode).
		
		bottom : float, optional, default: 0
		    The y-position of the baseline.
		
		label : str, optional, default: None
		    The label to use for the stems in legends.
		
		use_line_collection : bool, optional, default: False
		    If ``True``, store and plot the stem lines as a
		    `~.collections.LineCollection` instead of individual lines. This
		    significantly increases performance, and will become the default
		    option in Matplotlib 3.3. If ``False``, defaults to the old
		    behavior of using a list of `.Line2D` objects.
		
		
		Returns
		-------
		container : :class:`~matplotlib.container.StemContainer`
		    The container may be treated like a tuple
		    (*markerline*, *stemlines*, *baseline*)
		
		
		Notes
		-----
		
		.. seealso::
		    The MATLAB function
		    `stem <http://www.mathworks.com/help/techdoc/ref/stem.html>`_
		    which inspired this method.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All positional and all keyword arguments.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function stem(?args:python.VarArgs<Dynamic>, ?linefmt:Dynamic, ?markerfmt:Dynamic, ?basefmt:Dynamic, ?bottom:Dynamic, ?label:Dynamic, ?use_line_collection:Dynamic, ?data:Dynamic):Dynamic;
	/**
		Make a step plot.
		
		Call signatures::
		
		    step(x, y, [fmt], *, data=None, where='pre', **kwargs)
		    step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
		
		This is just a thin wrapper around `.plot` which changes some
		formatting options. Most of the concepts and parameters of plot can be
		used here as well.
		
		Parameters
		----------
		x : array_like
		    1-D sequence of x positions. It is assumed, but not checked, that
		    it is uniformly increasing.
		
		y : array_like
		    1-D sequence of y levels.
		
		fmt : str, optional
		    A format string, e.g. 'g' for a green line. See `.plot` for a more
		    detailed description.
		
		    Note: While full format strings are accepted, it is recommended to
		    only specify the color. Line styles are currently ignored (use
		    the keyword argument *linestyle* instead). Markers are accepted
		    and plotted on the given positions, however, this is a rarely
		    needed feature for step plots.
		
		data : indexable object, optional
		    An object with labelled data. If given, provide the label names to
		    plot in *x* and *y*.
		
		where : {'pre', 'post', 'mid'}, optional, default 'pre'
		    Define where the steps should be placed:
		
		    - 'pre': The y value is continued constantly to the left from
		      every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
		      value ``y[i]``.
		    - 'post': The y value is continued constantly to the right from
		      every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
		      value ``y[i]``.
		    - 'mid': Steps occur half-way between the *x* positions.
		
		Returns
		-------
		lines
		    A list of `.Line2D` objects representing the plotted data.
		
		Other Parameters
		----------------
		**kwargs
		    Additional parameters are the same as those for `.plot`.
		
		Notes
		-----
		.. [notes section required to get data note injection right]
	**/
	static public function step(x:Dynamic, y:Dynamic, ?args:python.VarArgs<Dynamic>, ?where:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Draw streamlines of a vector flow.
		
		Parameters
		----------
		x, y : 1d arrays
		    An evenly spaced grid.
		u, v : 2d arrays
		    *x* and *y*-velocities. Number of rows should match length of *y*, and
		    the number of columns should match *x*.
		density : float or 2-tuple
		    Controls the closeness of streamlines. When ``density = 1``, the domain
		    is divided into a 30x30 grid---*density* linearly scales this grid.
		    Each cell in the grid can have, at most, one traversing streamline.
		    For different densities in each direction, use [density_x, density_y].
		linewidth : numeric or 2d array
		    Vary linewidth when given a 2d array with the same shape as velocities.
		color : matplotlib color code, or 2d array
		    Streamline color. When given an array with the same shape as
		    velocities, *color* values are converted to colors using *cmap*.
		cmap : `~matplotlib.colors.Colormap`
		    Colormap used to plot streamlines and arrows. Only necessary when using
		    an array input for *color*.
		norm : `~matplotlib.colors.Normalize`
		    Normalize object used to scale luminance data to 0, 1. If ``None``,
		    stretch (min, max) to (0, 1). Only necessary when *color* is an array.
		arrowsize : float
		    Factor scale arrow size.
		arrowstyle : str
		    Arrow style specification.
		    See `~matplotlib.patches.FancyArrowPatch`.
		minlength : float
		    Minimum length of streamline in axes coordinates.
		start_points : Nx2 array
		    Coordinates of starting points for the streamlines.
		    In data coordinates, the same as the *x* and *y* arrays.
		zorder : int
		    Any number.
		maxlength : float
		    Maximum length of streamline in axes coordinates.
		integration_direction : ['forward' | 'backward' | 'both']
		    Integrate the streamline in forward, backward or both directions.
		    default is ``'both'``.
		
		Returns
		-------
		stream_container : StreamplotSet
		    Container object with attributes
		
		    - lines: `matplotlib.collections.LineCollection` of streamlines
		
		    - arrows: collection of `matplotlib.patches.FancyArrowPatch`
		      objects representing arrows half-way along stream
		      lines.
		
		    This container will probably change in the future to allow changes
		    to the colormap, alpha, etc. for both lines and arrows, but these
		    changes should be backward compatible.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'start_points', 'u', 'v', 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function streamplot(x:Dynamic, y:Dynamic, u:Dynamic, v:Dynamic, ?density:Dynamic, ?linewidth:Dynamic, ?color:Dynamic, ?cmap:Dynamic, ?norm:Dynamic, ?arrowsize:Dynamic, ?arrowstyle:Dynamic, ?minlength:Dynamic, ?transform:Dynamic, ?zorder:Dynamic, ?start_points:Dynamic, ?maxlength:Dynamic, ?integration_direction:Dynamic, ?data:Dynamic):Dynamic;
	/**
		Add a subplot to the current figure.
		
		Wrapper of `.Figure.add_subplot` with a difference in behavior
		explained in the notes section.
		
		Call signatures::
		
		   subplot(nrows, ncols, index, **kwargs)
		   subplot(pos, **kwargs)
		   subplot(ax)
		
		Parameters
		----------
		*args
		    Either a 3-digit integer or three separate integers
		    describing the position of the subplot. If the three
		    integers are *nrows*, *ncols*, and *index* in order, the
		    subplot will take the *index* position on a grid with *nrows*
		    rows and *ncols* columns. *index* starts at 1 in the upper left
		    corner and increases to the right.
		
		    *pos* is a three digit integer, where the first digit is the
		    number of rows, the second the number of columns, and the third
		    the index of the subplot. i.e. fig.add_subplot(235) is the same as
		    fig.add_subplot(2, 3, 5). Note that all integers must be less than
		    10 for this form to work.
		
		projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', 'polar', 'rectilinear', str}, optional
		    The projection type of the subplot (`~.axes.Axes`). *str* is the name
		    of a costum projection, see `~matplotlib.projections`. The default
		    None results in a 'rectilinear' projection.
		
		polar : boolean, optional
		    If True, equivalent to projection='polar'.
		
		sharex, sharey : `~.axes.Axes`, optional
		    Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
		    axis will have the same limits, ticks, and scale as the axis of the
		    shared axes.
		
		label : str
		    A label for the returned axes.
		
		Other Parameters
		----------------
		**kwargs
		    This method also takes the keyword arguments for
		    the returned axes base class. The keyword arguments for the
		    rectilinear base class `~.axes.Axes` can be found in
		    the following table but there might also be other keyword
		    arguments if another projection is used.
		      adjustable: {'box', 'datalim'}
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  anchor: 2-tuple of floats or {'C', 'SW', 'S', 'SE', ...}
		  animated: bool
		  aspect: {'auto', 'equal'} or num
		  autoscale_on: bool
		  autoscalex_on: bool
		  autoscaley_on: bool
		  axes_locator: Callable[[Axes, Renderer], Bbox]
		  axisbelow: bool or 'line'
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  contains: callable
		  facecolor: color
		  fc: color
		  figure: `.Figure`
		  frame_on: bool
		  gid: str
		  in_layout: bool
		  label: object
		  navigate: bool
		  navigate_mode: unknown
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  position: [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
		  rasterization_zorder: float or None
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  title: str
		  transform: `.Transform`
		  url: str
		  visible: bool
		  xbound: unknown
		  xlabel: str
		  xlim: (left: float, right: float)
		  xmargin: float greater than -0.5
		  xscale: {"linear", "log", "symlog", "logit", ...}
		  xticklabels: List[str]
		  xticks: list
		  ybound: unknown
		  ylabel: str
		  ylim: (bottom: float, top: float)
		  ymargin: float greater than -0.5
		  yscale: {"linear", "log", "symlog", "logit", ...}
		  yticklabels: List[str]
		  yticks: list
		  zorder: float
		
		Returns
		-------
		axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass     of `~.axes.Axes`)
		
		    The axes of the subplot. The returned axes base class depends on
		    the projection used. It is `~.axes.Axes` if rectilinear projection
		    are used and `.projections.polar.PolarAxes` if polar projection
		    are used. The returned axes is then a subplot subclass of the
		    base class.
		
		Notes
		-----
		Creating a subplot will delete any pre-existing subplot that overlaps
		with it beyond sharing a boundary::
		
		    import matplotlib.pyplot as plt
		    # plot a line, implicitly creating a subplot(111)
		    plt.plot([1,2,3])
		    # now create a subplot which represents the top plot of a grid
		    # with 2 rows and 1 column. Since this subplot will overlap the
		    # first, the plot (and its axes) previously created, will be removed
		    plt.subplot(211)
		
		If you do not want this behavior, use the `.Figure.add_subplot` method
		or the `.pyplot.axes` function instead.
		
		If the figure already has a subplot with key (*args*,
		*kwargs*) then it will simply make that subplot current and
		return it.  This behavior is deprecated. Meanwhile, if you do
		not want this behavior (i.e., you want to force the creation of a
		new subplot), you must use a unique set of args and kwargs.  The axes
		*label* attribute has been exposed for this purpose: if you want
		two subplots that are otherwise identical to be added to the figure,
		make sure you give them unique labels.
		
		In rare circumstances, `.add_subplot` may be called with a single
		argument, a subplot axes instance already created in the
		present figure but not in the figure's list of axes.
		
		See Also
		--------
		.Figure.add_subplot
		.pyplot.subplots
		.pyplot.axes
		.Figure.subplots
		
		Examples
		--------
		::
		
		    plt.subplot(221)
		
		    # equivalent but more general
		    ax1=plt.subplot(2, 2, 1)
		
		    # add a subplot with no frame
		    ax2=plt.subplot(222, frameon=False)
		
		    # add a polar subplot
		    plt.subplot(223, projection='polar')
		
		    # add a red subplot that shares the x-axis with ax1
		    plt.subplot(224, sharex=ax1, facecolor='red')
		
		    # delete ax2 from the figure
		    plt.delaxes(ax2)
		
		    # add ax2 to the figure again
		    plt.subplot(ax2)
		    
	**/
	static public function subplot(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Create an axis at specific location inside a regular grid.
		
		Parameters
		----------
		shape : sequence of 2 ints
		    Shape of grid in which to place axis.
		    First entry is number of rows, second entry is number of columns.
		
		loc : sequence of 2 ints
		    Location to place axis within grid.
		    First entry is row number, second entry is column number.
		
		rowspan : int
		    Number of rows for the axis to span to the right.
		
		colspan : int
		    Number of columns for the axis to span downwards.
		
		fig : `Figure`, optional
		    Figure to place axis in. Defaults to current figure.
		
		**kwargs
		    Additional keyword arguments are handed to `add_subplot`.
		
		
		Notes
		-----
		The following call ::
		
		    subplot2grid(shape, loc, rowspan=1, colspan=1)
		
		is identical to ::
		
		    gridspec=GridSpec(shape[0], shape[1])
		    subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)
		    subplot(subplotspec)
	**/
	static public function subplot2grid(shape:Dynamic, loc:Dynamic, ?rowspan:Dynamic, ?colspan:Dynamic, ?fig:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Launch a subplot tool window for a figure.
		
		A :class:`matplotlib.widgets.SubplotTool` instance is returned.
	**/
	static public function subplot_tool(?targetfig:Dynamic):Dynamic;
	/**
		Create a figure and a set of subplots.
		
		This utility wrapper makes it convenient to create common layouts of
		subplots, including the enclosing figure object, in a single call.
		
		Parameters
		----------
		nrows, ncols : int, optional, default: 1
		    Number of rows/columns of the subplot grid.
		
		sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
		    Controls sharing of properties among x (`sharex`) or y (`sharey`)
		    axes:
		
		        - True or 'all': x- or y-axis will be shared among all
		          subplots.
		        - False or 'none': each subplot x- or y-axis will be
		          independent.
		        - 'row': each subplot row will share an x- or y-axis.
		        - 'col': each subplot column will share an x- or y-axis.
		
		    When subplots have a shared x-axis along a column, only the x tick
		    labels of the bottom subplot are created. Similarly, when subplots
		    have a shared y-axis along a row, only the y tick labels of the first
		    column subplot are created. To later turn other subplots' ticklabels
		    on, use `~matplotlib.axes.Axes.tick_params`.
		
		squeeze : bool, optional, default: True
		    - If True, extra dimensions are squeezed out from the returned
		      array of `~matplotlib.axes.Axes`:
		
		        - if only one subplot is constructed (nrows=ncols=1), the
		          resulting single Axes object is returned as a scalar.
		        - for Nx1 or 1xM subplots, the returned object is a 1D numpy
		          object array of Axes objects.
		        - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
		
		    - If False, no squeezing at all is done: the returned Axes object is
		      always a 2D array containing Axes instances, even if it ends up
		      being 1x1.
		
		num : integer or string, optional, default: None
		    A `.pyplot.figure` keyword that sets the figure number or label.
		
		subplot_kw : dict, optional
		    Dict with keywords passed to the
		    `~matplotlib.figure.Figure.add_subplot` call used to create each
		    subplot.
		
		gridspec_kw : dict, optional
		    Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
		    constructor used to create the grid the subplots are placed on.
		
		**fig_kw
		    All additional keyword arguments are passed to the
		    `.pyplot.figure` call.
		
		Returns
		-------
		fig : `~.figure.Figure`
		
		ax : `.axes.Axes` object or array of Axes objects.
		    *ax* can be either a single `~matplotlib.axes.Axes` object or an
		    array of Axes objects if more than one subplot was created.  The
		    dimensions of the resulting array can be controlled with the squeeze
		    keyword, see above.
		
		Examples
		--------
		::
		
		    # First create some toy data:
		    x = np.linspace(0, 2*np.pi, 400)
		    y = np.sin(x**2)
		
		    # Creates just a figure and only one subplot
		    fig, ax = plt.subplots()
		    ax.plot(x, y)
		    ax.set_title('Simple plot')
		
		    # Creates two subplots and unpacks the output array immediately
		    f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
		    ax1.plot(x, y)
		    ax1.set_title('Sharing Y axis')
		    ax2.scatter(x, y)
		
		    # Creates four polar axes, and accesses them through the returned array
		    fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))
		    axes[0, 0].plot(x, y)
		    axes[1, 1].scatter(x, y)
		
		    # Share a X axis with each column of subplots
		    plt.subplots(2, 2, sharex='col')
		
		    # Share a Y axis with each row of subplots
		    plt.subplots(2, 2, sharey='row')
		
		    # Share both X and Y axes with all subplots
		    plt.subplots(2, 2, sharex='all', sharey='all')
		
		    # Note that this is the same as
		    plt.subplots(2, 2, sharex=True, sharey=True)
		
		    # Creates figure number 10 with a single subplot
		    # and clears it if it already exists.
		    fig, ax=plt.subplots(num=10, clear=True)
		
		See Also
		--------
		.pyplot.figure
		.pyplot.subplot
		.pyplot.axes
		.Figure.subplots
		.Figure.add_subplot
	**/
	static public function subplots(?nrows:Dynamic, ?ncols:Dynamic, ?sharex:Dynamic, ?sharey:Dynamic, ?squeeze:Dynamic, ?subplot_kw:Dynamic, ?gridspec_kw:Dynamic, ?fig_kw:python.KwArgs<Dynamic>):Dynamic;
	/**
		Tune the subplot layout.
		
		The parameter meanings (and suggested defaults) are::
		
		  left = 0.125  # the left side of the subplots of the figure
		  right = 0.9   # the right side of the subplots of the figure
		  bottom = 0.1  # the bottom of the subplots of the figure
		  top = 0.9     # the top of the subplots of the figure
		  wspace = 0.2  # the amount of width reserved for space between subplots,
		                # expressed as a fraction of the average axis width
		  hspace = 0.2  # the amount of height reserved for space between subplots,
		                # expressed as a fraction of the average axis height
		
		The actual defaults are controlled by the rc file
	**/
	static public function subplots_adjust(?left:Dynamic, ?bottom:Dynamic, ?right:Dynamic, ?top:Dynamic, ?wspace:Dynamic, ?hspace:Dynamic):Dynamic;
	/**
		subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Subtract arguments, element-wise.
		
		Parameters
		----------
		x1, x2 : array_like
		    The arrays to be subtracted from each other.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The difference of `x1` and `x2`, element-wise.
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		Equivalent to ``x1 - x2`` in terms of array broadcasting.
		
		Examples
		--------
		>>> np.subtract(1.0, 4.0)
		-3.0
		
		>>> x1 = np.arange(9.0).reshape((3, 3))
		>>> x2 = np.arange(3.0)
		>>> np.subtract(x1, x2)
		array([[ 0.,  0.,  0.],
		       [ 3.,  3.,  3.],
		       [ 6.,  6.,  6.]])
	**/
	static public function subtract(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Sum of array elements over a given axis.
		
		Parameters
		----------
		a : array_like
		    Elements to sum.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which a sum is performed.  The default,
		    axis=None, will sum all of the elements of the input array.  If
		    axis is negative it counts from the last to the first axis.
		
		    .. versionadded:: 1.7.0
		
		    If axis is a tuple of ints, a sum is performed on all of the axes
		    specified in the tuple instead of a single axis or all the axes as
		    before.
		dtype : dtype, optional
		    The type of the returned array and of the accumulator in which the
		    elements are summed.  The dtype of `a` is used by default unless `a`
		    has an integer dtype of less precision than the default platform
		    integer.  In that case, if `a` is signed then the platform integer
		    is used while if `a` is unsigned then an unsigned integer of the
		    same precision as the platform integer is used.
		out : ndarray, optional
		    Alternative output array in which to place the result. It must have
		    the same shape as the expected output, but the type of the output
		    values will be cast if necessary.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `sum` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		initial : scalar, optional
		    Starting value for the sum. See `~numpy.ufunc.reduce` for details.
		
		    .. versionadded:: 1.15.0
		
		Returns
		-------
		sum_along_axis : ndarray
		    An array with the same shape as `a`, with the specified
		    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
		    is returned.  If an output array is specified, a reference to
		    `out` is returned.
		
		See Also
		--------
		ndarray.sum : Equivalent method.
		
		cumsum : Cumulative sum of array elements.
		
		trapz : Integration of array values using the composite trapezoidal rule.
		
		mean, average
		
		Notes
		-----
		Arithmetic is modular when using integer types, and no error is
		raised on overflow.
		
		The sum of an empty array is the neutral element 0:
		
		>>> np.sum([])
		0.0
		
		Examples
		--------
		>>> np.sum([0.5, 1.5])
		2.0
		>>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
		1
		>>> np.sum([[0, 1], [0, 5]])
		6
		>>> np.sum([[0, 1], [0, 5]], axis=0)
		array([0, 6])
		>>> np.sum([[0, 1], [0, 5]], axis=1)
		array([1, 5])
		
		If the accumulator is too small, overflow occurs:
		
		>>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
		-128
		
		You can also start the sum with a value other than zero:
		
		>>> np.sum([10], initial=5)
		15
	**/
	static public function sum(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?keepdims:Dynamic, ?initial:Dynamic):Dynamic;
	/**
		Set the colormap to "summer".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function summer():Dynamic;
	/**
		Add a centered title to the figure.
		
		Parameters
		----------
		t : str
		    The title text.
		
		x : float, default 0.5
		    The x location of the text in figure coordinates.
		
		y : float, default 0.98
		    The y location of the text in figure coordinates.
		
		horizontalalignment, ha : {'center', 'left', right'}, default: 'center'
		    The horizontal alignment of the text relative to (*x*, *y*).
		
		verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, default: 'top'
		    The vertical alignment of the text relative to (*x*, *y*).
		
		fontsize, size : default: :rc:`figure.titlesize`
		    The font size of the text. See `.Text.set_size` for possible
		    values.
		
		fontweight, weight : default: :rc:`figure.titleweight`
		    The font weight of the text. See `.Text.set_weight` for possible
		    values.
		
		
		Returns
		-------
		    text
		        The `.Text` instance of the title.
		
		
		Other Parameters
		----------------
		fontproperties : None or dict, optional
		    A dict of font properties. If *fontproperties* is given the
		    default values for font size and weight are taken from the
		    `FontProperties` defaults. :rc:`figure.titlesize` and
		    :rc:`figure.titleweight` are ignored in this case.
		
		**kwargs
		    Additional kwargs are :class:`matplotlib.text.Text` properties.
		
		
		Examples
		--------
		
		>>> fig.suptitle('This is the figure title', fontsize=12)
	**/
	static public function suptitle(t:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Singular Value Decomposition.
		
		When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh
		= (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D
		array of `a`'s singular values. When `a` is higher-dimensional, SVD is
		applied in stacked mode as explained below.
		
		Parameters
		----------
		a : (..., M, N) array_like
		    A real or complex array with ``a.ndim >= 2``.
		full_matrices : bool, optional
		    If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
		    ``(..., N, N)``, respectively.  Otherwise, the shapes are
		    ``(..., M, K)`` and ``(..., K, N)``, respectively, where
		    ``K = min(M, N)``.
		compute_uv : bool, optional
		    Whether or not to compute `u` and `vh` in addition to `s`.  True
		    by default.
		
		Returns
		-------
		u : { (..., M, M), (..., M, K) } array
		    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
		    size as those of the input `a`. The size of the last two dimensions
		    depends on the value of `full_matrices`. Only returned when
		    `compute_uv` is True.
		s : (..., K) array
		    Vector(s) with the singular values, within each vector sorted in
		    descending order. The first ``a.ndim - 2`` dimensions have the same
		    size as those of the input `a`.
		vh : { (..., N, N), (..., K, N) } array
		    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
		    size as those of the input `a`. The size of the last two dimensions
		    depends on the value of `full_matrices`. Only returned when
		    `compute_uv` is True.
		
		Raises
		------
		LinAlgError
		    If SVD computation does not converge.
		
		Notes
		-----
		
		.. versionchanged:: 1.8.0
		   Broadcasting rules apply, see the `numpy.linalg` documentation for
		   details.
		
		The decomposition is performed using LAPACK routine ``_gesdd``.
		
		SVD is usually described for the factorization of a 2D matrix :math:`A`.
		The higher-dimensional case will be discussed below. In the 2D case, SVD is
		written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
		:math:`S= \mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
		contains the singular values of `a` and `u` and `vh` are unitary. The rows
		of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
		the eigenvectors of :math:`A A^H`. In both cases the corresponding
		(possibly non-zero) eigenvalues are given by ``s**2``.
		
		If `a` has more than two dimensions, then broadcasting rules apply, as
		explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
		working in "stacked" mode: it iterates over all indices of the first
		``a.ndim - 2`` dimensions and for each combination SVD is applied to the
		last two indices. The matrix `a` can be reconstructed from the
		decomposition with either ``(u * s[..., None, :]) @ vh`` or
		``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
		function ``np.matmul`` for python versions below 3.5.)
		
		If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
		all the return values.
		
		Examples
		--------
		>>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
		>>> b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)
		
		Reconstruction based on full SVD, 2D case:
		
		>>> u, s, vh = np.linalg.svd(a, full_matrices=True)
		>>> u.shape, s.shape, vh.shape
		((9, 9), (6,), (6, 6))
		>>> np.allclose(a, np.dot(u[:, :6] * s, vh))
		True
		>>> smat = np.zeros((9, 6), dtype=complex)
		>>> smat[:6, :6] = np.diag(s)
		>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
		True
		
		Reconstruction based on reduced SVD, 2D case:
		
		>>> u, s, vh = np.linalg.svd(a, full_matrices=False)
		>>> u.shape, s.shape, vh.shape
		((9, 6), (6,), (6, 6))
		>>> np.allclose(a, np.dot(u * s, vh))
		True
		>>> smat = np.diag(s)
		>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
		True
		
		Reconstruction based on full SVD, 4D case:
		
		>>> u, s, vh = np.linalg.svd(b, full_matrices=True)
		>>> u.shape, s.shape, vh.shape
		((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
		>>> np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
		True
		>>> np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
		True
		
		Reconstruction based on reduced SVD, 4D case:
		
		>>> u, s, vh = np.linalg.svd(b, full_matrices=False)
		>>> u.shape, s.shape, vh.shape
		((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
		>>> np.allclose(b, np.matmul(u * s[..., None, :], vh))
		True
		>>> np.allclose(b, np.matmul(u, s[..., None] * vh))
		True
	**/
	static public function svd(a:Dynamic, ?full_matrices:Dynamic, ?compute_uv:Dynamic):Dynamic;
	/**
		Interchange two axes of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axis1 : int
		    First axis.
		axis2 : int
		    Second axis.
		
		Returns
		-------
		a_swapped : ndarray
		    For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is
		    returned; otherwise a new array is created. For earlier NumPy
		    versions a view of `a` is returned only if the order of the
		    axes is changed, otherwise the input array is returned.
		
		Examples
		--------
		>>> x = np.array([[1,2,3]])
		>>> np.swapaxes(x,0,1)
		array([[1],
		       [2],
		       [3]])
		
		>>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
		>>> x
		array([[[0, 1],
		        [2, 3]],
		       [[4, 5],
		        [6, 7]]])
		
		>>> np.swapaxes(x,0,2)
		array([[[0, 4],
		        [2, 6]],
		       [[1, 5],
		        [3, 7]]])
	**/
	static public function swapaxes(a:Dynamic, axis1:Dynamic, axis2:Dynamic):Dynamic;
	/**
		Close all open figures and set the Matplotlib backend.
		
		The argument is case-insensitive.  Switching to an interactive backend is
		possible only if no event loop for another interactive backend has started.
		Switching to and from non-interactive backends is always possible.
		
		Parameters
		----------
		newbackend : str
		    The name of the backend to use.
	**/
	static public function switch_backend(newbackend:Dynamic):Dynamic;
	/**
		Add a table to an `~.axes.Axes`.
		
		At least one of *cellText* or *cellColours* must be specified. These
		parameters must be 2D lists, in which the outer lists define the rows and
		the inner list define the column values per row. Each row must have the
		same number of elements.
		
		The table can optionally have row and column headers, which are configured
		using *rowLabels*, *rowColours*, *rowLoc* and *colLabels*, *colColours*,
		*colLoc* respectively.
		
		For finer grained control over tables, use the `.Table` class and add it to
		the axes with `.Axes.add_table`.
		
		Parameters
		----------
		cellText : 2D list of str, optional
		    The texts to place into the table cells.
		
		    *Note*: Line breaks in the strings are currently not accounted for and
		    will result in the text exceeding the cell boundaries.
		
		cellColours : 2D list of matplotlib color specs, optional
		    The background colors of the cells.
		
		cellLoc : {'left', 'center', 'right'}, default: 'right'
		    The alignment of the text within the cells.
		
		colWidths : list of float, optional
		    The column widths in units of the axes. If not given, all columns will
		    have a width of *1 / ncols*.
		
		rowLabels : list of str, optional
		    The text of the row header cells.
		
		rowColours : list of matplotlib color specs, optional
		    The colors of the row header cells.
		
		rowLoc : {'left', 'center', 'right'}, optional, default: 'left'
		    The text alignment of the row header cells.
		
		colLabels : list of str, optional
		    The text of the column header cells.
		
		colColours : list of matplotlib color specs, optional
		    The colors of the column header cells.
		
		rowLoc : {'left', 'center', 'right'}, optional, default: 'left'
		    The text alignment of the column header cells.
		
		loc : str, optional
		    The position of the cell with respect to *ax*. This must be one of
		    the `~.Table.codes`.
		
		bbox : `.Bbox`, optional
		    A bounding box to draw the table into. If this is not *None*, this
		    overrides *loc*.
		
		edges : substring of 'BRTL' or {'open', 'closed', 'horizontal', 'vertical'}
		    The cell edges to be drawn with a line. See also
		    `~.CustomCell.visible_edges`.
		
		Other Parameters
		----------------
		**kwargs
		    `.Table` properties.
		
		  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
		  alpha: float
		  animated: bool
		  clip_box: `.Bbox`
		  clip_on: bool
		  clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]
		  contains: callable
		  figure: `.Figure`
		  fontsize: float
		  gid: str
		  in_layout: bool
		  label: object
		  path_effects: `.AbstractPathEffect`
		  picker: None or bool or float or callable
		  rasterized: bool or None
		  sketch_params: (scale: float, length: float, randomness: float)
		  snap: bool or None
		  transform: `.Transform`
		  url: str
		  visible: bool
		  zorder: float
		
		Returns
		-------
		table : `~matplotlib.table.Table`
		    The created table.
	**/
	static public function table(?cellText:Dynamic, ?cellColours:Dynamic, ?cellLoc:Dynamic, ?colWidths:Dynamic, ?rowLabels:Dynamic, ?rowColours:Dynamic, ?rowLoc:Dynamic, ?colLabels:Dynamic, ?colColours:Dynamic, ?colLoc:Dynamic, ?loc:Dynamic, ?bbox:Dynamic, ?edges:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Take elements from an array along an axis.
		
		When axis is not None, this function does the same thing as "fancy"
		indexing (indexing arrays using arrays); however, it can be easier to use
		if you need elements along a given axis. A call such as
		``np.take(arr, indices, axis=3)`` is equivalent to
		``arr[:,:,:,indices,...]``.
		
		Explained without fancy indexing, this is equivalent to the following use
		of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
		indices::
		
		    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
		    Nj = indices.shape
		    for ii in ndindex(Ni):
		        for jj in ndindex(Nj):
		            for kk in ndindex(Nk):
		                out[ii + jj + kk] = a[ii + (indices[jj],) + kk]
		
		Parameters
		----------
		a : array_like (Ni..., M, Nk...)
		    The source array.
		indices : array_like (Nj...)
		    The indices of the values to extract.
		
		    .. versionadded:: 1.8.0
		
		    Also allow scalars for indices.
		axis : int, optional
		    The axis over which to select values. By default, the flattened
		    input array is used.
		out : ndarray, optional (Ni..., Nj..., Nk...)
		    If provided, the result will be placed in this array. It should
		    be of the appropriate shape and dtype.
		mode : {'raise', 'wrap', 'clip'}, optional
		    Specifies how out-of-bounds indices will behave.
		
		    * 'raise' -- raise an error (default)
		    * 'wrap' -- wrap around
		    * 'clip' -- clip to the range
		
		    'clip' mode means that all indices that are too large are replaced
		    by the index that addresses the last element along that axis. Note
		    that this disables indexing with negative numbers.
		
		Returns
		-------
		out : ndarray (Ni..., Nj..., Nk...)
		    The returned array has the same type as `a`.
		
		See Also
		--------
		compress : Take elements using a boolean mask
		ndarray.take : equivalent method
		take_along_axis : Take elements by matching the array and the index arrays
		
		Notes
		-----
		
		By eliminating the inner loop in the description above, and using `s_` to
		build simple slice objects, `take` can be expressed  in terms of applying
		fancy indexing to each 1-d slice::
		
		    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
		    for ii in ndindex(Ni):
		        for kk in ndindex(Nj):
		            out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]
		
		For this reason, it is equivalent to (but faster than) the following use
		of `apply_along_axis`::
		
		    out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)
		
		Examples
		--------
		>>> a = [4, 3, 5, 7, 6, 8]
		>>> indices = [0, 1, 4]
		>>> np.take(a, indices)
		array([4, 3, 6])
		
		In this example if `a` is an ndarray, "fancy" indexing can be used.
		
		>>> a = np.array(a)
		>>> a[indices]
		array([4, 3, 6])
		
		If `indices` is not one dimensional, the output also has these dimensions.
		
		>>> np.take(a, [[0, 1], [2, 3]])
		array([[4, 3],
		       [5, 7]])
	**/
	static public function take(a:Dynamic, indices:Dynamic, ?axis:Dynamic, ?out:Dynamic, ?mode:Dynamic):Dynamic;
	/**
		Take values from the input array by matching 1d index and data slices.
		
		This iterates over matching 1d slices oriented along the specified axis in
		the index and data arrays, and uses the former to look up values in the
		latter. These slices can be different lengths.
		
		Functions returning an index along an axis, like `argsort` and
		`argpartition`, produce suitable indices for this function.
		
		.. versionadded:: 1.15.0
		
		Parameters
		----------
		arr: ndarray (Ni..., M, Nk...)
		    Source array
		indices: ndarray (Ni..., J, Nk...)
		    Indices to take along each 1d slice of `arr`. This must match the
		    dimension of arr, but dimensions Ni and Nj only need to broadcast
		    against `arr`.
		axis: int
		    The axis to take 1d slices along. If axis is None, the input array is
		    treated as if it had first been flattened to 1d, for consistency with
		    `sort` and `argsort`.
		
		Returns
		-------
		out: ndarray (Ni..., J, Nk...)
		    The indexed result.
		
		Notes
		-----
		This is equivalent to (but faster than) the following use of `ndindex` and
		`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::
		
		    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
		    J = indices.shape[axis]  # Need not equal M
		    out = np.empty(Nk + (J,) + Nk)
		
		    for ii in ndindex(Ni):
		        for kk in ndindex(Nk):
		            a_1d       = a      [ii + s_[:,] + kk]
		            indices_1d = indices[ii + s_[:,] + kk]
		            out_1d     = out    [ii + s_[:,] + kk]
		            for j in range(J):
		                out_1d[j] = a_1d[indices_1d[j]]
		
		Equivalently, eliminating the inner loop, the last two lines would be::
		
		            out_1d[:] = a_1d[indices_1d]
		
		See Also
		--------
		take : Take along an axis, using the same indices for every 1d slice
		put_along_axis :
		    Put values into the destination array by matching 1d index and data slices
		
		Examples
		--------
		
		For this sample array
		
		>>> a = np.array([[10, 30, 20], [60, 40, 50]])
		
		We can sort either by using sort directly, or argsort and this function
		
		>>> np.sort(a, axis=1)
		array([[10, 20, 30],
		       [40, 50, 60]])
		>>> ai = np.argsort(a, axis=1); ai
		array([[0, 2, 1],
		       [1, 2, 0]], dtype=int64)
		>>> np.take_along_axis(a, ai, axis=1)
		array([[10, 20, 30],
		       [40, 50, 60]])
		
		The same works for max and min, if you expand the dimensions:
		
		>>> np.expand_dims(np.max(a, axis=1), axis=1)
		array([[30],
		       [60]])
		>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
		>>> ai
		array([[1],
		       [0], dtype=int64)
		>>> np.take_along_axis(a, ai, axis=1)
		array([[30],
		       [60]])
		
		If we want to get the max and min at the same time, we can stack the
		indices first
		
		>>> ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)
		>>> ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)
		>>> ai = np.concatenate([ai_min, ai_max], axis=axis)
		>> ai
		array([[0, 1],
		       [1, 0]], dtype=int64)
		>>> np.take_along_axis(a, ai, axis=1)
		array([[10, 30],
		       [40, 60]])
	**/
	static public function take_along_axis(arr:Dynamic, indices:Dynamic, axis:Dynamic):Dynamic;
	/**
		tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute tangent element-wise.
		
		Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding tangent values.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		If `out` is provided, the function writes the result into it,
		and returns a reference to `out`.  (See Examples)
		
		References
		----------
		M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
		New York, NY: Dover, 1972.
		
		Examples
		--------
		>>> from math import pi
		>>> np.tan(np.array([-pi,pi/2,pi]))
		array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
		>>>
		>>> # Example of providing the optional output parameter illustrating
		>>> # that what is returned is a reference to said parameter
		>>> out2 = np.cos([0.1], out1)
		>>> out2 is out1
		True
		>>>
		>>> # Example of ValueError due to provision of shape mis-matched `out`
		>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
	**/
	static public function tan(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Compute hyperbolic tangent element-wise.
		
		Equivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.
		
		Parameters
		----------
		x : array_like
		    Input array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray
		    The corresponding hyperbolic tangent values.
		    This is a scalar if `x` is a scalar.
		
		Notes
		-----
		If `out` is provided, the function writes the result into it,
		and returns a reference to `out`.  (See Examples)
		
		References
		----------
		.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
		       New York, NY: Dover, 1972, pg. 83.
		       http://www.math.sfu.ca/~cbm/aands/
		
		.. [2] Wikipedia, "Hyperbolic function",
		       https://en.wikipedia.org/wiki/Hyperbolic_function
		
		Examples
		--------
		>>> np.tanh((0, np.pi*1j, np.pi*1j/2))
		array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])
		
		>>> # Example of providing the optional output parameter illustrating
		>>> # that what is returned is a reference to said parameter
		>>> out2 = np.tanh([0.1], out1)
		>>> out2 is out1
		True
		
		>>> # Example of ValueError due to provision of shape mis-matched `out`
		>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
	**/
	static public function tanh(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Compute tensor dot product along specified axes for arrays >= 1-D.
		
		Given two tensors (arrays of dimension greater than or equal to one),
		`a` and `b`, and an array_like object containing two array_like
		objects, ``(a_axes, b_axes)``, sum the products of `a`'s and `b`'s
		elements (components) over the axes specified by ``a_axes`` and
		``b_axes``. The third argument can be a single non-negative
		integer_like scalar, ``N``; if it is such, then the last ``N``
		dimensions of `a` and the first ``N`` dimensions of `b` are summed
		over.
		
		Parameters
		----------
		a, b : array_like, len(shape) >= 1
		    Tensors to "dot".
		
		axes : int or (2,) array_like
		    * integer_like
		      If an int N, sum over the last N axes of `a` and the first N axes
		      of `b` in order. The sizes of the corresponding axes must match.
		    * (2,) array_like
		      Or, a list of axes to be summed over, first sequence applying to `a`,
		      second to `b`. Both elements array_like must be of the same length.
		
		See Also
		--------
		dot, einsum
		
		Notes
		-----
		Three common use cases are:
		    * ``axes = 0`` : tensor product :math:`a\otimes b`
		    * ``axes = 1`` : tensor dot product :math:`a\cdot b`
		    * ``axes = 2`` : (default) tensor double contraction :math:`a:b`
		
		When `axes` is integer_like, the sequence for evaluation will be: first
		the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
		Nth axis in `b` last.
		
		When there is more than one axis to sum over - and they are not the last
		(first) axes of `a` (`b`) - the argument `axes` should consist of
		two sequences of the same length, with the first axis to sum over given
		first in both sequences, the second axis second, and so forth.
		
		Examples
		--------
		A "traditional" example:
		
		>>> a = np.arange(60.).reshape(3,4,5)
		>>> b = np.arange(24.).reshape(4,3,2)
		>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
		>>> c.shape
		(5, 2)
		>>> c
		array([[ 4400.,  4730.],
		       [ 4532.,  4874.],
		       [ 4664.,  5018.],
		       [ 4796.,  5162.],
		       [ 4928.,  5306.]])
		>>> # A slower but equivalent way of computing the same...
		>>> d = np.zeros((5,2))
		>>> for i in range(5):
		...   for j in range(2):
		...     for k in range(3):
		...       for n in range(4):
		...         d[i,j] += a[k,n,i] * b[n,k,j]
		>>> c == d
		array([[ True,  True],
		       [ True,  True],
		       [ True,  True],
		       [ True,  True],
		       [ True,  True]])
		
		An extended example taking advantage of the overloading of + and \*:
		
		>>> a = np.array(range(1, 9))
		>>> a.shape = (2, 2, 2)
		>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
		>>> A.shape = (2, 2)
		>>> a; A
		array([[[1, 2],
		        [3, 4]],
		       [[5, 6],
		        [7, 8]]])
		array([[a, b],
		       [c, d]], dtype=object)
		
		>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
		array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)
		
		>>> np.tensordot(a, A, 1)
		array([[[acc, bdd],
		        [aaacccc, bbbdddd]],
		       [[aaaaacccccc, bbbbbdddddd],
		        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)
		
		>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
		array([[[[[a, b],
		          [c, d]],
		          ...
		
		>>> np.tensordot(a, A, (0, 1))
		array([[[abbbbb, cddddd],
		        [aabbbbbb, ccdddddd]],
		       [[aaabbbbbbb, cccddddddd],
		        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)
		
		>>> np.tensordot(a, A, (2, 1))
		array([[[abb, cdd],
		        [aaabbbb, cccdddd]],
		       [[aaaaabbbbbb, cccccdddddd],
		        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)
		
		>>> np.tensordot(a, A, ((0, 1), (0, 1)))
		array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)
		
		>>> np.tensordot(a, A, ((2, 1), (1, 0)))
		array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)
	**/
	static public function tensordot(a:Dynamic, b:Dynamic, ?axes:Dynamic):Dynamic;
	/**
		Compute the 'inverse' of an N-dimensional array.
		
		The result is an inverse for `a` relative to the tensordot operation
		``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
		``tensordot(tensorinv(a), a, ind)`` is the "identity" tensor for the
		tensordot operation.
		
		Parameters
		----------
		a : array_like
		    Tensor to 'invert'. Its shape must be 'square', i. e.,
		    ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
		ind : int, optional
		    Number of first indices that are involved in the inverse sum.
		    Must be a positive integer, default is 2.
		
		Returns
		-------
		b : ndarray
		    `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.
		
		Raises
		------
		LinAlgError
		    If `a` is singular or not 'square' (in the above sense).
		
		See Also
		--------
		numpy.tensordot, tensorsolve
		
		Examples
		--------
		>>> a = np.eye(4*6)
		>>> a.shape = (4, 6, 8, 3)
		>>> ainv = np.linalg.tensorinv(a, ind=2)
		>>> ainv.shape
		(8, 3, 4, 6)
		>>> b = np.random.randn(4, 6)
		>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
		True
		
		>>> a = np.eye(4*6)
		>>> a.shape = (24, 8, 3)
		>>> ainv = np.linalg.tensorinv(a, ind=1)
		>>> ainv.shape
		(8, 3, 24)
		>>> b = np.random.randn(24)
		>>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
		True
	**/
	static public function tensorinv(a:Dynamic, ?ind:Dynamic):Dynamic;
	/**
		Solve the tensor equation ``a x = b`` for x.
		
		It is assumed that all indices of `x` are summed over in the product,
		together with the rightmost indices of `a`, as is done in, for example,
		``tensordot(a, x, axes=b.ndim)``.
		
		Parameters
		----------
		a : array_like
		    Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
		    the shape of that sub-tensor of `a` consisting of the appropriate
		    number of its rightmost indices, and must be such that
		    ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
		    'square').
		b : array_like
		    Right-hand tensor, which can be of any shape.
		axes : tuple of ints, optional
		    Axes in `a` to reorder to the right, before inversion.
		    If None (default), no reordering is done.
		
		Returns
		-------
		x : ndarray, shape Q
		
		Raises
		------
		LinAlgError
		    If `a` is singular or not 'square' (in the above sense).
		
		See Also
		--------
		numpy.tensordot, tensorinv, numpy.einsum
		
		Examples
		--------
		>>> a = np.eye(2*3*4)
		>>> a.shape = (2*3, 4, 2, 3, 4)
		>>> b = np.random.randn(2*3, 4)
		>>> x = np.linalg.tensorsolve(a, b)
		>>> x.shape
		(2, 3, 4)
		>>> np.allclose(np.tensordot(a, x, axes=3), b)
		True
	**/
	static public function tensorsolve(a:Dynamic, b:Dynamic, ?axes:Dynamic):Dynamic;
	static public function test(?label:Dynamic, ?verbose:Dynamic, ?extra_argv:Dynamic, ?doctests:Dynamic, ?coverage:Dynamic, ?durations:Dynamic, ?tests:Dynamic):Dynamic;
	/**
		Add text to the axes.
		
		Add the text *s* to the axes at location *x*, *y* in data coordinates.
		
		Parameters
		----------
		x, y : scalars
		    The position to place the text. By default, this is in data
		    coordinates. The coordinate system can be changed using the
		    *transform* parameter.
		
		s : str
		    The text.
		
		fontdict : dictionary, optional, default: None
		    A dictionary to override the default text properties. If fontdict
		    is None, the defaults are determined by your rc parameters.
		
		withdash : boolean, optional, default: False
		    Creates a `~matplotlib.text.TextWithDash` instance instead of a
		    `~matplotlib.text.Text` instance.
		
		Returns
		-------
		text : `.Text`
		    The created `.Text` instance.
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.text.Text` properties.
		    Other miscellaneous text parameters.
		
		Examples
		--------
		Individual keyword arguments can be used to override any given
		parameter::
		
		    >>> text(x, y, s, fontsize=12)
		
		The default transform specifies that text is in data coords,
		alternatively, you can specify text in axis coords (0,0 is
		lower-left and 1,1 is upper-right).  The example below places
		text in the center of the axes::
		
		    >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
		    ...      verticalalignment='center', transform=ax.transAxes)
		
		You can put a rectangular box around the text instance (e.g., to
		set a background color) by using the keyword `bbox`.  `bbox` is
		a dictionary of `~matplotlib.patches.Rectangle`
		properties.  For example::
		
		    >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
	**/
	static public function text(x:Dynamic, y:Dynamic, s:Dynamic, ?fontdict:Dynamic, ?withdash:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Get or set the theta gridlines on the current polar plot.
		
		Call signatures::
		
		 lines, labels = thetagrids()
		 lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
		
		When called with no arguments, `.thetagrids` simply returns the tuple
		(*lines*, *labels*). When called with arguments, the labels will
		appear at the specified angles.
		
		Parameters
		----------
		angles : tuple with floats, degrees
		    The angles of the theta gridlines.
		
		labels : tuple with strings or None
		    The labels to use at each radial gridline. The
		    `.projections.polar.ThetaFormatter` will be used if None.
		
		fmt : str or None
		    Format string used in `matplotlib.ticker.FormatStrFormatter`.
		    For example '%f'. Note that the angle in radians will be used.
		
		Returns
		-------
		lines, labels : list of `.lines.Line2D`, list of `.text.Text`
		    *lines* are the theta gridlines and *labels* are the tick labels.
		
		Other Parameters
		----------------
		**kwargs
		    *kwargs* are optional `~.Text` properties for the labels.
		
		Examples
		--------
		::
		
		  # set the locations of the angular gridlines
		  lines, labels = thetagrids( range(45,360,90) )
		
		  # set the locations and labels of the angular gridlines
		  lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )
		
		See Also
		--------
		.pyplot.rgrids
		.projections.polar.PolarAxes.set_thetagrids
		.Axis.get_gridlines
		.Axis.get_ticklabels
	**/
	static public function thetagrids(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Change the appearance of ticks, tick labels, and gridlines.
		
		Parameters
		----------
		axis : {'x', 'y', 'both'}, optional
		    Which axis to apply the parameters to.
		
		Other Parameters
		----------------
		
		axis : {'x', 'y', 'both'}
		    Axis on which to operate; default is 'both'.
		
		reset : bool
		    If *True*, set all parameters to defaults
		    before processing other keyword arguments.  Default is
		    *False*.
		
		which : {'major', 'minor', 'both'}
		    Default is 'major'; apply arguments to *which* ticks.
		
		direction : {'in', 'out', 'inout'}
		    Puts ticks inside the axes, outside the axes, or both.
		
		length : float
		    Tick length in points.
		
		width : float
		    Tick width in points.
		
		color : color
		    Tick color; accepts any mpl color spec.
		
		pad : float
		    Distance in points between tick and label.
		
		labelsize : float or str
		    Tick label font size in points or as a string (e.g., 'large').
		
		labelcolor : color
		    Tick label color; mpl color spec.
		
		colors : color
		    Changes the tick color and the label color to the same value:
		    mpl color spec.
		
		zorder : float
		    Tick and label zorder.
		
		bottom, top, left, right : bool
		    Whether to draw the respective ticks.
		
		labelbottom, labeltop, labelleft, labelright : bool
		    Whether to draw the respective tick labels.
		
		labelrotation : float
		    Tick label rotation
		
		grid_color : color
		    Changes the gridline color to the given mpl color spec.
		
		grid_alpha : float
		    Transparency of gridlines: 0 (transparent) to 1 (opaque).
		
		grid_linewidth : float
		    Width of gridlines in points.
		
		grid_linestyle : string
		    Any valid `~matplotlib.lines.Line2D` line style spec.
		
		Examples
		--------
		
		Usage ::
		
		    ax.tick_params(direction='out', length=6, width=2, colors='r',
		                   grid_color='r', grid_alpha=0.5)
		
		This will make all major ticks be red, pointing out of the box,
		and with dimensions 6 points by 2 points.  Tick labels will
		also be red.  Gridlines will be red and translucent.
	**/
	static public function tick_params(?axis:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Change the `~matplotlib.ticker.ScalarFormatter` used by
		default for linear axes.
		
		Optional keyword arguments:
		
		  ==============   =========================================
		  Keyword          Description
		  ==============   =========================================
		  *axis*           [ 'x' | 'y' | 'both' ]
		  *style*          [ 'sci' (or 'scientific') | 'plain' ]
		                   plain turns off scientific notation
		  *scilimits*      (m, n), pair of integers; if *style*
		                   is 'sci', scientific notation will
		                   be used for numbers outside the range
		                   10\ :sup:`m` to 10\ :sup:`n`.
		                   Use (0,0) to include all numbers.
		                   Use (m,m) where m <> 0 to fix the order
		                   of magnitude to 10\ :sup:`m`.
		  *useOffset*      [ bool | offset ]; if True,
		                   the offset will be calculated as needed;
		                   if False, no offset will be used; if a
		                   numeric offset is specified, it will be
		                   used.
		  *useLocale*      If True, format the number according to
		                   the current locale.  This affects things
		                   such as the character used for the
		                   decimal separator.  If False, use
		                   C-style (English) formatting.  The
		                   default setting is controlled by the
		                   axes.formatter.use_locale rcparam.
		  *useMathText*    If True, render the offset and scientific
		                   notation in mathtext
		  ==============   =========================================
		
		Only the major ticks are affected.
		If the method is called when the `~matplotlib.ticker.ScalarFormatter`
		is not the `~matplotlib.ticker.Formatter` being used, an
		`AttributeError` will be raised.
	**/
	static public function ticklabel_format(?axis:Dynamic, ?style:Dynamic, ?scilimits:Dynamic, ?useOffset:Dynamic, ?useLocale:Dynamic, ?useMathText:Dynamic):Dynamic;
	/**
		Automatically adjust subplot parameters to give specified padding.
		
		Parameters
		----------
		pad : float
		    Padding between the figure edge and the edges of subplots,
		    as a fraction of the font size.
		h_pad, w_pad : float, optional
		    Padding (height/width) between edges of adjacent subplots,
		    as a fraction of the font size.  Defaults to *pad*.
		rect : tuple (left, bottom, right, top), optional
		    A rectangle (left, bottom, right, top) in the normalized
		    figure coordinate that the whole subplots area (including
		    labels) will fit into. Default is (0, 0, 1, 1).
	**/
	static public function tight_layout(?pad:Dynamic, ?h_pad:Dynamic, ?w_pad:Dynamic, ?rect:Dynamic):Dynamic;
	/**
		Construct an array by repeating A the number of times given by reps.
		
		If `reps` has length ``d``, the result will have dimension of
		``max(d, A.ndim)``.
		
		If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new
		axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
		or shape (1, 1, 3) for 3-D replication. If this is not the desired
		behavior, promote `A` to d-dimensions manually before calling this
		function.
		
		If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
		Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as
		(1, 1, 2, 2).
		
		Note : Although tile may be used for broadcasting, it is strongly
		recommended to use numpy's broadcasting operations and functions.
		
		Parameters
		----------
		A : array_like
		    The input array.
		reps : array_like
		    The number of repetitions of `A` along each axis.
		
		Returns
		-------
		c : ndarray
		    The tiled output array.
		
		See Also
		--------
		repeat : Repeat elements of an array.
		broadcast_to : Broadcast an array to a new shape
		
		Examples
		--------
		>>> a = np.array([0, 1, 2])
		>>> np.tile(a, 2)
		array([0, 1, 2, 0, 1, 2])
		>>> np.tile(a, (2, 2))
		array([[0, 1, 2, 0, 1, 2],
		       [0, 1, 2, 0, 1, 2]])
		>>> np.tile(a, (2, 1, 2))
		array([[[0, 1, 2, 0, 1, 2]],
		       [[0, 1, 2, 0, 1, 2]]])
		
		>>> b = np.array([[1, 2], [3, 4]])
		>>> np.tile(b, 2)
		array([[1, 2, 1, 2],
		       [3, 4, 3, 4]])
		>>> np.tile(b, (2, 1))
		array([[1, 2],
		       [3, 4],
		       [1, 2],
		       [3, 4]])
		
		>>> c = np.array([1,2,3,4])
		>>> np.tile(c,(4,1))
		array([[1, 2, 3, 4],
		       [1, 2, 3, 4],
		       [1, 2, 3, 4],
		       [1, 2, 3, 4]])
	**/
	static public function tile(A:Dynamic, reps:Dynamic):Dynamic;
	/**
		Set a title for the axes.
		
		Set one of the three available axes titles. The available titles
		are positioned above the axes in the center, flush with the left
		edge, and flush with the right edge.
		
		Parameters
		----------
		label : str
		    Text to use for the title
		
		fontdict : dict
		    A dictionary controlling the appearance of the title text,
		    the default `fontdict` is::
		
		       {'fontsize': rcParams['axes.titlesize'],
		        'fontweight' : rcParams['axes.titleweight'],
		        'verticalalignment': 'baseline',
		        'horizontalalignment': loc}
		
		loc : {'center', 'left', 'right'}, str, optional
		    Which title to set, defaults to 'center'
		
		pad : float
		    The offset of the title from the top of the axes, in points.
		    Default is ``None`` to use rcParams['axes.titlepad'].
		
		Returns
		-------
		text : :class:`~matplotlib.text.Text`
		    The matplotlib text instance representing the title
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.text.Text` properties
		    Other keyword arguments are text properties, see
		    :class:`~matplotlib.text.Text` for a list of valid text
		    properties.
	**/
	static public function title(label:Dynamic, ?fontdict:Dynamic, ?loc:Dynamic, ?pad:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Return the sum along diagonals of the array.
		
		If `a` is 2-D, the sum along its diagonal with the given offset
		is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.
		
		If `a` has more than two dimensions, then the axes specified by axis1 and
		axis2 are used to determine the 2-D sub-arrays whose traces are returned.
		The shape of the resulting array is the same as that of `a` with `axis1`
		and `axis2` removed.
		
		Parameters
		----------
		a : array_like
		    Input array, from which the diagonals are taken.
		offset : int, optional
		    Offset of the diagonal from the main diagonal. Can be both positive
		    and negative. Defaults to 0.
		axis1, axis2 : int, optional
		    Axes to be used as the first and second axis of the 2-D sub-arrays
		    from which the diagonals should be taken. Defaults are the first two
		    axes of `a`.
		dtype : dtype, optional
		    Determines the data-type of the returned array and of the accumulator
		    where the elements are summed. If dtype has the value None and `a` is
		    of integer type of precision less than the default integer
		    precision, then the default integer precision is used. Otherwise,
		    the precision is the same as that of `a`.
		out : ndarray, optional
		    Array into which the output is placed. Its type is preserved and
		    it must be of the right shape to hold the output.
		
		Returns
		-------
		sum_along_diagonals : ndarray
		    If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
		    larger dimensions, then an array of sums along diagonals is returned.
		
		See Also
		--------
		diag, diagonal, diagflat
		
		Examples
		--------
		>>> np.trace(np.eye(3))
		3.0
		>>> a = np.arange(8).reshape((2,2,2))
		>>> np.trace(a)
		array([6, 8])
		
		>>> a = np.arange(24).reshape((2,2,2,3))
		>>> np.trace(a).shape
		(2, 3)
	**/
	static public function trace(a:Dynamic, ?offset:Dynamic, ?axis1:Dynamic, ?axis2:Dynamic, ?dtype:Dynamic, ?out:Dynamic):Dynamic;
	static public var tracemalloc_domain : Dynamic;
	/**
		Permute the dimensions of an array.
		
		Parameters
		----------
		a : array_like
		    Input array.
		axes : list of ints, optional
		    By default, reverse the dimensions, otherwise permute the axes
		    according to the values given.
		
		Returns
		-------
		p : ndarray
		    `a` with its axes permuted.  A view is returned whenever
		    possible.
		
		See Also
		--------
		moveaxis
		argsort
		
		Notes
		-----
		Use `transpose(a, argsort(axes))` to invert the transposition of tensors
		when using the `axes` keyword argument.
		
		Transposing a 1-D array returns an unchanged view of the original array.
		
		Examples
		--------
		>>> x = np.arange(4).reshape((2,2))
		>>> x
		array([[0, 1],
		       [2, 3]])
		
		>>> np.transpose(x)
		array([[0, 2],
		       [1, 3]])
		
		>>> x = np.ones((1, 2, 3))
		>>> np.transpose(x, (1, 0, 2)).shape
		(2, 1, 3)
	**/
	static public function transpose(a:Dynamic, ?axes:Dynamic):Dynamic;
	/**
		Integrate along the given axis using the composite trapezoidal rule.
		
		Integrate `y` (`x`) along given axis.
		
		Parameters
		----------
		y : array_like
		    Input array to integrate.
		x : array_like, optional
		    The sample points corresponding to the `y` values. If `x` is None,
		    the sample points are assumed to be evenly spaced `dx` apart. The
		    default is None.
		dx : scalar, optional
		    The spacing between sample points when `x` is None. The default is 1.
		axis : int, optional
		    The axis along which to integrate.
		
		Returns
		-------
		trapz : float
		    Definite integral as approximated by trapezoidal rule.
		
		See Also
		--------
		sum, cumsum
		
		Notes
		-----
		Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
		will be taken from `y` array, by default x-axis distances between
		points will be 1.0, alternatively they can be provided with `x` array
		or with `dx` scalar.  Return value will be equal to combined area under
		the red lines.
		
		
		References
		----------
		.. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule
		
		.. [2] Illustration image:
		       https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png
		
		Examples
		--------
		>>> np.trapz([1,2,3])
		4.0
		>>> np.trapz([1,2,3], x=[4,6,8])
		8.0
		>>> np.trapz([1,2,3], dx=2)
		8.0
		>>> a = np.arange(6).reshape(2, 3)
		>>> a
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.trapz(a, axis=0)
		array([ 1.5,  2.5,  3.5])
		>>> np.trapz(a, axis=1)
		array([ 2.,  8.])
	**/
	static public function trapz(y:Dynamic, ?x:Dynamic, ?dx:Dynamic, ?axis:Dynamic):Float;
	/**
		An array with ones at and below the given diagonal and zeros elsewhere.
		
		Parameters
		----------
		N : int
		    Number of rows in the array.
		M : int, optional
		    Number of columns in the array.
		    By default, `M` is taken equal to `N`.
		k : int, optional
		    The sub-diagonal at and below which the array is filled.
		    `k` = 0 is the main diagonal, while `k` < 0 is below it,
		    and `k` > 0 is above.  The default is 0.
		dtype : dtype, optional
		    Data type of the returned array.  The default is float.
		
		Returns
		-------
		tri : ndarray of shape (N, M)
		    Array with its lower triangle filled with ones and zero elsewhere;
		    in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise.
		
		Examples
		--------
		>>> np.tri(3, 5, 2, dtype=int)
		array([[1, 1, 1, 0, 0],
		       [1, 1, 1, 1, 0],
		       [1, 1, 1, 1, 1]])
		
		>>> np.tri(3, 5, -1)
		array([[ 0.,  0.,  0.,  0.,  0.],
		       [ 1.,  0.,  0.,  0.,  0.],
		       [ 1.,  1.,  0.,  0.,  0.]])
	**/
	static public function tri(N:Dynamic, ?M:Dynamic, ?k:Dynamic, ?dtype:Dynamic):Dynamic;
	/**
		triangular(left, mode, right, size=None)
		
		Draw samples from the triangular distribution over the
		interval ``[left, right]``.
		
		The triangular distribution is a continuous probability
		distribution with lower limit left, peak at mode, and upper
		limit right. Unlike the other distributions, these parameters
		directly define the shape of the pdf.
		
		Parameters
		----------
		left : float or array_like of floats
		    Lower limit.
		mode : float or array_like of floats
		    The value where the peak of the distribution occurs.
		    The value should fulfill the condition ``left <= mode <= right``.
		right : float or array_like of floats
		    Upper limit, should be larger than `left`.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``left``, ``mode``, and ``right``
		    are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``
		    samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized triangular distribution.
		
		Notes
		-----
		The probability density function for the triangular distribution is
		
		.. math:: P(x;l, m, r) = \begin{cases}
		          \frac{2(x-l)}{(r-l)(m-l)}& \text{for $l \leq x \leq m$},\\
		          \frac{2(r-x)}{(r-l)(r-m)}& \text{for $m \leq x \leq r$},\\
		          0& \text{otherwise}.
		          \end{cases}
		
		The triangular distribution is often used in ill-defined
		problems where the underlying distribution is not known, but
		some knowledge of the limits and mode exists. Often it is used
		in simulations.
		
		References
		----------
		.. [1] Wikipedia, "Triangular distribution"
		       https://en.wikipedia.org/wiki/Triangular_distribution
		
		Examples
		--------
		Draw values from the distribution and plot the histogram:
		
		>>> import matplotlib.pyplot as plt
		>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
		...              density=True)
		>>> plt.show()
	**/
	static public function triangular(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Draw contours on an unstructured triangular grid.
		
		`.tricontour` and `.tricontourf` draw contour lines and filled contours,
		respectively.  Except as noted, function signatures and return values are
		the same for both versions.
		
		The triangulation can be specified in one of two ways; either ::
		
		    tricontour(triangulation, ...)
		
		where *triangulation* is a `matplotlib.tri.Triangulation` object, or ::
		
		    tricontour(x, y, ...)
		    tricontour(x, y, triangles, ...)
		    tricontour(x, y, triangles=triangles, ...)
		    tricontour(x, y, mask=mask, ...)
		    tricontour(x, y, triangles, mask=mask, ...)
		
		in which case a `.Triangulation` object will be created.  See that class'
		docstring for an explanation of these cases.
		
		The remaining arguments may be::
		
		    tricontour(..., Z)
		
		where *Z* is the array of values to contour, one per point in the
		triangulation.  The level values are chosen automatically.
		
		::
		
		    tricontour(..., Z, N)
		
		contour up to *N+1* automatically chosen contour levels (*N* intervals).
		
		::
		
		    tricontour(..., Z, V)
		
		draw contour lines at the values specified in sequence *V*,
		which must be in increasing order.
		
		::
		
		    tricontourf(..., Z, V)
		
		fill the (len(*V*)-1) regions between the values in *V*,
		which must be in increasing order.
		
		::
		
		    tricontour(Z, **kwargs)
		
		Use keyword args to control colors, linewidth, origin, cmap ... see
		below for more details.
		
		`.tricontour(...)` returns a `~matplotlib.contour.TriContourSet` object.
		
		Optional keyword arguments:
		
		    *colors*: [ *None* | string | (mpl_colors) ]
		    If *None*, the colormap specified by cmap will be used.
		
		    If a string, like 'r' or 'red', all levels will be plotted in this
		    color.
		
		    If a tuple of matplotlib color args (string, float, rgb, etc),
		    different levels will be plotted in different colors in the order
		    specified.
		
		    *alpha*: float
		    The alpha blending value
		
		    *cmap*: [ *None* | Colormap ]
		    A cm :class:`~matplotlib.colors.Colormap` instance or
		    *None*. If *cmap* is *None* and *colors* is *None*, a
		    default Colormap is used.
		
		    *norm*: [ *None* | Normalize ]
		    A :class:`matplotlib.colors.Normalize` instance for
		    scaling data values to colors. If *norm* is *None* and
		    *colors* is *None*, the default linear scaling is used.
		
		    *levels* [level0, level1, ..., leveln]
		    A list of floating point numbers indicating the level
		    curves to draw, in increasing order; e.g., to draw just
		    the zero contour pass ``levels=[0]``
		
		    *origin*: [ *None* | 'upper' | 'lower' | 'image' ]
		    If *None*, the first value of *Z* will correspond to the
		    lower left corner, location (0,0). If 'image', the rc
		    value for ``image.origin`` will be used.
		
		    This keyword is not active if *X* and *Y* are specified in
		    the call to contour.
		
		    *extent*: [ *None* | (x0,x1,y0,y1) ]
		
		    If *origin* is not *None*, then *extent* is interpreted as
		    in :func:`matplotlib.pyplot.imshow`: it gives the outer
		    pixel boundaries. In this case, the position of Z[0,0]
		    is the center of the pixel, not a corner. If *origin* is
		    *None*, then (*x0*, *y0*) is the position of Z[0,0], and
		    (*x1*, *y1*) is the position of Z[-1,-1].
		
		    This keyword is not active if *X* and *Y* are specified in
		    the call to contour.
		
		    *locator*: [ *None* | ticker.Locator subclass ]
		    If *locator* is None, the default
		    :class:`~matplotlib.ticker.MaxNLocator` is used. The
		    locator is used to determine the contour levels if they
		    are not given explicitly via the *V* argument.
		
		    *extend*: [ 'neither' | 'both' | 'min' | 'max' ]
		    Unless this is 'neither', contour levels are automatically
		    added to one or both ends of the range so that all data
		    are included. These added ranges are then mapped to the
		    special colormap values which default to the ends of the
		    colormap range, but can be set via
		    :meth:`matplotlib.colors.Colormap.set_under` and
		    :meth:`matplotlib.colors.Colormap.set_over` methods.
		
		    *xunits*, *yunits*: [ *None* | registered units ]
		    Override axis units by specifying an instance of a
		    :class:`matplotlib.units.ConversionInterface`.
		
		tricontour-only keyword arguments:
		
		    *linewidths*: [ *None* | number | tuple of numbers ]
		    If *linewidths* is *None*, defaults to rc:`lines.linewidth`.
		
		    If a number, all levels will be plotted with this linewidth.
		
		    If a tuple, different levels will be plotted with different
		    linewidths in the order specified
		
		    *linestyles*: [ *None* | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]
		    If *linestyles* is *None*, the 'solid' is used.
		
		    *linestyles* can also be an iterable of the above strings
		    specifying a set of linestyles to be used. If this
		    iterable is shorter than the number of contour levels
		    it will be repeated as necessary.
		
		    If contour is using a monochrome colormap and the contour
		    level is less than 0, then the linestyle specified
		    in :rc:`contour.negative_linestyle` will be used.
		
		tricontourf-only keyword arguments:
		
		    *antialiased*: bool
		    enable antialiasing
		
		Note: `.tricontourf` fills intervals that are closed at the top; that is,
		for boundaries *z1* and *z2*, the filled region is::
		
		    z1 < Z <= z2
		
		except for the lowest interval, which is closed on both sides (i.e. it
		includes the lowest value).
	**/
	static public function tricontour(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Draw contours on an unstructured triangular grid.
		
		`.tricontour` and `.tricontourf` draw contour lines and filled contours,
		respectively.  Except as noted, function signatures and return values are
		the same for both versions.
		
		The triangulation can be specified in one of two ways; either ::
		
		    tricontour(triangulation, ...)
		
		where *triangulation* is a `matplotlib.tri.Triangulation` object, or ::
		
		    tricontour(x, y, ...)
		    tricontour(x, y, triangles, ...)
		    tricontour(x, y, triangles=triangles, ...)
		    tricontour(x, y, mask=mask, ...)
		    tricontour(x, y, triangles, mask=mask, ...)
		
		in which case a `.Triangulation` object will be created.  See that class'
		docstring for an explanation of these cases.
		
		The remaining arguments may be::
		
		    tricontour(..., Z)
		
		where *Z* is the array of values to contour, one per point in the
		triangulation.  The level values are chosen automatically.
		
		::
		
		    tricontour(..., Z, N)
		
		contour up to *N+1* automatically chosen contour levels (*N* intervals).
		
		::
		
		    tricontour(..., Z, V)
		
		draw contour lines at the values specified in sequence *V*,
		which must be in increasing order.
		
		::
		
		    tricontourf(..., Z, V)
		
		fill the (len(*V*)-1) regions between the values in *V*,
		which must be in increasing order.
		
		::
		
		    tricontour(Z, **kwargs)
		
		Use keyword args to control colors, linewidth, origin, cmap ... see
		below for more details.
		
		`.tricontour(...)` returns a `~matplotlib.contour.TriContourSet` object.
		
		Optional keyword arguments:
		
		    *colors*: [ *None* | string | (mpl_colors) ]
		    If *None*, the colormap specified by cmap will be used.
		
		    If a string, like 'r' or 'red', all levels will be plotted in this
		    color.
		
		    If a tuple of matplotlib color args (string, float, rgb, etc),
		    different levels will be plotted in different colors in the order
		    specified.
		
		    *alpha*: float
		    The alpha blending value
		
		    *cmap*: [ *None* | Colormap ]
		    A cm :class:`~matplotlib.colors.Colormap` instance or
		    *None*. If *cmap* is *None* and *colors* is *None*, a
		    default Colormap is used.
		
		    *norm*: [ *None* | Normalize ]
		    A :class:`matplotlib.colors.Normalize` instance for
		    scaling data values to colors. If *norm* is *None* and
		    *colors* is *None*, the default linear scaling is used.
		
		    *levels* [level0, level1, ..., leveln]
		    A list of floating point numbers indicating the level
		    curves to draw, in increasing order; e.g., to draw just
		    the zero contour pass ``levels=[0]``
		
		    *origin*: [ *None* | 'upper' | 'lower' | 'image' ]
		    If *None*, the first value of *Z* will correspond to the
		    lower left corner, location (0,0). If 'image', the rc
		    value for ``image.origin`` will be used.
		
		    This keyword is not active if *X* and *Y* are specified in
		    the call to contour.
		
		    *extent*: [ *None* | (x0,x1,y0,y1) ]
		
		    If *origin* is not *None*, then *extent* is interpreted as
		    in :func:`matplotlib.pyplot.imshow`: it gives the outer
		    pixel boundaries. In this case, the position of Z[0,0]
		    is the center of the pixel, not a corner. If *origin* is
		    *None*, then (*x0*, *y0*) is the position of Z[0,0], and
		    (*x1*, *y1*) is the position of Z[-1,-1].
		
		    This keyword is not active if *X* and *Y* are specified in
		    the call to contour.
		
		    *locator*: [ *None* | ticker.Locator subclass ]
		    If *locator* is None, the default
		    :class:`~matplotlib.ticker.MaxNLocator` is used. The
		    locator is used to determine the contour levels if they
		    are not given explicitly via the *V* argument.
		
		    *extend*: [ 'neither' | 'both' | 'min' | 'max' ]
		    Unless this is 'neither', contour levels are automatically
		    added to one or both ends of the range so that all data
		    are included. These added ranges are then mapped to the
		    special colormap values which default to the ends of the
		    colormap range, but can be set via
		    :meth:`matplotlib.colors.Colormap.set_under` and
		    :meth:`matplotlib.colors.Colormap.set_over` methods.
		
		    *xunits*, *yunits*: [ *None* | registered units ]
		    Override axis units by specifying an instance of a
		    :class:`matplotlib.units.ConversionInterface`.
		
		tricontour-only keyword arguments:
		
		    *linewidths*: [ *None* | number | tuple of numbers ]
		    If *linewidths* is *None*, defaults to rc:`lines.linewidth`.
		
		    If a number, all levels will be plotted with this linewidth.
		
		    If a tuple, different levels will be plotted with different
		    linewidths in the order specified
		
		    *linestyles*: [ *None* | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]
		    If *linestyles* is *None*, the 'solid' is used.
		
		    *linestyles* can also be an iterable of the above strings
		    specifying a set of linestyles to be used. If this
		    iterable is shorter than the number of contour levels
		    it will be repeated as necessary.
		
		    If contour is using a monochrome colormap and the contour
		    level is less than 0, then the linestyle specified
		    in :rc:`contour.negative_linestyle` will be used.
		
		tricontourf-only keyword arguments:
		
		    *antialiased*: bool
		    enable antialiasing
		
		Note: `.tricontourf` fills intervals that are closed at the top; that is,
		for boundaries *z1* and *z2*, the filled region is::
		
		    z1 < Z <= z2
		
		except for the lowest interval, which is closed on both sides (i.e. it
		includes the lowest value).
	**/
	static public function tricontourf(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Lower triangle of an array.
		
		Return a copy of an array with elements above the `k`-th diagonal zeroed.
		
		Parameters
		----------
		m : array_like, shape (M, N)
		    Input array.
		k : int, optional
		    Diagonal above which to zero elements.  `k = 0` (the default) is the
		    main diagonal, `k < 0` is below it and `k > 0` is above.
		
		Returns
		-------
		tril : ndarray, shape (M, N)
		    Lower triangle of `m`, of same shape and data-type as `m`.
		
		See Also
		--------
		triu : same thing, only for the upper triangle
		
		Examples
		--------
		>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
		array([[ 0,  0,  0],
		       [ 4,  0,  0],
		       [ 7,  8,  0],
		       [10, 11, 12]])
	**/
	static public function tril(m:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Return the indices for the lower-triangle of an (n, m) array.
		
		Parameters
		----------
		n : int
		    The row dimension of the arrays for which the returned
		    indices will be valid.
		k : int, optional
		    Diagonal offset (see `tril` for details).
		m : int, optional
		    .. versionadded:: 1.9.0
		
		    The column dimension of the arrays for which the returned
		    arrays will be valid.
		    By default `m` is taken equal to `n`.
		
		
		Returns
		-------
		inds : tuple of arrays
		    The indices for the triangle. The returned tuple contains two arrays,
		    each with the indices along one dimension of the array.
		
		See also
		--------
		triu_indices : similar function, for upper-triangular.
		mask_indices : generic function accepting an arbitrary mask function.
		tril, triu
		
		Notes
		-----
		.. versionadded:: 1.4.0
		
		Examples
		--------
		Compute two different sets of indices to access 4x4 arrays, one for the
		lower triangular part starting at the main diagonal, and one starting two
		diagonals further right:
		
		>>> il1 = np.tril_indices(4)
		>>> il2 = np.tril_indices(4, 2)
		
		Here is how they can be used with a sample array:
		
		>>> a = np.arange(16).reshape(4, 4)
		>>> a
		array([[ 0,  1,  2,  3],
		       [ 4,  5,  6,  7],
		       [ 8,  9, 10, 11],
		       [12, 13, 14, 15]])
		
		Both for indexing:
		
		>>> a[il1]
		array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])
		
		And for assigning values:
		
		>>> a[il1] = -1
		>>> a
		array([[-1,  1,  2,  3],
		       [-1, -1,  6,  7],
		       [-1, -1, -1, 11],
		       [-1, -1, -1, -1]])
		
		These cover almost the whole array (two diagonals right of the main one):
		
		>>> a[il2] = -10
		>>> a
		array([[-10, -10, -10,   3],
		       [-10, -10, -10, -10],
		       [-10, -10, -10, -10],
		       [-10, -10, -10, -10]])
	**/
	static public function tril_indices(n:Dynamic, ?k:Dynamic, ?m:Dynamic):Dynamic;
	/**
		Return the indices for the lower-triangle of arr.
		
		See `tril_indices` for full details.
		
		Parameters
		----------
		arr : array_like
		    The indices will be valid for square arrays whose dimensions are
		    the same as arr.
		k : int, optional
		    Diagonal offset (see `tril` for details).
		
		See Also
		--------
		tril_indices, tril
		
		Notes
		-----
		.. versionadded:: 1.4.0
	**/
	static public function tril_indices_from(arr:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Trim the leading and/or trailing zeros from a 1-D array or sequence.
		
		Parameters
		----------
		filt : 1-D array or sequence
		    Input array.
		trim : str, optional
		    A string with 'f' representing trim from front and 'b' to trim from
		    back. Default is 'fb', trim zeros from both front and back of the
		    array.
		
		Returns
		-------
		trimmed : 1-D array or sequence
		    The result of trimming the input. The input data type is preserved.
		
		Examples
		--------
		>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
		>>> np.trim_zeros(a)
		array([1, 2, 3, 0, 2, 1])
		
		>>> np.trim_zeros(a, 'b')
		array([0, 0, 0, 1, 2, 3, 0, 2, 1])
		
		The input data type is preserved, list/tuple in means list/tuple out.
		
		>>> np.trim_zeros([0, 1, 2, 0])
		[1, 2]
	**/
	static public function trim_zeros(filt:Dynamic, ?trim:Dynamic):Dynamic;
	/**
		Create a pseudocolor plot of an unstructured triangular grid.
		
		The triangulation can be specified in one of two ways; either::
		
		  tripcolor(triangulation, ...)
		
		where triangulation is a :class:`matplotlib.tri.Triangulation`
		object, or
		
		::
		
		  tripcolor(x, y, ...)
		  tripcolor(x, y, triangles, ...)
		  tripcolor(x, y, triangles=triangles, ...)
		  tripcolor(x, y, mask=mask, ...)
		  tripcolor(x, y, triangles, mask=mask, ...)
		
		in which case a Triangulation object will be created.  See
		:class:`~matplotlib.tri.Triangulation` for a explanation of these
		possibilities.
		
		The next argument must be *C*, the array of color values, either
		one per point in the triangulation if color values are defined at
		points, or one per triangle in the triangulation if color values
		are defined at triangles. If there are the same number of points
		and triangles in the triangulation it is assumed that color
		values are defined at points; to force the use of color values at
		triangles use the kwarg ``facecolors=C`` instead of just ``C``.
		
		*shading* may be 'flat' (the default) or 'gouraud'. If *shading*
		is 'flat' and C values are defined at points, the color values
		used for each triangle are from the mean C of the triangle's
		three points. If *shading* is 'gouraud' then color values must be
		defined at points.
		
		The remaining kwargs are the same as for
		:meth:`~matplotlib.axes.Axes.pcolor`.
	**/
	static public function tripcolor(?args:python.VarArgs<Dynamic>, ?alpha:Dynamic, ?norm:Dynamic, ?cmap:Dynamic, ?vmin:Dynamic, ?vmax:Dynamic, ?shading:Dynamic, ?facecolors:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Draw a unstructured triangular grid as lines and/or markers.
		
		The triangulation to plot can be specified in one of two ways;
		either::
		
		  triplot(triangulation, ...)
		
		where triangulation is a :class:`matplotlib.tri.Triangulation`
		object, or
		
		::
		
		  triplot(x, y, ...)
		  triplot(x, y, triangles, ...)
		  triplot(x, y, triangles=triangles, ...)
		  triplot(x, y, mask=mask, ...)
		  triplot(x, y, triangles, mask=mask, ...)
		
		in which case a Triangulation object will be created.  See
		:class:`~matplotlib.tri.Triangulation` for a explanation of these
		possibilities.
		
		The remaining args and kwargs are the same as for
		:meth:`~matplotlib.axes.Axes.plot`.
		
		Return a list of 2 :class:`~matplotlib.lines.Line2D` containing
		respectively:
		
		    - the lines plotted for triangles edges
		    - the markers plotted for triangles nodes
	**/
	static public function triplot(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Upper triangle of an array.
		
		Return a copy of a matrix with the elements below the `k`-th diagonal
		zeroed.
		
		Please refer to the documentation for `tril` for further details.
		
		See Also
		--------
		tril : lower triangle of an array
		
		Examples
		--------
		>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
		array([[ 1,  2,  3],
		       [ 4,  5,  6],
		       [ 0,  8,  9],
		       [ 0,  0, 12]])
	**/
	static public function triu(m:Dynamic, ?k:Dynamic):Dynamic;
	/**
		Return the indices for the upper-triangle of an (n, m) array.
		
		Parameters
		----------
		n : int
		    The size of the arrays for which the returned indices will
		    be valid.
		k : int, optional
		    Diagonal offset (see `triu` for details).
		m : int, optional
		    .. versionadded:: 1.9.0
		
		    The column dimension of the arrays for which the returned
		    arrays will be valid.
		    By default `m` is taken equal to `n`.
		
		
		Returns
		-------
		inds : tuple, shape(2) of ndarrays, shape(`n`)
		    The indices for the triangle. The returned tuple contains two arrays,
		    each with the indices along one dimension of the array.  Can be used
		    to slice a ndarray of shape(`n`, `n`).
		
		See also
		--------
		tril_indices : similar function, for lower-triangular.
		mask_indices : generic function accepting an arbitrary mask function.
		triu, tril
		
		Notes
		-----
		.. versionadded:: 1.4.0
		
		Examples
		--------
		Compute two different sets of indices to access 4x4 arrays, one for the
		upper triangular part starting at the main diagonal, and one starting two
		diagonals further right:
		
		>>> iu1 = np.triu_indices(4)
		>>> iu2 = np.triu_indices(4, 2)
		
		Here is how they can be used with a sample array:
		
		>>> a = np.arange(16).reshape(4, 4)
		>>> a
		array([[ 0,  1,  2,  3],
		       [ 4,  5,  6,  7],
		       [ 8,  9, 10, 11],
		       [12, 13, 14, 15]])
		
		Both for indexing:
		
		>>> a[iu1]
		array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])
		
		And for assigning values:
		
		>>> a[iu1] = -1
		>>> a
		array([[-1, -1, -1, -1],
		       [ 4, -1, -1, -1],
		       [ 8,  9, -1, -1],
		       [12, 13, 14, -1]])
		
		These cover only a small part of the whole array (two diagonals right
		of the main one):
		
		>>> a[iu2] = -10
		>>> a
		array([[ -1,  -1, -10, -10],
		       [  4,  -1,  -1, -10],
		       [  8,   9,  -1,  -1],
		       [ 12,  13,  14,  -1]])
	**/
	static public function triu_indices(n:Dynamic, ?k:Dynamic, ?m:Dynamic):Dynamic;
	/**
		Return the indices for the upper-triangle of arr.
		
		See `triu_indices` for full details.
		
		Parameters
		----------
		arr : ndarray, shape(N, N)
		    The indices will be valid for square arrays.
		k : int, optional
		    Diagonal offset (see `triu` for details).
		
		Returns
		-------
		triu_indices_from : tuple, shape(2) of ndarray, shape(N)
		    Indices for the upper-triangle of `arr`.
		
		See Also
		--------
		triu_indices, triu
		
		Notes
		-----
		.. versionadded:: 1.4.0
	**/
	static public function triu_indices_from(arr:Dynamic, ?k:Dynamic):Dynamic;
	/**
		true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Returns a true division of the inputs, element-wise.
		
		Instead of the Python traditional 'floor division', this returns a true
		division.  True division adjusts the output type to present the best
		answer, regardless of input types.
		
		Parameters
		----------
		x1 : array_like
		    Dividend array.
		x2 : array_like
		    Divisor array.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		out : ndarray or scalar
		    This is a scalar if both `x1` and `x2` are scalars.
		
		Notes
		-----
		The floor division operator ``//`` was added in Python 2.2 making
		``//`` and ``/`` equivalent operators.  The default floor division
		operation of ``/`` can be replaced by true division with ``from
		__future__ import division``.
		
		In Python 3.0, ``//`` is the floor division operator and ``/`` the
		true division operator.  The ``true_divide(x1, x2)`` function is
		equivalent to true division in Python.
		
		Examples
		--------
		>>> x = np.arange(5)
		>>> np.true_divide(x, 4)
		array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
		
		>>> x/4
		array([0, 0, 0, 0, 1])
		>>> x//4
		array([0, 0, 0, 0, 1])
		
		>>> from __future__ import division
		>>> x/4
		array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
		>>> x//4
		array([0, 0, 0, 0, 1])
	**/
	static public function true_divide(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
		
		Return the truncated value of the input, element-wise.
		
		The truncated value of the scalar `x` is the nearest integer `i` which
		is closer to zero than `x` is. In short, the fractional part of the
		signed number `x` is discarded.
		
		Parameters
		----------
		x : array_like
		    Input data.
		out : ndarray, None, or tuple of ndarray and None, optional
		    A location into which the result is stored. If provided, it must have
		    a shape that the inputs broadcast to. If not provided or `None`,
		    a freshly-allocated array is returned. A tuple (possible only as a
		    keyword argument) must have length equal to the number of outputs.
		where : array_like, optional
		    Values of True indicate to calculate the ufunc at that position, values
		    of False indicate to leave the value in the output alone.
		**kwargs
		    For other keyword-only arguments, see the
		    :ref:`ufunc docs <ufuncs.kwargs>`.
		
		Returns
		-------
		y : ndarray or scalar
		    The truncated value of each element in `x`.
		    This is a scalar if `x` is a scalar.
		
		See Also
		--------
		ceil, floor, rint
		
		Notes
		-----
		.. versionadded:: 1.3.0
		
		Examples
		--------
		>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
		>>> np.trunc(a)
		array([-1., -1., -0.,  0.,  1.,  1.,  2.])
	**/
	static public function trunc(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Make and return a second axes that shares the *x*-axis.  The new axes will
		overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
		on the right.
		
		Examples
		--------
		:doc:`/gallery/subplots_axes_and_figures/two_scales`
	**/
	static public function twinx(?ax:Dynamic):Dynamic;
	/**
		Make and return a second axes that shares the *y*-axis.  The new axes will
		overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
		on the top.
		
		Examples
		--------
		:doc:`/gallery/subplots_axes_and_figures/two_scales`
	**/
	static public function twiny(?ax:Dynamic):Dynamic;
	static public var typeDict : Dynamic;
	static public var typeNA : Dynamic;
	static public var typecodes : Dynamic;
	/**
		Return a description for the given data type code.
		
		Parameters
		----------
		char : str
		    Data type code.
		
		Returns
		-------
		out : str
		    Description of the input data type code.
		
		See Also
		--------
		dtype, typecodes
		
		Examples
		--------
		>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
		...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
		>>> for typechar in typechars:
		...     print(typechar, ' : ', np.typename(typechar))
		...
		S1  :  character
		?  :  bool
		B  :  unsigned char
		D  :  complex double precision
		G  :  complex long double precision
		F  :  complex single precision
		I  :  unsigned integer
		H  :  unsigned short
		L  :  unsigned long integer
		O  :  object
		Q  :  unsigned long long integer
		S  :  string
		U  :  unicode
		V  :  void
		b  :  signed char
		d  :  double precision
		g  :  long precision
		f  :  single precision
		i  :  integer
		h  :  short
		l  :  long integer
		q  :  long long integer
	**/
	static public function typename(char:Dynamic):String;
	/**
		uniform(low=0.0, high=1.0, size=None)
		
		Draw samples from a uniform distribution.
		
		Samples are uniformly distributed over the half-open interval
		``[low, high)`` (includes low, but excludes high).  In other words,
		any value within the given interval is equally likely to be drawn
		by `uniform`.
		
		Parameters
		----------
		low : float or array_like of floats, optional
		    Lower boundary of the output interval.  All values generated will be
		    greater than or equal to low.  The default value is 0.
		high : float or array_like of floats
		    Upper boundary of the output interval.  All values generated will be
		    less than high.  The default value is 1.0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``low`` and ``high`` are both scalars.
		    Otherwise, ``np.broadcast(low, high).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized uniform distribution.
		
		See Also
		--------
		randint : Discrete uniform distribution, yielding integers.
		random_integers : Discrete uniform distribution over the closed
		                  interval ``[low, high]``.
		random_sample : Floats uniformly distributed over ``[0, 1)``.
		random : Alias for `random_sample`.
		rand : Convenience function that accepts dimensions as input, e.g.,
		       ``rand(2,2)`` would generate a 2-by-2 array of floats,
		       uniformly distributed over ``[0, 1)``.
		
		Notes
		-----
		The probability density function of the uniform distribution is
		
		.. math:: p(x) = \frac{1}{b - a}
		
		anywhere within the interval ``[a, b)``, and zero elsewhere.
		
		When ``high`` == ``low``, values of ``low`` will be returned.
		If ``high`` < ``low``, the results are officially undefined
		and may eventually raise an error, i.e. do not rely on this
		function to behave when passed arguments satisfying that
		inequality condition.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> s = np.random.uniform(-1,0,1000)
		
		All values are within the given interval:
		
		>>> np.all(s >= -1)
		True
		>>> np.all(s < 0)
		True
		
		Display the histogram of the samples, along with the
		probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> count, bins, ignored = plt.hist(s, 15, density=True)
		>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function uniform(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Uninstall the matplotlib display hook.
		
		.. warning
		
		   Need IPython >= 2 for this to work.  For IPython < 2 will raise a
		   ``NotImplementedError``
		
		.. warning
		
		   If you are using vanilla python and have installed another
		   display hook this will reset ``sys.displayhook`` to what ever
		   function was there when matplotlib installed it's displayhook,
		   possibly discarding your changes.
	**/
	static public function uninstall_repl_displayhook():Dynamic;
	/**
		Find the union of two arrays.
		
		Return the unique, sorted array of values that are in either of the two
		input arrays.
		
		Parameters
		----------
		ar1, ar2 : array_like
		    Input arrays. They are flattened if they are not already 1D.
		
		Returns
		-------
		union1d : ndarray
		    Unique, sorted union of the input arrays.
		
		See Also
		--------
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Examples
		--------
		>>> np.union1d([-1, 0, 1], [-2, 0, 2])
		array([-2, -1,  0,  1,  2])
		
		To find the union of more than two arrays, use functools.reduce:
		
		>>> from functools import reduce
		>>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
		array([1, 2, 3, 4, 6])
	**/
	static public function union1d(ar1:Dynamic, ar2:Dynamic):Dynamic;
	/**
		Find the unique elements of an array.
		
		Returns the sorted unique elements of an array. There are three optional
		outputs in addition to the unique elements:
		
		* the indices of the input array that give the unique values
		* the indices of the unique array that reconstruct the input array
		* the number of times each unique value comes up in the input array
		
		Parameters
		----------
		ar : array_like
		    Input array. Unless `axis` is specified, this will be flattened if it
		    is not already 1-D.
		return_index : bool, optional
		    If True, also return the indices of `ar` (along the specified axis,
		    if provided, or in the flattened array) that result in the unique array.
		return_inverse : bool, optional
		    If True, also return the indices of the unique array (for the specified
		    axis, if provided) that can be used to reconstruct `ar`.
		return_counts : bool, optional
		    If True, also return the number of times each unique item appears
		    in `ar`.
		
		    .. versionadded:: 1.9.0
		
		axis : int or None, optional
		    The axis to operate on. If None, `ar` will be flattened. If an integer,
		    the subarrays indexed by the given axis will be flattened and treated
		    as the elements of a 1-D array with the dimension of the given axis,
		    see the notes for more details.  Object arrays or structured arrays
		    that contain objects are not supported if the `axis` kwarg is used. The
		    default is None.
		
		    .. versionadded:: 1.13.0
		
		Returns
		-------
		unique : ndarray
		    The sorted unique values.
		unique_indices : ndarray, optional
		    The indices of the first occurrences of the unique values in the
		    original array. Only provided if `return_index` is True.
		unique_inverse : ndarray, optional
		    The indices to reconstruct the original array from the
		    unique array. Only provided if `return_inverse` is True.
		unique_counts : ndarray, optional
		    The number of times each of the unique values comes up in the
		    original array. Only provided if `return_counts` is True.
		
		    .. versionadded:: 1.9.0
		
		See Also
		--------
		numpy.lib.arraysetops : Module with a number of other functions for
		                        performing set operations on arrays.
		
		Notes
		-----
		When an axis is specified the subarrays indexed by the axis are sorted.
		This is done by making the specified axis the first dimension of the array
		and then flattening the subarrays in C order. The flattened subarrays are
		then viewed as a structured type with each element given a label, with the
		effect that we end up with a 1-D array of structured types that can be
		treated in the same way as any other 1-D array. The result is that the
		flattened subarrays are sorted in lexicographic order starting with the
		first element.
		
		Examples
		--------
		>>> np.unique([1, 1, 2, 2, 3, 3])
		array([1, 2, 3])
		>>> a = np.array([[1, 1], [2, 3]])
		>>> np.unique(a)
		array([1, 2, 3])
		
		Return the unique rows of a 2D array
		
		>>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
		>>> np.unique(a, axis=0)
		array([[1, 0, 0], [2, 3, 4]])
		
		Return the indices of the original array that give the unique values:
		
		>>> a = np.array(['a', 'b', 'b', 'c', 'a'])
		>>> u, indices = np.unique(a, return_index=True)
		>>> u
		array(['a', 'b', 'c'],
		       dtype='|S1')
		>>> indices
		array([0, 1, 3])
		>>> a[indices]
		array(['a', 'b', 'c'],
		       dtype='|S1')
		
		Reconstruct the input array from the unique values:
		
		>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
		>>> u, indices = np.unique(a, return_inverse=True)
		>>> u
		array([1, 2, 3, 4, 6])
		>>> indices
		array([0, 1, 4, 3, 1, 2, 1])
		>>> u[indices]
		array([1, 2, 6, 4, 2, 3, 2])
	**/
	static public function unique(ar:Dynamic, ?return_index:Dynamic, ?return_inverse:Dynamic, ?return_counts:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		unpackbits(myarray, axis=None)
		
		Unpacks elements of a uint8 array into a binary-valued output array.
		
		Each element of `myarray` represents a bit-field that should be unpacked
		into a binary-valued output array. The shape of the output array is either
		1-D (if `axis` is None) or the same shape as the input array with unpacking
		done along the axis specified.
		
		Parameters
		----------
		myarray : ndarray, uint8 type
		   Input array.
		axis : int, optional
		    The dimension over which bit-unpacking is done.
		    ``None`` implies unpacking the flattened array.
		
		Returns
		-------
		unpacked : ndarray, uint8 type
		   The elements are binary-valued (0 or 1).
		
		See Also
		--------
		packbits : Packs the elements of a binary-valued array into bits in a uint8
		           array.
		
		Examples
		--------
		>>> a = np.array([[2], [7], [23]], dtype=np.uint8)
		>>> a
		array([[ 2],
		       [ 7],
		       [23]], dtype=uint8)
		>>> b = np.unpackbits(a, axis=1)
		>>> b
		array([[0, 0, 0, 0, 0, 0, 1, 0],
		       [0, 0, 0, 0, 0, 1, 1, 1],
		       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
	**/
	static public function unpackbits(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		unravel_index(indices, shape, order='C')
		
		Converts a flat index or array of flat indices into a tuple
		of coordinate arrays.
		
		Parameters
		----------
		indices : array_like
		    An integer array whose elements are indices into the flattened
		    version of an array of dimensions ``shape``. Before version 1.6.0,
		    this function accepted just one index value.
		shape : tuple of ints
		    The shape of the array to use for unraveling ``indices``.
		
		    .. versionchanged:: 1.16.0
		        Renamed from ``dims`` to ``shape``.
		
		order : {'C', 'F'}, optional
		    Determines whether the indices should be viewed as indexing in
		    row-major (C-style) or column-major (Fortran-style) order.
		
		    .. versionadded:: 1.6.0
		
		Returns
		-------
		unraveled_coords : tuple of ndarray
		    Each array in the tuple has the same shape as the ``indices``
		    array.
		
		See Also
		--------
		ravel_multi_index
		
		Examples
		--------
		>>> np.unravel_index([22, 41, 37], (7,6))
		(array([3, 6, 6]), array([4, 5, 1]))
		>>> np.unravel_index([31, 41, 13], (7,6), order='F')
		(array([3, 6, 6]), array([4, 5, 1]))
		
		>>> np.unravel_index(1621, (6,7,8,9))
		(3, 1, 4, 1)
	**/
	static public function unravel_index(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Unwrap by changing deltas between values to 2*pi complement.
		
		Unwrap radian phase `p` by changing absolute jumps greater than
		`discont` to their 2*pi complement along the given axis.
		
		Parameters
		----------
		p : array_like
		    Input array.
		discont : float, optional
		    Maximum discontinuity between values, default is ``pi``.
		axis : int, optional
		    Axis along which unwrap will operate, default is the last axis.
		
		Returns
		-------
		out : ndarray
		    Output array.
		
		See Also
		--------
		rad2deg, deg2rad
		
		Notes
		-----
		If the discontinuity in `p` is smaller than ``pi``, but larger than
		`discont`, no unwrapping is done because taking the 2*pi complement
		would only make the discontinuity larger.
		
		Examples
		--------
		>>> phase = np.linspace(0, np.pi, num=5)
		>>> phase[3:] += np.pi
		>>> phase
		array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])
		>>> np.unwrap(phase)
		array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])
	**/
	static public function unwrap(p:Dynamic, ?discont:Dynamic, ?axis:Dynamic):Dynamic;
	/**
		Generate a Vandermonde matrix.
		
		The columns of the output matrix are powers of the input vector. The
		order of the powers is determined by the `increasing` boolean argument.
		Specifically, when `increasing` is False, the `i`-th output column is
		the input vector raised element-wise to the power of ``N - i - 1``. Such
		a matrix with a geometric progression in each row is named for Alexandre-
		Theophile Vandermonde.
		
		Parameters
		----------
		x : array_like
		    1-D input array.
		N : int, optional
		    Number of columns in the output.  If `N` is not specified, a square
		    array is returned (``N = len(x)``).
		increasing : bool, optional
		    Order of the powers of the columns.  If True, the powers increase
		    from left to right, if False (the default) they are reversed.
		
		    .. versionadded:: 1.9.0
		
		Returns
		-------
		out : ndarray
		    Vandermonde matrix.  If `increasing` is False, the first column is
		    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
		    True, the columns are ``x^0, x^1, ..., x^(N-1)``.
		
		See Also
		--------
		polynomial.polynomial.polyvander
		
		Examples
		--------
		>>> x = np.array([1, 2, 3, 5])
		>>> N = 3
		>>> np.vander(x, N)
		array([[ 1,  1,  1],
		       [ 4,  2,  1],
		       [ 9,  3,  1],
		       [25,  5,  1]])
		
		>>> np.column_stack([x**(N-1-i) for i in range(N)])
		array([[ 1,  1,  1],
		       [ 4,  2,  1],
		       [ 9,  3,  1],
		       [25,  5,  1]])
		
		>>> x = np.array([1, 2, 3, 5])
		>>> np.vander(x)
		array([[  1,   1,   1,   1],
		       [  8,   4,   2,   1],
		       [ 27,   9,   3,   1],
		       [125,  25,   5,   1]])
		>>> np.vander(x, increasing=True)
		array([[  1,   1,   1,   1],
		       [  1,   2,   4,   8],
		       [  1,   3,   9,  27],
		       [  1,   5,  25, 125]])
		
		The determinant of a square Vandermonde matrix is the product
		of the differences between the values of the input vector:
		
		>>> np.linalg.det(np.vander(x))
		48.000000000000043
		>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
		48
	**/
	static public function vander(x:Dynamic, ?N:Dynamic, ?increasing:Dynamic):Dynamic;
	/**
		Compute the variance along the specified axis.
		
		Returns the variance of the array elements, a measure of the spread of a
		distribution.  The variance is computed for the flattened array by
		default, otherwise over the specified axis.
		
		Parameters
		----------
		a : array_like
		    Array containing numbers whose variance is desired.  If `a` is not an
		    array, a conversion is attempted.
		axis : None or int or tuple of ints, optional
		    Axis or axes along which the variance is computed.  The default is to
		    compute the variance of the flattened array.
		
		    .. versionadded:: 1.7.0
		
		    If this is a tuple of ints, a variance is performed over multiple axes,
		    instead of a single axis or all the axes as before.
		dtype : data-type, optional
		    Type to use in computing the variance.  For arrays of integer type
		    the default is `float32`; for arrays of float types it is the same as
		    the array type.
		out : ndarray, optional
		    Alternate output array in which to place the result.  It must have
		    the same shape as the expected output, but the type is cast if
		    necessary.
		ddof : int, optional
		    "Delta Degrees of Freedom": the divisor used in the calculation is
		    ``N - ddof``, where ``N`` represents the number of elements. By
		    default `ddof` is zero.
		keepdims : bool, optional
		    If this is set to True, the axes which are reduced are left
		    in the result as dimensions with size one. With this option,
		    the result will broadcast correctly against the input array.
		
		    If the default value is passed, then `keepdims` will not be
		    passed through to the `var` method of sub-classes of
		    `ndarray`, however any non-default value will be.  If the
		    sub-class' method does not implement `keepdims` any
		    exceptions will be raised.
		
		Returns
		-------
		variance : ndarray, see dtype parameter above
		    If ``out=None``, returns a new array containing the variance;
		    otherwise, a reference to the output array is returned.
		
		See Also
		--------
		std , mean, nanmean, nanstd, nanvar
		numpy.doc.ufuncs : Section "Output arguments"
		
		Notes
		-----
		The variance is the average of the squared deviations from the mean,
		i.e.,  ``var = mean(abs(x - x.mean())**2)``.
		
		The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
		If, however, `ddof` is specified, the divisor ``N - ddof`` is used
		instead.  In standard statistical practice, ``ddof=1`` provides an
		unbiased estimator of the variance of a hypothetical infinite population.
		``ddof=0`` provides a maximum likelihood estimate of the variance for
		normally distributed variables.
		
		Note that for complex numbers, the absolute value is taken before
		squaring, so that the result is always real and nonnegative.
		
		For floating-point input, the variance is computed using the same
		precision the input has.  Depending on the input data, this can cause
		the results to be inaccurate, especially for `float32` (see example
		below).  Specifying a higher-accuracy accumulator using the ``dtype``
		keyword can alleviate this issue.
		
		Examples
		--------
		>>> a = np.array([[1, 2], [3, 4]])
		>>> np.var(a)
		1.25
		>>> np.var(a, axis=0)
		array([ 1.,  1.])
		>>> np.var(a, axis=1)
		array([ 0.25,  0.25])
		
		In single precision, var() can be inaccurate:
		
		>>> a = np.zeros((2, 512*512), dtype=np.float32)
		>>> a[0, :] = 1.0
		>>> a[1, :] = 0.1
		>>> np.var(a)
		0.20250003
		
		Computing the variance in float64 is more accurate:
		
		>>> np.var(a, dtype=np.float64)
		0.20249999932944759
		>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
		0.2025
	**/
	@:native("var")
	static public function _var(a:Dynamic, ?axis:Dynamic, ?dtype:Dynamic, ?out:Dynamic, ?ddof:Dynamic, ?keepdims:Dynamic):Dynamic;
	/**
		vdot(a, b)
		
		Return the dot product of two vectors.
		
		The vdot(`a`, `b`) function handles complex numbers differently than
		dot(`a`, `b`).  If the first argument is complex the complex conjugate
		of the first argument is used for the calculation of the dot product.
		
		Note that `vdot` handles multidimensional arrays differently than `dot`:
		it does *not* perform a matrix product, but flattens input arguments
		to 1-D vectors first. Consequently, it should only be used for vectors.
		
		Parameters
		----------
		a : array_like
		    If `a` is complex the complex conjugate is taken before calculation
		    of the dot product.
		b : array_like
		    Second argument to the dot product.
		
		Returns
		-------
		output : ndarray
		    Dot product of `a` and `b`.  Can be an int, float, or
		    complex depending on the types of `a` and `b`.
		
		See Also
		--------
		dot : Return the dot product without using the complex conjugate of the
		      first argument.
		
		Examples
		--------
		>>> a = np.array([1+2j,3+4j])
		>>> b = np.array([5+6j,7+8j])
		>>> np.vdot(a, b)
		(70-8j)
		>>> np.vdot(b, a)
		(70+8j)
		
		Note that higher-dimensional arrays are flattened!
		
		>>> a = np.array([[1, 4], [5, 6]])
		>>> b = np.array([[4, 1], [2, 2]])
		>>> np.vdot(a, b)
		30
		>>> np.vdot(b, a)
		30
		>>> 1*4 + 4*1 + 5*2 + 6*2
		30
	**/
	static public function vdot(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Make a violin plot.
		
		Make a violin plot for each column of *dataset* or each vector in
		sequence *dataset*.  Each filled area extends to represent the
		entire data range, with optional lines at the mean, the median,
		the minimum, and the maximum.
		
		Parameters
		----------
		dataset : Array or a sequence of vectors.
		  The input data.
		
		positions : array-like, default = [1, 2, ..., n]
		  Sets the positions of the violins. The ticks and limits are
		  automatically set to match the positions.
		
		vert : bool, default = True.
		  If true, creates a vertical violin plot.
		  Otherwise, creates a horizontal violin plot.
		
		widths : array-like, default = 0.5
		  Either a scalar or a vector that sets the maximal width of
		  each violin. The default is 0.5, which uses about half of the
		  available horizontal space.
		
		showmeans : bool, default = False
		  If `True`, will toggle rendering of the means.
		
		showextrema : bool, default = True
		  If `True`, will toggle rendering of the extrema.
		
		showmedians : bool, default = False
		  If `True`, will toggle rendering of the medians.
		
		points : scalar, default = 100
		  Defines the number of points to evaluate each of the
		  gaussian kernel density estimations at.
		
		bw_method : str, scalar or callable, optional
		  The method used to calculate the estimator bandwidth.  This can be
		  'scott', 'silverman', a scalar constant or a callable.  If a
		  scalar, this will be used directly as `kde.factor`.  If a
		  callable, it should take a `GaussianKDE` instance as its only
		  parameter and return a scalar. If None (default), 'scott' is used.
		
		Returns
		-------
		
		result : dict
		  A dictionary mapping each component of the violinplot to a
		  list of the corresponding collection instances created. The
		  dictionary has the following keys:
		
		    - ``bodies``: A list of the
		      :class:`matplotlib.collections.PolyCollection` instances
		      containing the filled area of each violin.
		
		    - ``cmeans``: A
		      :class:`matplotlib.collections.LineCollection` instance
		      created to identify the mean values of each of the
		      violin's distribution.
		
		    - ``cmins``: A
		      :class:`matplotlib.collections.LineCollection` instance
		      created to identify the bottom of each violin's
		      distribution.
		
		    - ``cmaxes``: A
		      :class:`matplotlib.collections.LineCollection` instance
		      created to identify the top of each violin's
		      distribution.
		
		    - ``cbars``: A
		      :class:`matplotlib.collections.LineCollection` instance
		      created to identify the centers of each violin's
		      distribution.
		
		    - ``cmedians``: A
		      :class:`matplotlib.collections.LineCollection` instance
		      created to identify the median values of each of the
		      violin's distribution.
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'dataset'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function violinplot(dataset:Dynamic, ?positions:Dynamic, ?vert:Dynamic, ?widths:Dynamic, ?showmeans:Dynamic, ?showextrema:Dynamic, ?showmedians:Dynamic, ?points:Dynamic, ?bw_method:Dynamic, ?data:Dynamic):python.Dict<Dynamic, Dynamic>;
	/**
		Set the colormap to "viridis".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function viridis():Dynamic;
	/**
		Plot vertical lines.
		
		Plot vertical lines at each *x* from *ymin* to *ymax*.
		
		Parameters
		----------
		x : scalar or 1D array_like
		    x-indexes where to plot the lines.
		
		ymin, ymax : scalar or 1D array_like
		    Respective beginning and end of each line. If scalars are
		    provided, all lines will have same length.
		
		colors : array_like of colors, optional, default: 'k'
		
		linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
		
		label : string, optional, default: ''
		
		Returns
		-------
		lines : `~matplotlib.collections.LineCollection`
		
		Other Parameters
		----------------
		**kwargs : `~matplotlib.collections.LineCollection` properties.
		
		See also
		--------
		hlines : horizontal lines
		axvline: vertical line across the axes
		
		Notes
		-----
		
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'colors', 'x', 'ymax', 'ymin'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function vlines(x:Dynamic, ymin:Dynamic, ymax:Dynamic, ?colors:Dynamic, ?linestyles:Dynamic, ?label:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		vonmises(mu, kappa, size=None)
		
		Draw samples from a von Mises distribution.
		
		Samples are drawn from a von Mises distribution with specified mode
		(mu) and dispersion (kappa), on the interval [-pi, pi].
		
		The von Mises distribution (also known as the circular normal
		distribution) is a continuous probability distribution on the unit
		circle.  It may be thought of as the circular analogue of the normal
		distribution.
		
		Parameters
		----------
		mu : float or array_like of floats
		    Mode ("center") of the distribution.
		kappa : float or array_like of floats
		    Dispersion of the distribution, has to be >=0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``mu`` and ``kappa`` are both scalars.
		    Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized von Mises distribution.
		
		See Also
		--------
		scipy.stats.vonmises : probability density function, distribution, or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the von Mises distribution is
		
		.. math:: p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},
		
		where :math:`\mu` is the mode and :math:`\kappa` the dispersion,
		and :math:`I_0(\kappa)` is the modified Bessel function of order 0.
		
		The von Mises is named for Richard Edler von Mises, who was born in
		Austria-Hungary, in what is now the Ukraine.  He fled to the United
		States in 1939 and became a professor at Harvard.  He worked in
		probability theory, aerodynamics, fluid mechanics, and philosophy of
		science.
		
		References
		----------
		.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). "Handbook of
		       Mathematical Functions with Formulas, Graphs, and Mathematical
		       Tables, 9th printing," New York: Dover, 1972.
		.. [2] von Mises, R., "Mathematical Theory of Probability
		       and Statistics", New York: Academic Press, 1964.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> mu, kappa = 0.0, 4.0 # mean and dispersion
		>>> s = np.random.vonmises(mu, kappa, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> from scipy.special import i0
		>>> plt.hist(s, 50, density=True)
		>>> x = np.linspace(-np.pi, np.pi, num=51)
		>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))
		>>> plt.plot(x, y, linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function vonmises(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Split an array into multiple sub-arrays vertically (row-wise).
		
		Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
		to ``split`` with `axis=0` (default), the array is always split along the
		first axis regardless of the array dimension.
		
		See Also
		--------
		split : Split an array into multiple sub-arrays of equal size.
		
		Examples
		--------
		>>> x = np.arange(16.0).reshape(4, 4)
		>>> x
		array([[  0.,   1.,   2.,   3.],
		       [  4.,   5.,   6.,   7.],
		       [  8.,   9.,  10.,  11.],
		       [ 12.,  13.,  14.,  15.]])
		>>> np.vsplit(x, 2)
		[array([[ 0.,  1.,  2.,  3.],
		       [ 4.,  5.,  6.,  7.]]),
		 array([[  8.,   9.,  10.,  11.],
		       [ 12.,  13.,  14.,  15.]])]
		>>> np.vsplit(x, np.array([3, 6]))
		[array([[  0.,   1.,   2.,   3.],
		       [  4.,   5.,   6.,   7.],
		       [  8.,   9.,  10.,  11.]]),
		 array([[ 12.,  13.,  14.,  15.]]),
		 array([], dtype=float64)]
		
		With a higher dimensional array the split is still along the first axis.
		
		>>> x = np.arange(8.0).reshape(2, 2, 2)
		>>> x
		array([[[ 0.,  1.],
		        [ 2.,  3.]],
		       [[ 4.,  5.],
		        [ 6.,  7.]]])
		>>> np.vsplit(x, 2)
		[array([[[ 0.,  1.],
		        [ 2.,  3.]]]),
		 array([[[ 4.,  5.],
		        [ 6.,  7.]]])]
	**/
	static public function vsplit(ary:Dynamic, indices_or_sections:Dynamic):Dynamic;
	/**
		Stack arrays in sequence vertically (row wise).
		
		This is equivalent to concatenation along the first axis after 1-D arrays
		of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
		`vsplit`.
		
		This function makes most sense for arrays with up to 3 dimensions. For
		instance, for pixel-data with a height (first axis), width (second axis),
		and r/g/b channels (third axis). The functions `concatenate`, `stack` and
		`block` provide more general stacking and concatenation operations.
		
		Parameters
		----------
		tup : sequence of ndarrays
		    The arrays must have the same shape along all but the first axis.
		    1-D arrays must have the same length.
		
		Returns
		-------
		stacked : ndarray
		    The array formed by stacking the given arrays, will be at least 2-D.
		
		See Also
		--------
		stack : Join a sequence of arrays along a new axis.
		hstack : Stack arrays in sequence horizontally (column wise).
		dstack : Stack arrays in sequence depth wise (along third dimension).
		concatenate : Join a sequence of arrays along an existing axis.
		vsplit : Split array into a list of multiple sub-arrays vertically.
		block : Assemble arrays from blocks.
		
		Examples
		--------
		>>> a = np.array([1, 2, 3])
		>>> b = np.array([2, 3, 4])
		>>> np.vstack((a,b))
		array([[1, 2, 3],
		       [2, 3, 4]])
		
		>>> a = np.array([[1], [2], [3]])
		>>> b = np.array([[2], [3], [4]])
		>>> np.vstack((a,b))
		array([[1],
		       [2],
		       [3],
		       [2],
		       [3],
		       [4]])
	**/
	static public function vstack(tup:Dynamic):Dynamic;
	/**
		Blocking call to interact with the figure.
		
		This will return True is a key was pressed, False if a mouse
		button was pressed and None if *timeout* was reached without
		either being pressed.
		
		If *timeout* is negative, does not timeout.
	**/
	static public function waitforbuttonpress(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		wald(mean, scale, size=None)
		
		Draw samples from a Wald, or inverse Gaussian, distribution.
		
		As the scale approaches infinity, the distribution becomes more like a
		Gaussian. Some references claim that the Wald is an inverse Gaussian
		with mean equal to 1, but this is by no means universal.
		
		The inverse Gaussian distribution was first studied in relationship to
		Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
		because there is an inverse relationship between the time to cover a
		unit distance and distance covered in unit time.
		
		Parameters
		----------
		mean : float or array_like of floats
		    Distribution mean, should be > 0.
		scale : float or array_like of floats
		    Scale parameter, should be >= 0.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``mean`` and ``scale`` are both scalars.
		    Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Wald distribution.
		
		Notes
		-----
		The probability density function for the Wald distribution is
		
		.. math:: P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
		                            \frac{-scale(x-mean)^2}{2\cdotp mean^2x}
		
		As noted above the inverse Gaussian distribution first arise
		from attempts to model Brownian motion. It is also a
		competitor to the Weibull for use in reliability modeling and
		modeling stock returns and interest rate processes.
		
		References
		----------
		.. [1] Brighton Webs Ltd., Wald Distribution,
		       https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp
		.. [2] Chhikara, Raj S., and Folks, J. Leroy, "The Inverse Gaussian
		       Distribution: Theory : Methodology, and Applications", CRC Press,
		       1988.
		.. [3] Wikipedia, "Inverse Gaussian distribution"
		       https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution
		
		Examples
		--------
		Draw values from the distribution and plot the histogram:
		
		>>> import matplotlib.pyplot as plt
		>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
		>>> plt.show()
	**/
	static public function wald(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Used to display deprecation in a standard way.
		
		Parameters
		----------
		since : str
		    The release at which this API became deprecated.
		
		message : str, optional
		    Override the default deprecation message.  The format
		    specifier `%(name)s` may be used for the name of the function,
		    and `%(alternative)s` may be used in the deprecation message
		    to insert the name of an alternative to the deprecated
		    function.  `%(obj_type)s` may be used to insert a friendly name
		    for the type of object being deprecated.
		
		name : str, optional
		    The name of the deprecated object.
		
		alternative : str, optional
		    An alternative API that the user may use in place of the deprecated
		    API.  The deprecation warning will tell the user about this alternative
		    if provided.
		
		pending : bool, optional
		    If True, uses a PendingDeprecationWarning instead of a
		    DeprecationWarning.  Cannot be used together with *removal*.
		
		obj_type : str, optional
		    The object type being deprecated.
		
		addendum : str, optional
		    Additional text appended directly to the final message.
		
		removal : str, optional
		    The expected removal version.  With the default (an empty string), a
		    removal version is automatically computed from *since*.  Set to other
		    Falsy values to not schedule a removal date.  Cannot be used together
		    with *pending*.
		
		Examples
		--------
		
		    Basic example::
		
		        # To warn of the deprecation of "matplotlib.name_of_module"
		        warn_deprecated('1.4.0', name='matplotlib.name_of_module',
		                        obj_type='module')
	**/
	static public function warn_deprecated(since:Dynamic, ?message:Dynamic, ?name:Dynamic, ?alternative:Dynamic, ?pending:Dynamic, ?obj_type:Dynamic, ?addendum:Dynamic, ?removal:Dynamic):Dynamic;
	/**
		weibull(a, size=None)
		
		Draw samples from a Weibull distribution.
		
		Draw samples from a 1-parameter Weibull distribution with the given
		shape parameter `a`.
		
		.. math:: X = (-ln(U))^{1/a}
		
		Here, U is drawn from the uniform distribution over (0,1].
		
		The more common 2-parameter Weibull, including a scale parameter
		:math:`\lambda` is just :math:`X = \lambda(-ln(U))^{1/a}`.
		
		Parameters
		----------
		a : float or array_like of floats
		    Shape parameter of the distribution.  Must be nonnegative.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``a`` is a scalar.  Otherwise,
		    ``np.array(a).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Weibull distribution.
		
		See Also
		--------
		scipy.stats.weibull_max
		scipy.stats.weibull_min
		scipy.stats.genextreme
		gumbel
		
		Notes
		-----
		The Weibull (or Type III asymptotic extreme value distribution
		for smallest values, SEV Type III, or Rosin-Rammler
		distribution) is one of a class of Generalized Extreme Value
		(GEV) distributions used in modeling extreme value problems.
		This class includes the Gumbel and Frechet distributions.
		
		The probability density for the Weibull distribution is
		
		.. math:: p(x) = \frac{a}
		                 {\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},
		
		where :math:`a` is the shape and :math:`\lambda` the scale.
		
		The function has its peak (the mode) at
		:math:`\lambda(\frac{a-1}{a})^{1/a}`.
		
		When ``a = 1``, the Weibull distribution reduces to the exponential
		distribution.
		
		References
		----------
		.. [1] Waloddi Weibull, Royal Technical University, Stockholm,
		       1939 "A Statistical Theory Of The Strength Of Materials",
		       Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
		       Generalstabens Litografiska Anstalts Forlag, Stockholm.
		.. [2] Waloddi Weibull, "A Statistical Distribution Function of
		       Wide Applicability", Journal Of Applied Mechanics ASME Paper
		       1951.
		.. [3] Wikipedia, "Weibull distribution",
		       https://en.wikipedia.org/wiki/Weibull_distribution
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> a = 5. # shape
		>>> s = np.random.weibull(a, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> x = np.arange(1,100.)/50.
		>>> def weib(x,n,a):
		...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)
		
		>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
		>>> x = np.arange(1,100.)/50.
		>>> scale = count.max()/weib(x, 1., 5.).max()
		>>> plt.plot(x, weib(x, 1., 5.)*scale)
		>>> plt.show()
	**/
	static public function weibull(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		where(condition, [x, y])
		
		Return elements chosen from `x` or `y` depending on `condition`.
		
		.. note::
		    When only `condition` is provided, this function is a shorthand for
		    ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
		    preferred, as it behaves correctly for subclasses. The rest of this
		    documentation covers only the case where all three arguments are
		    provided.
		
		Parameters
		----------
		condition : array_like, bool
		    Where True, yield `x`, otherwise yield `y`.
		x, y : array_like
		    Values from which to choose. `x`, `y` and `condition` need to be
		    broadcastable to some shape.
		
		Returns
		-------
		out : ndarray
		    An array with elements from `x` where `condition` is True, and elements
		    from `y` elsewhere.
		
		See Also
		--------
		choose
		nonzero : The function that is called when x and y are omitted
		
		Notes
		-----
		If all the arrays are 1-D, `where` is equivalent to::
		
		    [xv if c else yv
		     for c, xv, yv in zip(condition, x, y)]
		
		Examples
		--------
		>>> a = np.arange(10)
		>>> a
		array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
		>>> np.where(a < 5, a, 10*a)
		array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
		
		This can be used on multidimensional arrays too:
		
		>>> np.where([[True, False], [True, True]],
		...          [[1, 2], [3, 4]],
		...          [[9, 8], [7, 6]])
		array([[1, 8],
		       [3, 4]])
		
		The shapes of x, y, and the condition are broadcast together:
		
		>>> x, y = np.ogrid[:3, :4]
		>>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
		array([[10,  0,  0,  0],
		       [10, 11,  1,  1],
		       [10, 11, 12,  2]])
		
		>>> a = np.array([[0, 1, 2],
		...               [0, 2, 4],
		...               [0, 3, 6]])
		>>> np.where(a < 4, a, -1)  # -1 is broadcast
		array([[ 0,  1,  2],
		       [ 0,  2, -1],
		       [ 0,  3, -1]])
	**/
	static public function where(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Print the NumPy arrays in the given dictionary.
		
		If there is no dictionary passed in or `vardict` is None then returns
		NumPy arrays in the globals() dictionary (all NumPy arrays in the
		namespace).
		
		Parameters
		----------
		vardict : dict, optional
		    A dictionary possibly containing ndarrays.  Default is globals().
		
		Returns
		-------
		out : None
		    Returns 'None'.
		
		Notes
		-----
		Prints out the name, shape, bytes and type of all of the ndarrays
		present in `vardict`.
		
		Examples
		--------
		>>> a = np.arange(10)
		>>> b = np.ones(20)
		>>> np.who()
		Name            Shape            Bytes            Type
		===========================================================
		a               10               40               int32
		b               20               160              float64
		Upper bound on total bytes  =       200
		
		>>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',
		... 'idx':5}
		>>> np.who(d)
		Name            Shape            Bytes            Type
		===========================================================
		y               3                24               float64
		x               2                16               float64
		Upper bound on total bytes  =       40
	**/
	static public function who(?vardict:Dynamic):Dynamic;
	/**
		Return x times the hanning window of len(x).
		
		See Also
		--------
		window_none : Another window algorithm.
	**/
	static public function window_hanning(x:Dynamic):Dynamic;
	/**
		No window function; simply return x.
		
		See Also
		--------
		window_hanning : Another window algorithm.
	**/
	static public function window_none(x:Dynamic):Dynamic;
	/**
		Set the colormap to "winter".
		
		This changes the default colormap as well as the colormap of the current
		image if there is one. See ``help(colormaps)`` for more information.
	**/
	static public function winter():Dynamic;
	/**
		Plot the cross correlation between *x* and *y*.
		
		The correlation with lag k is defined as
		:math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
		conjugate of :math:`y`.
		
		Parameters
		----------
		x : array-like of length n
		
		y : array-like of length n
		
		detrend : callable, optional, default: `mlab.detrend_none`
		    *x* and *y* are detrended by the *detrend* callable. This must be a
		    function ``x = detrend(x)`` accepting and returning an
		    `numpy.array`. Default is no normalization.
		
		normed : bool, optional, default: True
		    If ``True``, input vectors are normalised to unit length.
		
		usevlines : bool, optional, default: True
		    Determines the plot style.
		
		    If ``True``, vertical lines are plotted from 0 to the xcorr value
		    using `Axes.vlines`. Additionally, a horizontal line is plotted
		    at y=0 using `Axes.axhline`.
		
		    If ``False``, markers are plotted at the xcorr values using
		    `Axes.plot`.
		
		maxlags : int, optional, default: 10
		    Number of lags to show. If None, will return all ``2 * len(x) - 1``
		    lags.
		
		Returns
		-------
		lags : array (length ``2*maxlags+1``)
		    The lag vector.
		c : array  (length ``2*maxlags+1``)
		    The auto correlation vector.
		line : `.LineCollection` or `.Line2D`
		    `.Artist` added to the axes of the correlation:
		
		    - `.LineCollection` if *usevlines* is True.
		    - `.Line2D` if *usevlines* is False.
		b : `.Line2D` or None
		    Horizontal line at 0 if *usevlines* is True
		    None *usevlines* is False.
		
		Other Parameters
		----------------
		linestyle : `.Line2D` property, optional
		    The linestyle for plotting the data points.
		    Only used if *usevlines* is ``False``.
		
		marker : str, optional, default: 'o'
		    The marker for plotting the data points.
		    Only used if *usevlines* is ``False``.
		
		Notes
		-----
		The cross correlation is performed with :func:`numpy.correlate` with
		``mode = "full"``.
		
		.. note::
		    In addition to the above described arguments, this function can take a
		    **data** keyword argument. If such a **data** argument is given, the
		    following arguments are replaced by **data[<arg>]**:
		
		    * All arguments with the following names: 'x', 'y'.
		
		    Objects passed as **data** must support item access (``data[<arg>]``) and
		    membership test (``<arg> in data``).
	**/
	static public function xcorr(x:Dynamic, y:Dynamic, ?normed:Dynamic, ?detrend:Dynamic, ?usevlines:Dynamic, ?maxlags:Dynamic, ?data:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.
		This will only have effect on things drawn after this function is
		called.
		
		For best results, the "Humor Sans" font should be installed: it is
		not included with matplotlib.
		
		Parameters
		----------
		scale : float, optional
		    The amplitude of the wiggle perpendicular to the source line.
		length : float, optional
		    The length of the wiggle along the line.
		randomness : float, optional
		    The scale factor by which the length is shrunken or expanded.
		
		Notes
		-----
		This function works by a number of rcParams, so it will probably
		override others you have set before.
		
		If you want the effects of this function to be temporary, it can
		be used as a context manager, for example::
		
		    with plt.xkcd():
		        # This figure will be in XKCD-style
		        fig1 = plt.figure()
		        # ...
		
		    # This figure will be in regular style
		    fig2 = plt.figure()
	**/
	static public function xkcd(?scale:Dynamic, ?length:Dynamic, ?randomness:Dynamic):Dynamic;
	/**
		Set the label for the x-axis.
		
		Parameters
		----------
		xlabel : str
		    The label text.
		
		labelpad : scalar, optional, default: None
		    Spacing in points from the axes bounding box including ticks
		    and tick labels.
		
		Other Parameters
		----------------
		**kwargs : `.Text` properties
		    `.Text` properties control the appearance of the label.
		
		See also
		--------
		text : for information on how override and the optional args work
	**/
	static public function xlabel(xlabel:Dynamic, ?fontdict:Dynamic, ?labelpad:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Get or set the x limits of the current axes.
		
		Call signatures::
		
		    left, right = xlim()  # return the current xlim
		    xlim((left, right))   # set the xlim to left, right
		    xlim(left, right)     # set the xlim to left, right
		
		If you do not specify args, you can pass *left* or *right* as kwargs,
		i.e.::
		
		    xlim(right=3)  # adjust the right leaving left unchanged
		    xlim(left=1)  # adjust the left leaving right unchanged
		
		Setting limits turns autoscaling off for the x-axis.
		
		Returns
		-------
		left, right
		    A tuple of the new x-axis limits.
		
		Notes
		-----
		Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
		equivalent of calling `~.Axes.get_xlim` on the current axes.
		Calling this function with arguments is the pyplot equivalent of calling
		`~.Axes.set_xlim` on the current axes. All arguments are passed though.
	**/
	static public function xlim(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the x-axis scale.
		
		Parameters
		----------
		value : {"linear", "log", "symlog", "logit", ...}
		    The axis scale type to apply.
		
		**kwargs
		    Different keyword arguments are accepted, depending on the scale.
		    See the respective class keyword arguments:
		
		    - `matplotlib.scale.LinearScale`
		    - `matplotlib.scale.LogScale`
		    - `matplotlib.scale.SymmetricalLogScale`
		    - `matplotlib.scale.LogitScale`
		
		
		Notes
		-----
		By default, Matplotlib supports the above mentioned scales.
		Additionally, custom scales may be registered using
		`matplotlib.scale.register_scale`. These scales can then also
		be used here.
	**/
	static public function xscale(value:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Get or set the current tick locations and labels of the x-axis.
		
		Call signatures::
		
		    locs, labels = xticks()            # Get locations and labels
		    xticks(ticks, [labels], **kwargs)  # Set locations and labels
		
		Parameters
		----------
		ticks : array_like
		    A list of positions at which ticks should be placed. You can pass an
		    empty list to disable xticks.
		
		labels : array_like, optional
		    A list of explicit labels to place at the given *locs*.
		
		**kwargs
		    :class:`.Text` properties can be used to control the appearance of
		    the labels.
		
		Returns
		-------
		locs
		    An array of label locations.
		labels
		    A list of `.Text` objects.
		
		Notes
		-----
		Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
		equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
		the current axes.
		Calling this function with arguments is the pyplot equivalent of calling
		`~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
		
		Examples
		--------
		Get the current locations and labels:
		
		    >>> locs, labels = xticks()
		
		Set label locations:
		
		    >>> xticks(np.arange(0, 1, step=0.2))
		
		Set text labels:
		
		    >>> xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
		
		Set text labels and properties:
		
		    >>> xticks(np.arange(12), calendar.month_name[1:13], rotation=20)
		
		Disable xticks:
		
		    >>> xticks([])
	**/
	static public function xticks(?ticks:Dynamic, ?labels:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the label for the y-axis.
		
		Parameters
		----------
		ylabel : str
		    The label text.
		
		labelpad : scalar, optional, default: None
		    Spacing in points from the axes bounding box including ticks
		    and tick labels.
		
		Other Parameters
		----------------
		**kwargs : `.Text` properties
		    `.Text` properties control the appearance of the label.
		
		See also
		--------
		text : for information on how override and the optional args work
	**/
	static public function ylabel(ylabel:Dynamic, ?fontdict:Dynamic, ?labelpad:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Get or set the y-limits of the current axes.
		
		Call signatures::
		
		    bottom, top = ylim()  # return the current ylim
		    ylim((bottom, top))   # set the ylim to bottom, top
		    ylim(bottom, top)     # set the ylim to bottom, top
		
		If you do not specify args, you can alternatively pass *bottom* or
		*top* as kwargs, i.e.::
		
		    ylim(top=3)  # adjust the top leaving bottom unchanged
		    ylim(bottom=1)  # adjust the bottom leaving top unchanged
		
		Setting limits turns autoscaling off for the y-axis.
		
		Returns
		-------
		bottom, top
		    A tuple of the new y-axis limits.
		
		Notes
		-----
		Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
		equivalent of calling `~.Axes.get_ylim` on the current axes.
		Calling this function with arguments is the pyplot equivalent of calling
		`~.Axes.set_ylim` on the current axes. All arguments are passed though.
	**/
	static public function ylim(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Set the y-axis scale.
		
		Parameters
		----------
		value : {"linear", "log", "symlog", "logit", ...}
		    The axis scale type to apply.
		
		**kwargs
		    Different keyword arguments are accepted, depending on the scale.
		    See the respective class keyword arguments:
		
		    - `matplotlib.scale.LinearScale`
		    - `matplotlib.scale.LogScale`
		    - `matplotlib.scale.SymmetricalLogScale`
		    - `matplotlib.scale.LogitScale`
		
		
		Notes
		-----
		By default, Matplotlib supports the above mentioned scales.
		Additionally, custom scales may be registered using
		`matplotlib.scale.register_scale`. These scales can then also
		be used here.
	**/
	static public function yscale(value:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Get or set the current tick locations and labels of the y-axis.
		
		Call signatures::
		
		    locs, labels = yticks()            # Get locations and labels
		    yticks(ticks, [labels], **kwargs)  # Set locations and labels
		
		Parameters
		----------
		ticks : array_like
		    A list of positions at which ticks should be placed. You can pass an
		    empty list to disable yticks.
		
		labels : array_like, optional
		    A list of explicit labels to place at the given *locs*.
		
		**kwargs
		    :class:`.Text` properties can be used to control the appearance of
		    the labels.
		
		Returns
		-------
		locs
		    An array of label locations.
		labels
		    A list of `.Text` objects.
		
		Notes
		-----
		Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
		equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
		the current axes.
		Calling this function with arguments is the pyplot equivalent of calling
		`~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
		
		Examples
		--------
		Get the current locations and labels:
		
		    >>> locs, labels = yticks()
		
		Set label locations:
		
		    >>> yticks(np.arange(0, 1, step=0.2))
		
		Set text labels:
		
		    >>> yticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
		
		Set text labels and properties:
		
		    >>> yticks(np.arange(12), calendar.month_name[1:13], rotation=45)
		
		Disable yticks:
		
		    >>> yticks([])
	**/
	static public function yticks(?ticks:Dynamic, ?labels:Dynamic, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		zeros(shape, dtype=float, order='C')
		
		Return a new array of given shape and type, filled with zeros.
		
		Parameters
		----------
		shape : int or tuple of ints
		    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
		dtype : data-type, optional
		    The desired data-type for the array, e.g., `numpy.int8`.  Default is
		    `numpy.float64`.
		order : {'C', 'F'}, optional, default: 'C'
		    Whether to store multi-dimensional data in row-major
		    (C-style) or column-major (Fortran-style) order in
		    memory.
		
		Returns
		-------
		out : ndarray
		    Array of zeros with the given shape, dtype, and order.
		
		See Also
		--------
		zeros_like : Return an array of zeros with shape and type of input.
		empty : Return a new uninitialized array.
		ones : Return a new array setting values to one.
		full : Return a new array of given shape filled with value.
		
		Examples
		--------
		>>> np.zeros(5)
		array([ 0.,  0.,  0.,  0.,  0.])
		
		>>> np.zeros((5,), dtype=int)
		array([0, 0, 0, 0, 0])
		
		>>> np.zeros((2, 1))
		array([[ 0.],
		       [ 0.]])
		
		>>> s = (2,2)
		>>> np.zeros(s)
		array([[ 0.,  0.],
		       [ 0.,  0.]])
		
		>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
		array([(0, 0), (0, 0)],
		      dtype=[('x', '<i4'), ('y', '<i4')])
	**/
	static public function zeros(args:haxe.extern.Rest<Dynamic>):Dynamic;
	/**
		Return an array of zeros with the same shape and type as a given array.
		
		Parameters
		----------
		a : array_like
		    The shape and data-type of `a` define these same attributes of
		    the returned array.
		dtype : data-type, optional
		    Overrides the data type of the result.
		
		    .. versionadded:: 1.6.0
		order : {'C', 'F', 'A', or 'K'}, optional
		    Overrides the memory layout of the result. 'C' means C-order,
		    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
		    'C' otherwise. 'K' means match the layout of `a` as closely
		    as possible.
		
		    .. versionadded:: 1.6.0
		subok : bool, optional.
		    If True, then the newly created array will use the sub-class
		    type of 'a', otherwise it will be a base-class array. Defaults
		    to True.
		
		Returns
		-------
		out : ndarray
		    Array of zeros with the same shape and type as `a`.
		
		See Also
		--------
		empty_like : Return an empty array with shape and type of input.
		ones_like : Return an array of ones with shape and type of input.
		full_like : Return a new array with shape of input filled with value.
		zeros : Return a new array setting values to zero.
		
		Examples
		--------
		>>> x = np.arange(6)
		>>> x = x.reshape((2, 3))
		>>> x
		array([[0, 1, 2],
		       [3, 4, 5]])
		>>> np.zeros_like(x)
		array([[0, 0, 0],
		       [0, 0, 0]])
		
		>>> y = np.arange(3, dtype=float)
		>>> y
		array([ 0.,  1.,  2.])
		>>> np.zeros_like(y)
		array([ 0.,  0.,  0.])
	**/
	static public function zeros_like(a:Dynamic, ?dtype:Dynamic, ?order:Dynamic, ?subok:Dynamic):Dynamic;
	/**
		zipf(a, size=None)
		
		Draw samples from a Zipf distribution.
		
		Samples are drawn from a Zipf distribution with specified parameter
		`a` > 1.
		
		The Zipf distribution (also known as the zeta distribution) is a
		continuous probability distribution that satisfies Zipf's law: the
		frequency of an item is inversely proportional to its rank in a
		frequency table.
		
		Parameters
		----------
		a : float or array_like of floats
		    Distribution parameter. Should be greater than 1.
		size : int or tuple of ints, optional
		    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
		    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
		    a single value is returned if ``a`` is a scalar. Otherwise,
		    ``np.array(a).size`` samples are drawn.
		
		Returns
		-------
		out : ndarray or scalar
		    Drawn samples from the parameterized Zipf distribution.
		
		See Also
		--------
		scipy.stats.zipf : probability density function, distribution, or
		    cumulative density function, etc.
		
		Notes
		-----
		The probability density for the Zipf distribution is
		
		.. math:: p(x) = \frac{x^{-a}}{\zeta(a)},
		
		where :math:`\zeta` is the Riemann Zeta function.
		
		It is named for the American linguist George Kingsley Zipf, who noted
		that the frequency of any word in a sample of a language is inversely
		proportional to its rank in the frequency table.
		
		References
		----------
		.. [1] Zipf, G. K., "Selected Studies of the Principle of Relative
		       Frequency in Language," Cambridge, MA: Harvard Univ. Press,
		       1932.
		
		Examples
		--------
		Draw samples from the distribution:
		
		>>> a = 2. # parameter
		>>> s = np.random.zipf(a, 1000)
		
		Display the histogram of the samples, along with
		the probability density function:
		
		>>> import matplotlib.pyplot as plt
		>>> from scipy import special
		
		Truncate s values at 50 so plot is interesting:
		
		>>> count, bins, ignored = plt.hist(s[s<50], 50, density=True)
		>>> x = np.arange(1., 50.)
		>>> y = x**(-a) / special.zetac(a)
		>>> plt.plot(x, y/max(y), linewidth=2, color='r')
		>>> plt.show()
	**/
	static public function zipf(args:haxe.extern.Rest<Dynamic>):Dynamic;
}